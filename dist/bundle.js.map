{"version":3,"sources":["webpack:///dist/bundle.js","webpack:///webpack/bootstrap c5877cff6679273a3361","webpack:///./bin/index.jsx","webpack:///./bin/components/bar.jsx","webpack:///./bin/common/component/component.jsx","webpack:///./~/inferno-component/inferno-component.js","webpack:///./~/inferno/dist/inferno-component.js","webpack:///./bin/common/component/styler.jsx","webpack:///./~/j2c/dist/j2c.commonjs.js","webpack:///./~/mobx-inferno/index.js","webpack:///./~/mobx/lib/mobx.js","webpack:///./~/inferno/inferno.js","webpack:///./~/inferno/dist/inferno.js","webpack:///./~/inferno-dom/inferno-dom.js","webpack:///./~/inferno/dist/inferno-dom.js","webpack:///./~/inferno-create-class/inferno-create-class.js","webpack:///./~/inferno/dist/inferno-create-class.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","bar_1","inferno_dom_1","bp0","Inferno","createBlueprint","tag","arg","render","default","document","body","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","_typeof","Symbol","iterator","obj","__decorate","decorators","desc","d","arguments","r","getOwnPropertyDescriptor","Reflect","decorate","__metadata","k","v","metadata","component_1","mobx_inferno_1","bp5","attrs","children","bp4","bp3","bp2","bp1","className","Bar","_component_1$default","this","getPrototypeOf","background","style","open","observer","inferno_component_1","styler_1","StyledComponent","_inferno_component_1$","styled","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","global","factory","undefined","isNullOrUndefined","isUndefined","isNull","VPlaceholder","placeholder","dom","createVPlaceholder","constructDefaults","string","object","split","forEach","Lifecycle","_listeners","scrollX","scrollY","screenHeight","screenWidth","getActiveNode","activeElement","resetActiveNode","activeNode","focus","queueStateChanges","component","newState","callback","stateKey","_pendingState","_pendingSetState","state","assign","applyState","force","_deferSetState","_blockRender","pendingState","prevState","nextState","nextNode","_updateComponent","NO_RENDER","_lastNode","lastNode","parentDom","parentNode","subLifecycle","_patch","context","_componentToDOMNodeMap","set","_parentNode","componentDidUpdate","trigger","isBrowser","window","xlinkNS","xmlNS","strictProps","booleanProps","namespaces","isUnitlessNumber","screen","width","height","lastScrollTime","onscroll","performance","now","resize","refresh","addListener","push","this$1","noOp","Component","refs","_blockSetState","_unmounted","_parentComponent","forceUpdate","Error","setState","componentDidMount","componentWillMount","componentWillUnmount","shouldComponentUpdate","componentWillReceiveProps","componentWillUpdate","getChildContext","prevProps","nextProps","shouldUpdate","cleanStyle","s","replace","attach","_len","Array","_key","scoped","j2c_1","sheet","dispatchStyle","clean","computedStyle","componentStyle","cartesian","a","b","selectorP","res","j","own","concat","test","decamelize","match","toLowerCase","declarations","o","buf","prefix","vendors","local","ns","kk","type","valueOf","ARRAY","OBJECT","map","l","join","at","rawPrefix","slice","findClass","exec","JSON","stringify","e","parent","emptyArray","statements","inDeclaration","STRING","j2c","finalize","extensions","use","args","suffix","scope_root","counter","locals","child","nameList","lastIndexOf","space","dot","name","String","inline","decl","val","kv","emptyObject","toString","hasOwnProperty","Math","floor","random","x","rule","params","block","_at","bind","apply","__WEBPACK_AMD_DEFINE_ARRAY__","mrFactory","mobx","InfernoDOM","InfernoComponent","createClass","findDOMNode","reportRendering","node","componentByNodeRegistery","renderReporter","emit","event","renderTime","__$mobRenderEnd","__$mobRenderStart","totalTime","Date","trackComponents","WeakMap","isDevtoolsEnabled","EventEmitter","listeners","patch","funcName","base","mixinFunc","reactiveMixin","arg1","arg2","isArray","inject","componentClass","isReactClass","isPrototypeOf","displayName","contextTypes","getDefaultProps","defaultProps","isMobXReactObserver","createStoreInjector","grabStoresFn","Injector","newProps","mobxStores","universal","createElement","PropTypesAny","wrappedComponent","storesNames","grabStoresByName","storeNames","baseStores","storeName","on","cb","idx","indexOf","splice","data","fn","specialReactKeys","ref","initialRender","reaction","Reaction","isRenderingPending","componentWillReact","__$mobxIsUnmounted","reactiveRender","$mobx","rendering","track","extras","allowStateChanges","baseRender","_reactInternalInstance","_rootNodeID","dispose","delete","isScheduled","keys","newValue","isObservable","Provider","Children","only","stores","childContextTypes","propTypes","observableArray","observableMap","observableObject","arrayOrObservableArray","objectOrObservableObject","action","arg3","arg4","createAction","namedActionDecorator","prop","actionFieldDecorator","runInAction","actionName","scope","invariant","executeAction","isAction","thing","isMobxAction","autorun","reactionRunner","view","getNextId","assertUnwrapped","schedule","getDisposer","when","predicate","effect","disposer","prevUntracked","untrackedStart","untrackedEnd","autorunUntil","deprecated","autorunAsync","func","delay","setTimeout","isDisposed","arg5","arg6","changed","unwrappedExpression","valueDidChange","compareStructural","nextValue","firstTime","fireImmediately","expression","_a","getValueModeFromValue","ValueMode","Reference","valueMode","Structure","computed","targetOrExpr","keyOrScope","baseDescriptor","options","computedExpr","computedDecorator","expr","Recursive","mode","ComputedValue","throwingComputedValueSetter","createTransformer","transformer","onCleanup","objectCache","resetId","globalState","Transformer","_super","sourceIdentifier","sourceObject","__extends","onBecomeUnobserved","lastValue","identifier","getMemoizationId","reactiveTransformer","get","tid","$transformId","addHiddenProp","isComputingDerivation","extendObservable","properties","_i","ObservableMap","propSet","extendObservableHelper","adm","asObservableObject","isPropertyConfigurable","setObservableObjectInstanceProperty","getDependencyTree","property","nodeToDependencyTree","getAtom","result","observing","dependencies","unique","getObserverTree","nodeToObserverTree","observers","asArray","intercept","propOrHandler","handler","interceptProperty","interceptInterceptable","isPlainObject","isObservableObject","getAdministration","observable","ObservableArray","values","BaseAtom","observableDecorator","assertPropertyConfigurable","decoratorImpl","sourceType","ValueType","getTypeOfValue","PlainObject","makeChildObservable","ComplexObject","ObservableValue","ComplexFunction","ViewFunction","observe","propOrCb","cbOrFire","observeObservableProperty","observeObservable","listener","toJS","source","detectCycles","__alreadySeen","cache","RegExp","toAdd","res_1","toJSON","log","msg","whyRun","derivationStack","ds","startTime","notifySpy","isSpyEnabled","flattendArgs","spyReportStart","transactionStart","prevAllowStateChanges","allowStateChangesStart","allowStateChangesEnd","transactionEnd","spyReportEnd","time","useStrict","strict","strictMode","prev","propagateAtomReady","atom","isDirty","propagateReadiness","isTracking","checkIfStateModificationsAreAllowed","notifyDependencyStale","derivation","dependencyStaleCount","propagateStaleness","notifyDependencyReady","dependencyDidChange","dependencyChangeCount","onDependenciesReady","trackDerivedFunction","f","prevObserving","unboundDepsCount","runId","prevTracking","hasException","message","spyReport","resetGlobalState","bindDependencies","prevLength","newLength","diffValue","dep","addObserver","removeObserver","clearObserving","obs","untracked","registerGlobals","defaultGlobals","MobXGlobals","persistentKeys","add","remove","reportObserved","lastAccessedBy","os","staleObservers","valueDidActuallyChange","runReactions","isRunningReactions","inTransaction","allReactions","pendingReactions","iterations","MAX_REACTION_ITERATIONS","remainingReactions","runReaction","spyEnabled","spyListeners","change","objectAssign","END_EVENT","spy","once","trackTransitions","onReport","transaction","thisArg","report","changedAtoms","hasInterceptors","interceptable","interceptors","registerInterceptor","interceptChange","prevU","hasListeners","listenable","changeListeners","registerListener","notifyListeners","asReference","AsReference","asStructure","AsStructure","asFlat","AsFlat","asMap","modifierFunc","defaultMode","Flat","getValueModeFromModifierFunc","parentMode","childMode","createObservableArray","isExtensible","createArrayBufferItem","index","createArraySetter","createArrayGetter","oldValue","array","makeReactiveArrayItem","deepEquals","notifyArrayChildUpdate","spliceWithArray","impl","reserveArrayBuffer","max","OBSERVABLE_ARRAY_BUFFER_SIZE","initialValues","fastArray","isObservableArray","valueModifier","isObservableMap","ObservableObjectAdministration","addHiddenFinalProp","propName","defineObservableProperty","asInstanceProperty","isComputed","generateComputedPropConfig","generateObservablePropConfig","notifyPropertyAddition","config","observablePropertyConfigs","setPropertyValue","computedPropertyConfigs","prepareNewValue","UNCHANGED","notify","setNewValue","runLazyInitializers","_keys","observable_1","_data","_hasMap","getDebugName","observable_2","named","createClassPropertyDecorator","onInitialize","_get","_set","allowCustomArguments","classPropertyDecorator","customArgs","quacksLikeADecorator","__mobxLazyInitializers","value_1","initializer_1","initializer","__mobxDidRunLazyInitializers","newDescriptor","__mobxInitializedProps","typescriptInitializeProperty","outerArgs","iteratorSymbol","arrayAsIterator","IS_ITERATING_MARKER","done","declareIterator","prototType","iteratorFactory","mobxGuid","check","deprecatedMessages","invoked","list","item","joinStrings","things","limit","separator","sliced","makeNonEnumerable","propNames","getEnumerableKeys","aIsArray","__","_","originalDescriptor","wrappedAction","decoratorArgs","baseValue","prevA","SimpleSet","reportChanged","reportStale","reportReady","Atom","onBecomeObservedHandler","onBecomeUnobservedHandler","noop","isBeingTracked","tracking","RunReason","isLazy","isComputing","__mapid","peek","trackAndCompute","_this","prevValue","runReason","INVALIDATED","REQUIRED","PEEK","NOT_RUNNING","requiredBy","runReasonTexts","EMPTY_DERIVATION_SET","version","__mobservableTrackingStack","__mobservableViewStack","__mobxGlobal","onInvalidate","EMPTY_ARRAY","_isScheduled","_isTrackPending","_isRunning","safariPrototypeSetterInheritanceBug","StubArray","ObservableArrayAdministration","owned","lastKnownLength","added","addedCount","removed","removedCount","getArrayLength","setArrayLength","currentLength","updateArrayLength","oldLength","delta","deleteCount","newItems","min","lengthDelta","notifyArraySplice","ENTRY_0","clear","arrays","find","fromIndex","items","pop","shift","unshift","reverse","clone","sort","compareFn","toLocaleString","baseFunc","ObservableMapMarker","initialData","valueModeFunc","_valueMode","merge","_has","has","isValidKey","_updateHasMapEntry","assertValidKey","hasKey","_updateValue","_addValue","entry","entries","other","toJs","hasUnreportedChange","childmode","unwrappedValue","size","SimpleEventEmitter","subscription","freeze","isAttrAnEvent$1","attr","VNode","blueprint","bp","events","hooks","clipData","createVNode","isAttrAnEvent","isAttrAHook","hook","isAttrAComponentHook","shape","childrenType","tagIsDynamic","childrenIsDynamic","attrsIsDynamic","hooksIsDynamic","eventsIsDynamic","keyIsDynamic","styleIsDynamic","classNameIsDynamic","spread","hasSpread","lazy","pool","isComponent","hasAttrs","hasHooks","hasEvents","hasStyle","hasClassName","attrKeys","eventKeys","isSVG","vNode","attrs$1","events$1","hooks$1","_spread","substring","VText","text","createVText","documentCreateElement","createElementNS","createUniversalElement","createStaticAttributes","setAttribute","setAttrs","setTag","setStyle","setClassName","setChildren","setHooks","setEvents","setKey","addChildrenToProps","isChildrenArray","isStatefulComponent","isStringOrNumber","isString","isNumber","isInvalidNode","isFunction","isTrue","deepScanChildrenForNode","getRefInstance$1","recycle","lifecycle","recycledNode","unmount","input","isVList","unmountVList","isVNode","unmountVNode","vList","removePointer","itemsLength","pointer","removeChild","shallow","instanceHooks","instanceChildren","componentToDOMNodeMap","willDetach","VList","createVList","isVText","isVPlaceholder","insertOrAppend","newNode","appendChild","insertBefore","replaceVListWithNode","replaceNode","appendText","singleChild","createTextNode","textContent","firstChild","textNode","textNode$1","replaceWithNewNode","lastInstance","instanceLastNode","mount","nextDom","lastDom","replaceChild","normalise","normaliseChild","innerHTML","recyclingEnabled","removeEvents","lastEventKeys","removeAllChildren","childrenLength","isKeyed","lastChildren","nextChildren","complex","selectOptionValueIfNeeded","vdom","selected","len","selectValue","i$1","len$1","handleAttachedHooks","created","attached","setValueProperty","setFormElementProperties","nextTag","inputType","checked","mountVPlaceholder","mountVText","mountVList","mountVNode$1","normalisedInput","mountVNodeWithoutBlueprint","mountVNodeWithBlueprint","createDocumentFragment","mountArrayChildren","vText","vPlaceholder","handleSelects","mountBlueprintAttrs","newKeys","mountAttributes","mountBlueprintEvents","mountEvents","mountComponent","handleLazyAttached","mountChildren","patchStyle","mountRef","refValue","childContext","node$1","patchAttribute","lastInput","nextInput","nodeValue","patchVList","patchVFragment","patchVText","patchVNode","mountVNode","patchTextNode","patchRef","patchChildren","patchKeyedChildren","patchNonKeyedChildren","lastChild","lastVNode","nextVNode","skipLazyCheck","lastBp","nextBp","patchVNodeWithoutBlueprint","patchVNodeWithBlueprint","nextHooks","willUpdate","lastTag","lastNodeInstance","instance$1","newDom","patchComponent","lastChildrenType","nextChildrenType","pending","top","setClipNode","bottom","patchAttributes","patchEvents","nextClassName","removeAttribute","nextStyle","lastStyle","didUpdate","nextHooksDefined","_instance","lastAttrKeys","nextAttrKeys","nextAttrs","lastAttrs","nextAttrsIsUndef","lastAttrsIsNotUndef","nextAttrsKeys","attrKeysLength","lastAttrVal","nextAttrVal","lastAttrsKeys","attrKeysLength$1","attr$1","getRefInstance","lastAttrValue","nextAttrValue","cssText","styleKeys","styleKeys$1","style$1","value$1","lastStyleKeys","i$2","style$2","lastEvents","nextEvents","_lastEventKeys","_nextEventKeys","nextEventsDefined","lastEventsDefined","nextEventKeys","lastEvent","nextEvent","event$1","attrName","lastHtml","__html","nextHtml","eventData","removeAttributeNS","setAttributeNS","hasBlueprint","lastProps","componentShouldUpdate","nextNode$1","lastVList","nextVList","lastItems","nextItems","parentVList","lastChildrenLength","nextChildrenLength","commonLength","nextChild","lastVFragment","nextVFragment","lastVText","nextVText","nextText","lastEndIndex","nextEndIndex","lastStartIndex","nextStartIndex","lastStartNode","nextStartNode","nextEndNode","lastEndNode","aLength","bLength","sources","moved","removeOffset","lastTarget","prevItemsMap","Map","pos","seq","lis_algorithm","u","rect","getBoundingClientRect","left","right","hydrateChild","childNodes","domNode","nodeType","newDomNode","rebuild","rebuild$1","hydrateNode","getChildNodesWithoutComments","rawChildNodes","rawChild","hydrateComponent","isRoot","tagName","hydrate","rootNode","querySelector","documetBody","root","roots","F","extend","all","bindAll","ctx","__bound","AUTOBIND_BLACKLIST","Cl","getInitialState","componentWillRecieveProps","componentDidUnmount"],"mappings":"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","file":"./dist/bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar bar_1 = __webpack_require__(1);\n\tvar inferno_dom_1 = __webpack_require__(11);\n\tvar bp0 = Inferno.createBlueprint({\n\t  tag: {\n\t    arg: 0\n\t  }\n\t});\n\tinferno_dom_1.render(bp0(bar_1.default), document.body);\n\t//# sourceMappingURL=index.jsx.map\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n\t    var c = arguments.length,\n\t        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n\t        d;\n\t    if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n\t        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\tvar __metadata = undefined && undefined.__metadata || function (k, v) {\n\t    if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t};\n\tvar component_1 = __webpack_require__(2);\n\tvar mobx_inferno_1 = __webpack_require__(7);\n\tvar bp5 = Inferno.createBlueprint({\n\t    tag: \"div\",\n\t    attrs: {\n\t        arg: 0\n\t    },\n\t    children: {\n\t        arg: 1\n\t    }\n\t});\n\tvar bp4 = Inferno.createBlueprint({\n\t    tag: \"div\",\n\t    children: {\n\t        arg: 0\n\t    }\n\t});\n\tvar bp3 = Inferno.createBlueprint({\n\t    tag: \"div\",\n\t    children: {\n\t        arg: 0\n\t    }\n\t});\n\tvar bp2 = Inferno.createBlueprint({\n\t    tag: \"div\",\n\t    children: {\n\t        arg: 0\n\t    }\n\t});\n\tvar bp1 = Inferno.createBlueprint({\n\t    tag: \"div\",\n\t    children: {\n\t        arg: 0\n\t    }\n\t});\n\tvar bp0 = Inferno.createBlueprint({\n\t    tag: \"div\",\n\t    className: {\n\t        arg: 0\n\t    },\n\t    children: {\n\t        arg: 1\n\t    }\n\t});\n\tvar Bar = function (_component_1$default) {\n\t    _inherits(Bar, _component_1$default);\n\t\n\t    function Bar(props) {\n\t        _classCallCheck(this, Bar);\n\t\n\t        return _possibleConstructorReturn(this, Object.getPrototypeOf(Bar).call(this, props));\n\t    }\n\t\n\t    _createClass(Bar, [{\n\t        key: \"componentStyle\",\n\t        value: function componentStyle() {\n\t            return {\n\t                background: 'green'\n\t            };\n\t        }\n\t    }, {\n\t        key: \"render\",\n\t        value: function render() {\n\t            return bp0(this.style, [bp1([bp2(\"PMENU\"), bp3(\"STRUCTURE\"), bp4(\"ADD\")]), bp5({\n\t                open: this.props.children.length > 0\n\t            }, this.props.children)]);\n\t        }\n\t    }]);\n\t\n\t    return Bar;\n\t}(component_1.default);\n\tBar = __decorate([mobx_inferno_1.observer, __metadata('design:paramtypes', [Object])], Bar);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = Bar;\n\t//# sourceMappingURL=bar.jsx.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n\t    var c = arguments.length,\n\t        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n\t        d;\n\t    if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n\t        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\tvar __metadata = undefined && undefined.__metadata || function (k, v) {\n\t    if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t};\n\tvar inferno_component_1 = __webpack_require__(3);\n\tvar styler_1 = __webpack_require__(5);\n\tvar bp0 = Inferno.createBlueprint({\n\t    tag: \"div\",\n\t    className: {\n\t        arg: 0\n\t    }\n\t});\n\tvar StyledComponent = function (_inferno_component_1$) {\n\t    _inherits(StyledComponent, _inferno_component_1$);\n\t\n\t    function StyledComponent(props) {\n\t        _classCallCheck(this, StyledComponent);\n\t\n\t        return _possibleConstructorReturn(this, Object.getPrototypeOf(StyledComponent).call(this, props));\n\t    }\n\t\n\t    _createClass(StyledComponent, [{\n\t        key: \"componentStyle\",\n\t        value: function componentStyle() {\n\t            return {\n\t                background: 'red'\n\t            };\n\t        }\n\t    }, {\n\t        key: \"render\",\n\t        value: function render() {\n\t            return bp0(this.style);\n\t        }\n\t    }]);\n\t\n\t    return StyledComponent;\n\t}(inferno_component_1.default);\n\tStyledComponent = __decorate([styler_1.styled, __metadata('design:paramtypes', [Object])], StyledComponent);\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.default = StyledComponent;\n\t//# sourceMappingURL=component.jsx.map\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(4);\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/*!\n\t * inferno-component v0.7.25\n\t * (c) 2016 Dominic Gannaway\n\t * Released under the MIT License.\n\t */\n\t(function (global, factory) {\n\t\t( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.InfernoComponent = factory();\n\t})(undefined, function () {\n\t\t'use strict';\n\t\n\t\tvar NO_RENDER = 'NO_RENDER';\n\t\n\t\t// Runs only once in applications lifetime\n\t\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\t\n\t\tfunction isNullOrUndefined(obj) {\n\t\t\treturn isUndefined(obj) || isNull(obj);\n\t\t}\n\t\n\t\tfunction isNull(obj) {\n\t\t\treturn obj === null;\n\t\t}\n\t\n\t\tfunction isUndefined(obj) {\n\t\t\treturn obj === undefined;\n\t\t}\n\t\n\t\tfunction VPlaceholder() {\n\t\t\tthis.placeholder = true;\n\t\t\tthis.dom = null;\n\t\t}\n\t\n\t\tfunction createVPlaceholder() {\n\t\t\treturn new VPlaceholder();\n\t\t}\n\t\n\t\tvar documetBody = isBrowser ? document.body : null;\n\t\n\t\tfunction constructDefaults(string, object, value) {\n\t\t\t/* eslint no-return-assign: 0 */\n\t\t\tstring.split(',').forEach(function (i) {\n\t\t\t\treturn object[i] = value;\n\t\t\t});\n\t\t}\n\t\n\t\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\t\tvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\n\t\tvar strictProps = {};\n\t\tvar booleanProps = {};\n\t\tvar namespaces = {};\n\t\tvar isUnitlessNumber = {};\n\t\n\t\tconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\n\t\tconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\n\t\tconstructDefaults('volume,value', strictProps, true);\n\t\tconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,selected,readonly,multiple,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\n\t\tconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\t\n\t\tvar screenWidth = isBrowser && window.screen.width;\n\t\tvar screenHeight = isBrowser && window.screen.height;\n\t\tvar scrollX = 0;\n\t\tvar scrollY = 0;\n\t\tvar lastScrollTime = 0;\n\t\n\t\tif (isBrowser) {\n\t\t\twindow.onscroll = function () {\n\t\t\t\tscrollX = window.scrollX;\n\t\t\t\tscrollY = window.scrollY;\n\t\t\t\tlastScrollTime = performance.now();\n\t\t\t};\n\t\n\t\t\twindow.resize = function () {\n\t\t\t\tscrollX = window.scrollX;\n\t\t\t\tscrollY = window.scrollY;\n\t\t\t\tscreenWidth = window.screen.width;\n\t\t\t\tscreenHeight = window.screen.height;\n\t\t\t\tlastScrollTime = performance.now();\n\t\t\t};\n\t\t}\n\t\n\t\tfunction Lifecycle() {\n\t\t\tthis._listeners = [];\n\t\t\tthis.scrollX = null;\n\t\t\tthis.scrollY = null;\n\t\t\tthis.screenHeight = screenHeight;\n\t\t\tthis.screenWidth = screenWidth;\n\t\t}\n\t\n\t\tLifecycle.prototype = {\n\t\t\trefresh: function refresh() {\n\t\t\t\tthis.scrollX = isBrowser && window.scrollX;\n\t\t\t\tthis.scrollY = isBrowser && window.scrollY;\n\t\t\t},\n\t\t\taddListener: function addListener(callback) {\n\t\t\t\tthis._listeners.push(callback);\n\t\t\t},\n\t\t\ttrigger: function trigger() {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tfor (var i = 0; i < this._listeners.length; i++) {\n\t\t\t\t\tthis$1._listeners[i]();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tvar noOp = 'Inferno Error: Can only update a mounted or mounting component. This usually means you called setState() or forceUpdate() on an unmounted component. This is a no-op.';\n\t\n\t\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\t\tfunction getActiveNode() {\n\t\t\treturn document.activeElement;\n\t\t}\n\t\n\t\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\t\tfunction resetActiveNode(activeNode) {\n\t\t\tif (activeNode !== document.body && document.activeElement !== activeNode) {\n\t\t\t\tactiveNode.focus(); // TODO: verify are we doing new focus event, if user has focus listener this might trigger it\n\t\t\t}\n\t\t}\n\t\n\t\tfunction queueStateChanges(component, newState, callback) {\n\t\t\tfor (var stateKey in newState) {\n\t\t\t\tcomponent._pendingState[stateKey] = newState[stateKey];\n\t\t\t}\n\t\t\tif (!component._pendingSetState) {\n\t\t\t\tcomponent._pendingSetState = true;\n\t\t\t\tapplyState(component, false, callback);\n\t\t\t} else {\n\t\t\t\tcomponent.state = Object.assign({}, component.state, component._pendingState);\n\t\t\t\tcomponent._pendingState = {};\n\t\t\t}\n\t\t}\n\t\n\t\tfunction applyState(component, force, callback) {\n\t\t\tif ((!component._deferSetState || force) && !component._blockRender) {\n\t\t\t\tcomponent._pendingSetState = false;\n\t\t\t\tvar pendingState = component._pendingState;\n\t\t\t\tvar prevState = component.state;\n\t\t\t\tvar nextState = Object.assign({}, prevState, pendingState);\n\t\t\t\tvar props = component.props;\n\t\n\t\t\t\tcomponent._pendingState = {};\n\t\t\t\tvar nextNode = component._updateComponent(prevState, nextState, props, props, force);\n\t\n\t\t\t\tif (nextNode === NO_RENDER) {\n\t\t\t\t\tnextNode = component._lastNode;\n\t\t\t\t} else if (isNullOrUndefined(nextNode)) {\n\t\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t\t}\n\t\t\t\tvar lastNode = component._lastNode;\n\t\t\t\tvar parentDom = lastNode.dom.parentNode;\n\t\t\t\tvar activeNode = getActiveNode();\n\t\t\t\tvar subLifecycle = new Lifecycle();\n\t\n\t\t\t\tcomponent._patch(lastNode, nextNode, parentDom, subLifecycle, component.context, component, null);\n\t\t\t\tcomponent._lastNode = nextNode;\n\t\t\t\tcomponent._componentToDOMNodeMap.set(component, nextNode.dom);\n\t\t\t\tcomponent._parentNode.dom = nextNode.dom;\n\t\t\t\tcomponent.componentDidUpdate(props, prevState);\n\t\t\t\tsubLifecycle.trigger();\n\t\t\t\tif (!isNullOrUndefined(callback)) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t\tresetActiveNode(activeNode);\n\t\t\t}\n\t\t}\n\t\n\t\tvar Component = function Component(props, context) {\n\t\t\tif (context === void 0) context = {};\n\t\n\t\t\t/** @type {object} */\n\t\t\tthis.props = props || {};\n\t\n\t\t\t/** @type {object} */\n\t\t\tthis.state = {};\n\t\n\t\t\t/** @type {object} */\n\t\t\tthis.refs = {};\n\t\t\tthis._blockRender = false;\n\t\t\tthis._blockSetState = false;\n\t\t\tthis._deferSetState = false;\n\t\t\tthis._pendingSetState = false;\n\t\t\tthis._pendingState = {};\n\t\t\tthis._parentNode = null;\n\t\t\tthis._lastNode = null;\n\t\t\tthis._unmounted = true;\n\t\t\tthis.context = context;\n\t\t\tthis._patch = null;\n\t\t\tthis._parentComponent = null;\n\t\t\tthis._componentToDOMNodeMap = null;\n\t\t};\n\t\n\t\tComponent.prototype.render = function render() {};\n\t\n\t\tComponent.prototype.forceUpdate = function forceUpdate(callback) {\n\t\t\tif (this._unmounted) {\n\t\t\t\tthrow Error(noOp);\n\t\t\t}\n\t\t\tapplyState(this, true, callback);\n\t\t};\n\t\n\t\tComponent.prototype.setState = function setState(newState, callback) {\n\t\t\tif (this._unmounted) {\n\t\t\t\tthrow Error(noOp);\n\t\t\t}\n\t\t\tif (this._blockSetState === false) {\n\t\t\t\tqueueStateChanges(this, newState, callback);\n\t\t\t} else {\n\t\t\t\tthrow Error('Inferno Warning: Cannot update state via setState() in componentWillUpdate()');\n\t\t\t}\n\t\t};\n\t\n\t\tComponent.prototype.componentDidMount = function componentDidMount() {};\n\t\n\t\tComponent.prototype.componentWillMount = function componentWillMount() {};\n\t\n\t\tComponent.prototype.componentWillUnmount = function componentWillUnmount() {};\n\t\n\t\tComponent.prototype.componentDidUpdate = function componentDidUpdate() {};\n\t\n\t\tComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate() {\n\t\t\treturn true;\n\t\t};\n\t\n\t\tComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps() {};\n\t\n\t\tComponent.prototype.componentWillUpdate = function componentWillUpdate() {};\n\t\n\t\tComponent.prototype.getChildContext = function getChildContext() {};\n\t\n\t\tComponent.prototype._updateComponent = function _updateComponent(prevState, nextState, prevProps, nextProps, force) {\n\t\t\tif (this._unmounted === true) {\n\t\t\t\tthis._unmounted = false;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!isNullOrUndefined(nextProps) && isNullOrUndefined(nextProps.children)) {\n\t\t\t\tnextProps.children = prevProps.children;\n\t\t\t}\n\t\t\tif (prevProps !== nextProps || prevState !== nextState || force) {\n\t\t\t\tif (prevProps !== nextProps) {\n\t\t\t\t\tthis._blockRender = true;\n\t\t\t\t\tthis.componentWillReceiveProps(nextProps);\n\t\t\t\t\tthis._blockRender = false;\n\t\t\t\t\tif (this._pendingSetState) {\n\t\t\t\t\t\tnextState = Object.assign({}, nextState, this._pendingState);\n\t\t\t\t\t\tthis._pendingSetState = false;\n\t\t\t\t\t\tthis._pendingState = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar shouldUpdate = this.shouldComponentUpdate(nextProps, nextState);\n\t\n\t\t\t\tif (shouldUpdate !== false || force) {\n\t\t\t\t\tthis._blockSetState = true;\n\t\t\t\t\tthis.componentWillUpdate(nextProps, nextState);\n\t\t\t\t\tthis._blockSetState = false;\n\t\t\t\t\tthis.props = nextProps;\n\t\t\t\t\tthis.state = nextState;\n\t\t\t\t\treturn this.render();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NO_RENDER;\n\t\t};\n\t\n\t\treturn Component;\n\t});\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tvar j2c_1 = __webpack_require__(6);\n\tvar style = '';\n\tfunction cleanStyle(s) {\n\t    return s.replace(/\\n/g, '');\n\t}\n\tfunction attach() {\n\t    for (var _len = arguments.length, s = Array(_len), _key = 0; _key < _len; _key++) {\n\t        s[_key] = arguments[_key];\n\t    }\n\t\n\t    var scoped = j2c_1.sheet(s);\n\t    style += scoped;\n\t    return scoped;\n\t}\n\texports.attach = attach;\n\tvar bp0 = Inferno.createBlueprint({\n\t    tag: 'style',\n\t    children: {\n\t        arg: 0\n\t    }\n\t});\n\tvar bp1 = Inferno.createBlueprint({\n\t    tag: 'style',\n\t    children: {\n\t        arg: 0\n\t    }\n\t});\n\tfunction dispatchStyle() {\n\t    var clean = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\t\n\t    if (!clean) {\n\t        return bp0(style);\n\t    }\n\t    return bp1(cleanStyle(style));\n\t}\n\texports.dispatchStyle = dispatchStyle;\n\tfunction styled(target) {\n\t    if (typeof target.computedStyle === 'function') {\n\t        target.style = attach(target.componentStyle());\n\t    } else {\n\t        target.style = {};\n\t    }\n\t}\n\texports.styled = styled;\n\t//# sourceMappingURL=styler.jsx.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar emptyObject = {};\n\tvar emptyArray = [];\n\tvar type = emptyObject.toString;\n\tvar own = emptyObject.hasOwnProperty;\n\tvar OBJECT = type.call(emptyObject);\n\tvar ARRAY = type.call(emptyArray);\n\tvar STRING = type.call('');\n\t/*/-inline-/*/\n\t// function cartesian(a, b, res, i, j) {\n\t//   res = [];\n\t//   for (j in b) if (own.call(b, j))\n\t//     for (i in a) if (own.call(a, i))\n\t//       res.push(a[i] + b[j]);\n\t//   return res;\n\t// }\n\t/*/-inline-/*/\n\t\n\t/* /-statements-/*/\n\tfunction cartesian(a, b, selectorP, res, i, j) {\n\t  res = [];\n\t  for (j in b) {\n\t    if (own.call(b, j)) for (i in a) {\n\t      if (own.call(a, i)) res.push(concat(a[i], b[j], selectorP));\n\t    }\n\t  }return res;\n\t}\n\t\n\tfunction concat(a, b, selectorP) {\n\t  // `b.replace(/&/g, a)` is never falsy, since the\n\t  // 'a' of cartesian can't be the empty string\n\t  // in selector mode.\n\t  return selectorP && (/^[-\\w$]+$/.test(b) && ':-error-bad-sub-selector-' + b || /&/.test(b) && /* never falsy */b.replace(/&/g, a)) || a + b;\n\t}\n\t\n\tfunction decamelize(match) {\n\t  return '-' + match.toLowerCase();\n\t}\n\t\n\t/**\n\t * Handles the property:value; pairs.\n\t *\n\t * @param {array|object|string} o - the declarations.\n\t * @param {string[]} buf - the buffer in which the final style sheet is built.\n\t * @param {string} prefix - the current property or a prefix in case of nested\n\t *                          sub-properties.\n\t * @param {string} vendors - a list of vendor prefixes.\n\t * @Param {boolean} local - are we in @local or in @global scope.\n\t * @param {object} ns - helper functions to populate or create the @local namespace\n\t *                      and to @extend classes.\n\t * @param {function} ns.e - @extend helper.\n\t * @param {function} ns.l - @local helper.\n\t */\n\t\n\tfunction declarations(o, buf, prefix, vendors, local, ns, /*var*/k, v, kk) {\n\t  if (o == null) return;\n\t  if (/\\$/.test(prefix)) {\n\t    for (kk in prefix = prefix.split('$')) {\n\t      if (own.call(prefix, kk)) {\n\t        declarations(o, buf, prefix[kk], vendors, local, ns);\n\t      }\n\t    }return;\n\t  }\n\t  switch (type.call(o = o.valueOf())) {\n\t    case ARRAY:\n\t      for (k = 0; k < o.length; k++) {\n\t        declarations(o[k], buf, prefix, vendors, local, ns);\n\t      }break;\n\t    case OBJECT:\n\t      // prefix is falsy iif it is the empty string, which means we're at the root\n\t      // of the declarations list.\n\t      prefix = prefix && prefix + '-';\n\t      for (k in o) {\n\t        if (own.call(o, k)) {\n\t          v = o[k];\n\t          if (/\\$/.test(k)) {\n\t            for (kk in k = k.split('$')) {\n\t              if (own.call(k, kk)) declarations(v, buf, prefix + k[kk], vendors, local, ns);\n\t            }\n\t          } else {\n\t            declarations(v, buf, prefix + k, vendors, local, ns);\n\t          }\n\t        }\n\t      }break;\n\t    default:\n\t      // prefix is falsy when it is \"\", which means that we're\n\t      // at the top level.\n\t      // `o` is then treated as a `property:value` pair.\n\t      // otherwise, `prefix` is the property name, and\n\t      // `o` is the value.\n\t      k = prefix.replace(/_/g, '-').replace(/[A-Z]/g, decamelize);\n\t\n\t      if (local && (k == 'animation-name' || k == 'animation')) {\n\t        o = o.split(',').map(function (o) {\n\t          return o.replace(/()(?::global\\(\\s*([-\\w]+)\\s*\\)|()([-\\w]+))/, ns.l);\n\t        }).join(',');\n\t      }\n\t      if (/^animation|^transition/.test(k)) vendors = ['webkit'];\n\t      // '@' in properties also triggers the *ielte7 hack\n\t      // Since plugins dispatch on the /^@/ for at-rules\n\t      // we swap the at for an asterisk\n\t      // http://browserhacks.com/#hack-6d49e92634f26ae6d6e46b3ebc10019a\n\t\n\t      k = k.replace(/^@/, '*');\n\t\n\t      /*/-statements-/*/\n\t      // vendorify\n\t      for (kk = 0; kk < vendors.length; kk++) {\n\t        buf.push('-', vendors[kk], '-', k, k ? ':' : '', o, ';\\n');\n\t      } /*/-statements-/*/\n\t\n\t      buf.push(k, k ? ':' : '', o, ';\\n');\n\t\n\t  }\n\t}\n\t\n\tvar findClass = /()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|(\\.)([-\\w]+))/g;\n\t\n\t/**\n\t * Hanldes at-rules\n\t *\n\t * @param {string} k - The at-rule name, and, if takes both parameters and a\n\t *                     block, the parameters.\n\t * @param {string[]} buf - the buffer in which the final style sheet is built\n\t * @param {string[]} v - Either parameters for block-less rules or their block\n\t *                       for the others.\n\t * @param {string} prefix - the current selector or a prefix in case of nested rules\n\t * @param {string} rawPrefix - as above, but without localization transformations\n\t * @param {string} vendors - a list of vendor prefixes\n\t * @Param {boolean} local - are we in @local or in @global scope?\n\t * @param {object} ns - helper functions to populate or create the @local namespace\n\t *                      and to @extend classes\n\t * @param {function} ns.e - @extend helper\n\t * @param {function} ns.l - @local helper\n\t */\n\t\n\tfunction at(k, v, buf, prefix, rawPrefix, vendors, local, ns) {\n\t  var kk;\n\t  if (/^@(?:namespace|import|charset)$/.test(k)) {\n\t    if (type.call(v) == ARRAY) {\n\t      for (kk = 0; kk < v.length; kk++) {\n\t        buf.push(k, ' ', v[kk], ';\\n');\n\t      }\n\t    } else {\n\t      buf.push(k, ' ', v, ';\\n');\n\t    }\n\t  } else if (/^@keyframes /.test(k)) {\n\t    k = local ? k.replace(\n\t    // generated by script/regexps.js\n\t    /( )(?::global\\(\\s*([-\\w]+)\\s*\\)|()([-\\w]+))/, ns.l) : k;\n\t    // add a @-webkit-keyframes block too.\n\t\n\t    buf.push('@-webkit-', k.slice(1), ' {\\n');\n\t    sheet(v, buf, '', '', ['webkit']);\n\t    buf.push('}\\n');\n\t\n\t    buf.push(k, ' {\\n');\n\t    sheet(v, buf, '', '', vendors, local, ns);\n\t    buf.push('}\\n');\n\t  } else if (/^@extends?$/.test(k)) {\n\t\n\t    /*eslint-disable no-cond-assign*/\n\t    // pick the last class to be extended\n\t    while (kk = findClass.exec(rawPrefix)) {\n\t      k = kk[4];\n\t    } /*eslint-enable no-cond-assign*/\n\t    if (k == null || !local) {\n\t      // we're in a @global{} block\n\t      buf.push('@-error-cannot-extend-in-global-context ', JSON.stringify(rawPrefix), ';\\n');\n\t      return;\n\t    } else if (/^@extends?$/.test(k)) {\n\t      // no class in the selector\n\t      buf.push('@-error-no-class-to-extend-in ', JSON.stringify(rawPrefix), ';\\n');\n\t      return;\n\t    }\n\t    ns.e(type.call(v) == ARRAY ? v.map(function (parent) {\n\t      return parent.replace(/()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|()\\.([-\\w]+))/, ns.l);\n\t    }).join(' ') : v.replace(/()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|()\\.([-\\w]+))/, ns.l), k);\n\t  } else if (/^@(?:font-face$|viewport$|page )/.test(k)) {\n\t    sheet(v, buf, k, k, emptyArray);\n\t  } else if (/^@global$/.test(k)) {\n\t    sheet(v, buf, prefix, rawPrefix, vendors, 0, ns);\n\t  } else if (/^@local$/.test(k)) {\n\t    sheet(v, buf, prefix, rawPrefix, vendors, 1, ns);\n\t  } else if (/^@(?:media |supports |document )./.test(k)) {\n\t    buf.push(k, ' {\\n');\n\t    sheet(v, buf, prefix, rawPrefix, vendors, local, ns);\n\t    buf.push('}\\n');\n\t  } else {\n\t    buf.push('@-error-unsupported-at-rule ', JSON.stringify(k), ';\\n');\n\t  }\n\t}\n\t\n\t/**\n\t * Add rulesets and other CSS statements to the sheet.\n\t *\n\t * @param {array|string|object} statements - a source object or sub-object.\n\t * @param {string[]} buf - the buffer in which the final style sheet is built\n\t * @param {string} prefix - the current selector or a prefix in case of nested rules\n\t * @param {string} rawPrefix - as above, but without localization transformations\n\t * @param {string} vendors - a list of vendor prefixes\n\t * @Param {boolean} local - are we in @local or in @global scope?\n\t * @param {object} ns - helper functions to populate or create the @local namespace\n\t *                      and to @extend classes\n\t * @param {function} ns.e - @extend helper\n\t * @param {function} ns.l - @local helper\n\t */\n\tfunction sheet(statements, buf, prefix, rawPrefix, vendors, local, ns) {\n\t  var k, kk, v, inDeclaration;\n\t\n\t  switch (type.call(statements)) {\n\t\n\t    case ARRAY:\n\t      for (k = 0; k < statements.length; k++) {\n\t        sheet(statements[k], buf, prefix, rawPrefix, vendors, local, ns);\n\t      }break;\n\t\n\t    case OBJECT:\n\t      for (k in statements) {\n\t        v = statements[k];\n\t        if (prefix && /^[-\\w$]+$/.test(k)) {\n\t          if (!inDeclaration) {\n\t            inDeclaration = 1;\n\t            buf.push(prefix || '*', ' {\\n');\n\t          }\n\t          declarations(v, buf, k, vendors, local, ns);\n\t        } else if (/^@/.test(k)) {\n\t          // Handle At-rules\n\t          inDeclaration = inDeclaration && buf.push('}\\n') && 0;\n\t\n\t          at(k, v, buf, prefix, rawPrefix, vendors, local, ns);\n\t        } else {\n\t          // selector or nested sub-selectors\n\t\n\t          inDeclaration = inDeclaration && buf.push('}\\n') && 0;\n\t\n\t          sheet(v, buf, (kk = /,/.test(prefix) || prefix && /,/.test(k)) ? cartesian(prefix.split(','), (local ? k.replace(/()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|(\\.)([-\\w]+))/g, ns.l) : k).split(','), prefix).join(',') : concat(prefix, local ? k.replace(/()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|(\\.)([-\\w]+))/g, ns.l) : k, prefix), kk ? cartesian(rawPrefix.split(','), k.split(','), rawPrefix).join(',') : concat(rawPrefix, k, rawPrefix), vendors, local, ns);\n\t        }\n\t      }\n\t      if (inDeclaration) buf.push('}\\n');\n\t      break;\n\t    case STRING:\n\t      buf.push(prefix || ':-error-no-selector', ' {\\n');\n\t      declarations(statements, buf, '', vendors, local, ns);\n\t      buf.push('}\\n');\n\t  }\n\t}\n\t\n\tvar scope_root = '_j2c_' + Math.floor(Math.random() * 0x100000000).toString(36) + '_' + Math.floor(Math.random() * 0x100000000).toString(36) + '_' + Math.floor(Math.random() * 0x100000000).toString(36) + '_' + Math.floor(Math.random() * 0x100000000).toString(36) + '_';\n\tvar counter = 0;\n\tfunction j2c(res) {\n\t  res = res || {};\n\t  var extensions = [];\n\t\n\t  function finalize(buf, i) {\n\t    for (i = 0; i < extensions.length; i++) {\n\t      buf = extensions[i](buf) || buf;\n\t    }return buf.join('');\n\t  }\n\t\n\t  res.use = function () {\n\t    var args = arguments;\n\t    for (var i = 0; i < args.length; i++) {\n\t      extensions.push(args[i]);\n\t    }\n\t    return res;\n\t  };\n\t  /*/-statements-/*/\n\t  res.sheet = function (ns, statements) {\n\t    if (arguments.length === 1) {\n\t      statements = ns;ns = {};\n\t    }\n\t    var suffix = scope_root + counter++,\n\t        locals = {},\n\t        k,\n\t        buf = [];\n\t    // pick only non-numeric keys since `(NaN != NaN) === true`\n\t    for (k in ns) {\n\t      if (k - 0 != k - 0 && own.call(ns, k)) {\n\t        locals[k] = ns[k];\n\t      }\n\t    }sheet(statements, buf, '', '', emptyArray /*vendors*/\n\t    , 1, // local\n\t    {\n\t      e: function extend(parent, child) {\n\t        var nameList = locals[child];\n\t        locals[child] = nameList.slice(0, nameList.lastIndexOf(' ') + 1) + parent + ' ' + nameList.slice(nameList.lastIndexOf(' ') + 1);\n\t      },\n\t      l: function localize(match, space, global, dot, name) {\n\t        if (global) {\n\t          return space + global;\n\t        }\n\t        if (!locals[name]) locals[name] = name + suffix;\n\t        return space + dot + locals[name].match(/\\S+$/);\n\t      }\n\t    });\n\t    /*jshint -W053 */\n\t    buf = new String(finalize(buf));\n\t    /*jshint +W053 */\n\t    for (k in locals) {\n\t      if (own.call(locals, k)) buf[k] = locals[k];\n\t    }return buf;\n\t  };\n\t  /*/-statements-/*/\n\t  res.inline = function (locals, decl, buf) {\n\t    if (arguments.length === 1) {\n\t      decl = locals;locals = {};\n\t    }\n\t    declarations(decl, buf = [], '', // prefix\n\t    emptyArray, // vendors\n\t    1, {\n\t      l: function localize(match, space, global, dot, name) {\n\t        if (global) return space + global;\n\t        if (!locals[name]) return name;\n\t        return space + dot + locals[name];\n\t      }\n\t    });\n\t    return finalize(buf);\n\t  };\n\t\n\t  res.prefix = function (val, vendors) {\n\t    return cartesian(vendors.map(function (p) {\n\t      return '-' + p + '-';\n\t    }).concat(['']), [val]);\n\t  };\n\t  return res;\n\t}\n\t\n\tj2c.global = function (x) {\n\t  return ':global(' + x + ')';\n\t};\n\t\n\tj2c.kv = kv;\n\tfunction kv(k, v, o) {\n\t  o = {};\n\t  o[k] = v;\n\t  return o;\n\t}\n\t\n\tj2c.at = function at(rule, params, block) {\n\t  if (arguments.length < 3) {\n\t    var _at = at.bind.apply(at, [null].concat([].slice.call(arguments, 0)));\n\t    _at.toString = function () {\n\t      return '@' + rule + ' ' + params;\n\t    };\n\t    return _at;\n\t  } else return kv('@' + rule + ' ' + params, block);\n\t};\n\t\n\tj2c(j2c);\n\tdelete j2c.use;\n\t\n\tmodule.exports = j2c;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\"use strict\";\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t(function () {\n\t    function mrFactory(mobx, Inferno, InfernoDOM, InfernoComponent, createClass) {\n\t        if (!mobx) throw new Error(\"mobx-inferno requires the MobX package\");\n\t        if (!Inferno) throw new Error(\"mobx-inferno requires inferno to be available\");\n\t        if (!InfernoComponent) throw new Error(\"mobx-inferno requires inferno-component to be available\");\n\t\n\t        /**\n\t         * dev tool support\n\t         */\n\t        var isDevtoolsEnabled = false;\n\t\n\t        // WeakMap<Node, Object>;\n\t        var componentByNodeRegistery = typeof WeakMap !== \"undefined\" ? new WeakMap() : undefined;\n\t        var renderReporter = new EventEmitter();\n\t\n\t        function findDOMNode(component) {\n\t            if (InfernoDOM) return InfernoDOM.findDOMNode(component);\n\t            return null;\n\t        }\n\t\n\t        function reportRendering(component) {\n\t            var node = findDOMNode(component);\n\t            if (node && componentByNodeRegistery) componentByNodeRegistery.set(node, component);\n\t\n\t            renderReporter.emit({\n\t                event: 'render',\n\t                renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,\n\t                totalTime: Date.now() - component.__$mobRenderStart,\n\t                component: component,\n\t                node: node\n\t            });\n\t        }\n\t\n\t        function trackComponents() {\n\t            if (typeof WeakMap === \"undefined\") throw new Error(\"[mobx-inferno] tracking components is not supported in this browser.\");\n\t            if (!isDevtoolsEnabled) isDevtoolsEnabled = true;\n\t        }\n\t\n\t        function EventEmitter() {\n\t            this.listeners = [];\n\t        };\n\t        EventEmitter.prototype.on = function (cb) {\n\t            this.listeners.push(cb);\n\t            var self = this;\n\t            return function () {\n\t                var idx = self.listeners.indexOf(cb);\n\t                if (idx !== -1) self.listeners.splice(idx, 1);\n\t            };\n\t        };\n\t        EventEmitter.prototype.emit = function (data) {\n\t            this.listeners.forEach(function (fn) {\n\t                fn(data);\n\t            });\n\t        };\n\t\n\t        /**\n\t         * Utilities\n\t         */\n\t        var specialReactKeys = { children: true, key: true, ref: true };\n\t\n\t        function patch(target, funcName) {\n\t            var base = target[funcName];\n\t            var mixinFunc = reactiveMixin[funcName];\n\t            if (!base) {\n\t                target[funcName] = mixinFunc;\n\t            } else {\n\t                target[funcName] = function () {\n\t                    base.apply(this, arguments);\n\t                    mixinFunc.apply(this, arguments);\n\t                };\n\t            }\n\t        }\n\t\n\t        /**\n\t         * ReactiveMixin\n\t         */\n\t        var reactiveMixin = {\n\t            componentWillMount: function componentWillMount() {\n\t                // Generate friendly name for debugging\n\t                var name = [this.displayName || this.name || this.constructor && (this.constructor.displayName || this.constructor.name) || \"<component>\", \"#\", this._reactInternalInstance && this._reactInternalInstance._rootNodeID, \".render()\"].join(\"\");\n\t\n\t                var baseRender = this.render.bind(this);\n\t                var self = this;\n\t                var reaction = null;\n\t                var isRenderingPending = false;\n\t                function initialRender() {\n\t                    reaction = new mobx.Reaction(name, function () {\n\t                        if (!isRenderingPending) {\n\t                            // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n\t                            // This unidiomatic inferno usage but inferno will correctly warn about this so we continue as usual\n\t                            // See #85 / Pull #44\n\t                            isRenderingPending = true;\n\t\n\t                            if (typeof self.componentWillReact === \"function\") self.componentWillReact(); // TODO: wrap in action?\n\t                            if (self.__$mobxIsUnmounted !== true) {\n\t                                // If we are unmounted at this point, componentWillReact() had a side effect causing the component to unmounted\n\t                                // TODO: remove this check? Then inferno will properly warn about the fact that this should not happen? See #73\n\t                                // However, people also claim this migth happen during unit tests..\n\t                                InfernoComponent.prototype.forceUpdate.call(self);\n\t                            }\n\t                        }\n\t                    });\n\t\n\t                    reactiveRender.$mobx = reaction;\n\t                    self.render = reactiveRender;\n\t                    return reactiveRender();\n\t                }\n\t\n\t                function reactiveRender() {\n\t                    isRenderingPending = false;\n\t                    var rendering;\n\t                    reaction.track(function () {\n\t                        if (isDevtoolsEnabled) self.__$mobRenderStart = Date.now();\n\t                        rendering = mobx.extras.allowStateChanges(false, baseRender);\n\t                        if (isDevtoolsEnabled) self.__$mobRenderEnd = Date.now();\n\t                    });\n\t                    return rendering;\n\t                }\n\t\n\t                this.render = initialRender;\n\t            },\n\t\n\t            componentWillUnmount: function componentWillUnmount() {\n\t                this.render.$mobx && this.render.$mobx.dispose();\n\t                this.__$mobxIsUnmounted = true;\n\t                if (isDevtoolsEnabled) {\n\t                    var node = findDOMNode(this);\n\t                    if (node && componentByNodeRegistery) {\n\t                        componentByNodeRegistery.delete(node);\n\t                    }\n\t                    renderReporter.emit({\n\t                        event: 'destroy',\n\t                        component: this,\n\t                        node: node\n\t                    });\n\t                }\n\t            },\n\t\n\t            componentDidMount: function componentDidMount() {\n\t                if (isDevtoolsEnabled) reportRendering(this);\n\t            },\n\t\n\t            componentDidUpdate: function componentDidUpdate() {\n\t                if (isDevtoolsEnabled) reportRendering(this);\n\t            },\n\t\n\t            shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {\n\t                // TODO: if context changed, return true.., see #18\n\t                // if props or state did change, but a render was scheduled already, no additional render needs to be scheduled\n\t                if (this.render.$mobx && this.render.$mobx.isScheduled() === true) return false;\n\t\n\t                // update on any state changes (as is the default)\n\t                if (this.state !== nextState) return true;\n\t                // update if props are shallowly not equal, inspired by PureRenderMixin\n\t                var keys = Object.keys(this.props);\n\t                var key;\n\t                if (keys.length !== Object.keys(nextProps).length) return true;\n\t                for (var i = keys.length - 1; i >= 0, key = keys[i]; i--) {\n\t                    var newValue = nextProps[key];\n\t                    if (newValue !== this.props[key]) {\n\t                        return true;\n\t                    } else if (newValue && (typeof newValue === \"undefined\" ? \"undefined\" : _typeof(newValue)) === \"object\" && !mobx.isObservable(newValue)) {\n\t                        /**\n\t                         * If the newValue is still the same object, but that object is not observable,\n\t                         * fallback to the default inferno behavior: update, because the object *might* have changed.\n\t                         * If you need the non default behavior, just use the inferno pure render mixin, as that one\n\t                         * will work fine with mobx as well, instead of the default implementation of\n\t                         * observer.\n\t                         */\n\t                        return true;\n\t                    }\n\t                }\n\t                return false;\n\t            }\n\t        };\n\t\n\t        /**\n\t         * Observer function / decorator\n\t         */\n\t        function observer(arg1, arg2) {\n\t            if (typeof arg1 === \"string\") throw new Error(\"Store names should be provided as array\");\n\t            if (Array.isArray(arg1)) {\n\t                // component needs stores\n\t                if (!arg2) {\n\t                    // invoked as decorator\n\t                    return function (componentClass) {\n\t                        return observer(arg1, componentClass);\n\t                    };\n\t                } else {\n\t                    // TODO: deprecate this invocation style\n\t                    return inject.apply(null, arg1)(observer(arg2));\n\t                }\n\t            }\n\t            var componentClass = arg1;\n\t\n\t            // Stateless function component:\n\t            // If it is function but doesn't seem to be an inferno class constructor,\n\t            // wrap it to an inferno class automatically\n\t            if (typeof componentClass === \"function\" && (!componentClass.prototype || !componentClass.prototype.render) && !componentClass.isReactClass && !InfernoComponent.isPrototypeOf(componentClass)) {\n\t                return observer(createClass({\n\t                    displayName: componentClass.displayName || componentClass.name,\n\t                    contextTypes: componentClass.contextTypes,\n\t                    getDefaultProps: function getDefaultProps() {\n\t                        return componentClass.defaultProps;\n\t                    },\n\t                    render: function render() {\n\t                        return componentClass.call(this, this.props, this.context);\n\t                    }\n\t                }));\n\t            }\n\t\n\t            if (!componentClass) throw new Error(\"Please pass a valid component to 'observer'\");\n\t            var target = componentClass.prototype || componentClass;\n\t            [\"componentWillMount\", \"componentWillUnmount\", \"componentDidMount\", \"componentDidUpdate\"].forEach(function (funcName) {\n\t                patch(target, funcName);\n\t            });\n\t\n\t            if (!target.shouldComponentUpdate) target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate;\n\t\n\t            componentClass.isMobXReactObserver = true;\n\t            return componentClass;\n\t        }\n\t\n\t        /**\n\t         * Store provider\n\t         */\n\t        var Provider = createClass({\n\t            displayName: \"Provider\",\n\t\n\t            render: function render() {\n\t                return Inferno.Children.only(this.props.children);\n\t            },\n\t\n\t            getChildContext: function getChildContext() {\n\t                var stores = {};\n\t                // inherit stores\n\t                var baseStores = this.context.mobxStores;\n\t                if (baseStores) for (var key in baseStores) {\n\t                    stores[key] = baseStores[key];\n\t                }\n\t                // add own stores\n\t                for (var key in this.props) {\n\t                    if (!specialReactKeys[key]) stores[key] = this.props[key];\n\t                }return {\n\t                    mobxStores: stores\n\t                };\n\t            },\n\t\n\t            componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n\t                // Maybe this warning is to aggressive?\n\t                if (Object.keys(nextProps).length !== Object.keys(this.props).length) console.warn(\"MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children\");\n\t                for (var key in nextProps) {\n\t                    if (!specialReactKeys[key] && this.props[key] !== nextProps[key]) console.warn(\"MobX Provider: Provided store '\" + key + \"' has changed. Please avoid replacing stores as the change might not propagate to all children\");\n\t                }\n\t            }\n\t        });\n\t\n\t        var PropTypesAny = function PropTypesAny() {};\n\t        Provider.contextTypes = { mobxStores: PropTypesAny };\n\t        Provider.childContextTypes = { mobxStores: PropTypesAny };\n\t\n\t        /**\n\t         * Store Injection\n\t         */\n\t        function createStoreInjector(grabStoresFn, component) {\n\t            var Injector = createClass({\n\t                displayName: \"MobXStoreInjector\",\n\t                render: function render() {\n\t                    var newProps = {};\n\t                    for (var key in this.props) {\n\t                        newProps[key] = this.props[key];\n\t                    }newProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context);\n\t                    return Inferno.universal.createElement(component, newProps);\n\t                }\n\t                // TODO: should have shouldComponentUpdate?\n\t            });\n\t            Injector.contextTypes = { mobxStores: PropTypesAny };\n\t            Injector.wrappedComponent = component;\n\t            return Injector;\n\t        }\n\t\n\t        /**\n\t         * higher order component that injects stores to a child.\n\t         * takes either a varargs list of strings, which are stores read from the context,\n\t         * or a function that manually maps the available stores from the context to props:\n\t         * storesToProps(mobxStores, props, context) => newProps\n\t         */\n\t        function inject() /* fn(stores, nextProps) or ...storeNames */{\n\t            var grabStoresFn;\n\t            if (typeof arguments[0] === \"function\") {\n\t                grabStoresFn = arguments[0];\n\t            } else {\n\t                var storesNames = [];\n\t                for (var i = 0; i < arguments.length; i++) {\n\t                    storesNames[i] = arguments[i];\n\t                }grabStoresFn = grabStoresByName(storesNames);\n\t            }\n\t            return function (componentClass) {\n\t                return createStoreInjector(grabStoresFn, componentClass);\n\t            };\n\t        }\n\t\n\t        function grabStoresByName(storeNames) {\n\t            return function (baseStores, nextProps) {\n\t                storeNames.forEach(function (storeName) {\n\t                    if (storeName in nextProps) // prefer props over stores\n\t                        return;\n\t                    if (!(storeName in baseStores)) throw new Error(\"MobX observer: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n\t                    nextProps[storeName] = baseStores[storeName];\n\t                });\n\t                return nextProps;\n\t            };\n\t        }\n\t\n\t        /**\n\t         * PropTypes\n\t         */\n\t\n\t        function observableTypeChecker(type) {\n\t            return function (props, propName, componentName) {\n\t                if (!mobx['isObservable' + type](props[propName])) {\n\t                    return new Error('Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Expected a mobx observable ' + type + '. Validation failed.');\n\t                }\n\t            };\n\t        }\n\t\n\t        // oneOfType is used for simple isRequired chaining\n\t\n\t        var propTypes = {\n\t            observableArray: PropTypesAny,\n\t            observableMap: PropTypesAny,\n\t            observableObject: PropTypesAny,\n\t            arrayOrObservableArray: PropTypesAny,\n\t            objectOrObservableObject: PropTypesAny\n\t        };\n\t\n\t        /**\n\t         * Export\n\t         */\n\t        return {\n\t            observer: observer,\n\t            Provider: Provider,\n\t            inject: inject,\n\t            propTypes: propTypes,\n\t            renderReporter: renderReporter,\n\t            componentByNodeRegistery: componentByNodeRegistery,\n\t            trackComponents: trackComponents\n\t        };\n\t    }\n\t\n\t    /**\n\t     * UMD\n\t     */\n\t    if (( false ? \"undefined\" : _typeof(exports)) === 'object') {\n\t        module.exports = mrFactory(__webpack_require__(8), __webpack_require__(9), __webpack_require__(11), __webpack_require__(3), __webpack_require__(13));\n\t    } else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8), __webpack_require__(9), __webpack_require__(11), __webpack_require__(3), __webpack_require__(13)], __WEBPACK_AMD_DEFINE_FACTORY__ = (mrFactory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else {\n\t        this.mobxInferno = mrFactory(this['mobx'], this['Inferno'], this['InfernoDOM'], this['InfernoComponent'], this['createClass']);\n\t    }\n\t})();\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar __extends = undefined && undefined.__extends || function (d, b) {\n\t    for (var p in b) {\n\t        if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    }function __() {\n\t        this.constructor = d;\n\t    }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tregisterGlobals();\n\texports.extras = {\n\t    allowStateChanges: allowStateChanges,\n\t    getAtom: getAtom,\n\t    getDebugName: getDebugName,\n\t    getDependencyTree: getDependencyTree,\n\t    getObserverTree: getObserverTree,\n\t    isComputingDerivation: isComputingDerivation,\n\t    isSpyEnabled: isSpyEnabled,\n\t    resetGlobalState: resetGlobalState,\n\t    spyReport: spyReport,\n\t    spyReportEnd: spyReportEnd,\n\t    spyReportStart: spyReportStart,\n\t    trackTransitions: trackTransitions\n\t};\n\texports._ = {\n\t    getAdministration: getAdministration,\n\t    resetGlobalState: resetGlobalState\n\t};\n\tvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n\t    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n\t    var wrappedAction = action(actionName, value);\n\t    addHiddenProp(target, key, wrappedAction);\n\t}, function (key) {\n\t    return this[key];\n\t}, function () {\n\t    invariant(false, \"It is not allowed to assign new values to @action fields\");\n\t}, false, true);\n\tfunction action(arg1, arg2, arg3, arg4) {\n\t    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n\t    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n\t    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n\t    return namedActionDecorator(arg2).apply(null, arguments);\n\t}\n\texports.action = action;\n\tfunction namedActionDecorator(name) {\n\t    return function (target, prop, descriptor) {\n\t        if (descriptor && typeof descriptor.value === \"function\") {\n\t            descriptor.value = createAction(name, descriptor.value);\n\t            descriptor.enumerable = false;\n\t            descriptor.configurable = true;\n\t            return descriptor;\n\t        }\n\t        return actionFieldDecorator(name).apply(this, arguments);\n\t    };\n\t}\n\tfunction runInAction(arg1, arg2, arg3) {\n\t    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n\t    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n\t    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n\t    invariant(typeof fn === \"function\", \"`runInAction` expects a function\");\n\t    invariant(fn.length === 0, \"`runInAction` expects a function without arguments\");\n\t    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n\t    return executeAction(actionName, fn, scope, undefined);\n\t}\n\texports.runInAction = runInAction;\n\tfunction isAction(thing) {\n\t    return typeof thing === \"function\" && thing.isMobxAction === true;\n\t}\n\texports.isAction = isAction;\n\tfunction autorun(arg1, arg2, arg3) {\n\t    var name, view, scope;\n\t    if (typeof arg1 === \"string\") {\n\t        name = arg1;\n\t        view = arg2;\n\t        scope = arg3;\n\t    } else if (typeof arg1 === \"function\") {\n\t        name = arg1.name || \"Autorun@\" + getNextId();\n\t        view = arg1;\n\t        scope = arg2;\n\t    }\n\t    assertUnwrapped(view, \"autorun methods cannot have modifiers\");\n\t    invariant(typeof view === \"function\", \"autorun expects a function\");\n\t    if (scope) view = view.bind(scope);\n\t    var reaction = new Reaction(name, function () {\n\t        this.track(reactionRunner);\n\t    });\n\t    function reactionRunner() {\n\t        view(reaction);\n\t    }\n\t    reaction.schedule();\n\t    return reaction.getDisposer();\n\t}\n\texports.autorun = autorun;\n\tfunction when(arg1, arg2, arg3, arg4) {\n\t    var name, predicate, effect, scope;\n\t    if (typeof arg1 === \"string\") {\n\t        name = arg1;\n\t        predicate = arg2;\n\t        effect = arg3;\n\t        scope = arg4;\n\t    } else if (typeof arg1 === \"function\") {\n\t        name = \"When@\" + getNextId();\n\t        predicate = arg1;\n\t        effect = arg2;\n\t        scope = arg3;\n\t    }\n\t    var disposer = autorun(name, function (r) {\n\t        if (predicate.call(scope)) {\n\t            r.dispose();\n\t            var prevUntracked = untrackedStart();\n\t            effect.call(scope);\n\t            untrackedEnd(prevUntracked);\n\t        }\n\t    });\n\t    return disposer;\n\t}\n\texports.when = when;\n\tfunction autorunUntil(predicate, effect, scope) {\n\t    deprecated(\"`autorunUntil` is deprecated, please use `when`.\");\n\t    return when.apply(null, arguments);\n\t}\n\texports.autorunUntil = autorunUntil;\n\tfunction autorunAsync(arg1, arg2, arg3, arg4) {\n\t    var name, func, delay, scope;\n\t    if (typeof arg1 === \"string\") {\n\t        name = arg1;\n\t        func = arg2;\n\t        delay = arg3;\n\t        scope = arg4;\n\t    } else if (typeof arg1 === \"function\") {\n\t        name = arg1.name || \"AutorunAsync@\" + getNextId();\n\t        func = arg1;\n\t        delay = arg2;\n\t        scope = arg3;\n\t    }\n\t    if (delay === void 0) delay = 1;\n\t    if (scope) func = func.bind(scope);\n\t    var isScheduled = false;\n\t    var r = new Reaction(name, function () {\n\t        if (!isScheduled) {\n\t            isScheduled = true;\n\t            setTimeout(function () {\n\t                isScheduled = false;\n\t                if (!r.isDisposed) r.track(reactionRunner);\n\t            }, delay);\n\t        }\n\t    });\n\t    function reactionRunner() {\n\t        func(r);\n\t    }\n\t    r.schedule();\n\t    return r.getDisposer();\n\t}\n\texports.autorunAsync = autorunAsync;\n\tfunction reaction(arg1, arg2, arg3, arg4, arg5, arg6) {\n\t    var name, expression, effect, fireImmediately, delay, scope;\n\t    if (typeof arg1 === \"string\") {\n\t        name = arg1;\n\t        expression = arg2;\n\t        effect = arg3;\n\t        fireImmediately = arg4;\n\t        delay = arg5;\n\t        scope = arg6;\n\t    } else {\n\t        name = arg1.name || arg2.name || \"Reaction@\" + getNextId();\n\t        expression = arg1;\n\t        effect = arg2;\n\t        fireImmediately = arg3;\n\t        delay = arg4;\n\t        scope = arg5;\n\t    }\n\t    if (fireImmediately === void 0) fireImmediately = false;\n\t    if (delay === void 0) delay = 0;\n\t    var _a = getValueModeFromValue(expression, ValueMode.Reference),\n\t        valueMode = _a[0],\n\t        unwrappedExpression = _a[1];\n\t    var compareStructural = valueMode === ValueMode.Structure;\n\t    if (scope) {\n\t        unwrappedExpression = unwrappedExpression.bind(scope);\n\t        effect = action(name, effect.bind(scope));\n\t    }\n\t    var firstTime = true;\n\t    var isScheduled = false;\n\t    var nextValue = undefined;\n\t    var r = new Reaction(name, function () {\n\t        if (delay < 1) {\n\t            reactionRunner();\n\t        } else if (!isScheduled) {\n\t            isScheduled = true;\n\t            setTimeout(function () {\n\t                isScheduled = false;\n\t                reactionRunner();\n\t            }, delay);\n\t        }\n\t    });\n\t    function reactionRunner() {\n\t        if (r.isDisposed) return;\n\t        var changed = false;\n\t        r.track(function () {\n\t            var v = unwrappedExpression(r);\n\t            changed = valueDidChange(compareStructural, nextValue, v);\n\t            nextValue = v;\n\t        });\n\t        if (firstTime && fireImmediately) effect(nextValue, r);\n\t        if (!firstTime && changed === true) effect(nextValue, r);\n\t        if (firstTime) firstTime = false;\n\t    }\n\t    r.schedule();\n\t    return r.getDisposer();\n\t}\n\texports.reaction = reaction;\n\tvar computedDecorator = createClassPropertyDecorator(function (target, name, _, decoratorArgs, originalDescriptor) {\n\t    invariant(typeof originalDescriptor !== \"undefined\", \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\");\n\t    var baseValue = originalDescriptor.get;\n\t    invariant(typeof baseValue === \"function\", \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\");\n\t    var compareStructural = false;\n\t    if (decoratorArgs && decoratorArgs.length === 1 && decoratorArgs[0].asStructure === true) compareStructural = true;\n\t    var adm = asObservableObject(target, undefined, ValueMode.Recursive);\n\t    defineObservableProperty(adm, name, compareStructural ? asStructure(baseValue) : baseValue, false);\n\t}, function (name) {\n\t    return this.$mobx.values[name].get();\n\t}, throwingComputedValueSetter, false, true);\n\tfunction computed(targetOrExpr, keyOrScope, baseDescriptor, options) {\n\t    if (arguments.length < 3 && typeof targetOrExpr === \"function\") return computedExpr(targetOrExpr, keyOrScope);\n\t    invariant(!baseDescriptor || !baseDescriptor.set, \"@observable properties cannot have a setter: \" + keyOrScope);\n\t    return computedDecorator.apply(null, arguments);\n\t}\n\texports.computed = computed;\n\tfunction computedExpr(expr, scope) {\n\t    var _a = getValueModeFromValue(expr, ValueMode.Recursive),\n\t        mode = _a[0],\n\t        value = _a[1];\n\t    return new ComputedValue(value, scope, mode === ValueMode.Structure, value.name);\n\t}\n\tfunction throwingComputedValueSetter() {\n\t    throw new Error(\"[ComputedValue] It is not allowed to assign new values to computed properties.\");\n\t}\n\tfunction createTransformer(transformer, onCleanup) {\n\t    invariant(typeof transformer === \"function\" && transformer.length === 1, \"createTransformer expects a function that accepts one argument\");\n\t    var objectCache = {};\n\t    var resetId = globalState.resetId;\n\t    var Transformer = function (_super) {\n\t        __extends(Transformer, _super);\n\t        function Transformer(sourceIdentifier, sourceObject) {\n\t            _super.call(this, function () {\n\t                return transformer(sourceObject);\n\t            }, null, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier);\n\t            this.sourceIdentifier = sourceIdentifier;\n\t            this.sourceObject = sourceObject;\n\t        }\n\t        Transformer.prototype.onBecomeUnobserved = function () {\n\t            var lastValue = this.value;\n\t            _super.prototype.onBecomeUnobserved.call(this);\n\t            delete objectCache[this.sourceIdentifier];\n\t            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n\t        };\n\t        return Transformer;\n\t    }(ComputedValue);\n\t    return function (object) {\n\t        if (resetId !== globalState.resetId) {\n\t            objectCache = {};\n\t            resetId = globalState.resetId;\n\t        }\n\t        var identifier = getMemoizationId(object);\n\t        var reactiveTransformer = objectCache[identifier];\n\t        if (reactiveTransformer) return reactiveTransformer.get();\n\t        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n\t        return reactiveTransformer.get();\n\t    };\n\t}\n\texports.createTransformer = createTransformer;\n\tfunction getMemoizationId(object) {\n\t    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n\t    var tid = object.$transformId;\n\t    if (tid === undefined) {\n\t        tid = getNextId();\n\t        addHiddenProp(object, \"$transformId\", tid);\n\t    }\n\t    return tid;\n\t}\n\tfunction expr(expr, scope) {\n\t    if (!isComputingDerivation()) console.warn(\"[mobx.expr] 'expr' should only be used inside other reactive functions.\");\n\t    return computed(expr, scope).get();\n\t}\n\texports.expr = expr;\n\tfunction extendObservable(target) {\n\t    var properties = [];\n\t    for (var _i = 1; _i < arguments.length; _i++) {\n\t        properties[_i - 1] = arguments[_i];\n\t    }\n\t    invariant(arguments.length >= 2, \"extendObservable expected 2 or more arguments\");\n\t    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", \"extendObservable expects an object as first argument\");\n\t    invariant(!(target instanceof ObservableMap), \"extendObservable should not be used on maps, use map.merge instead\");\n\t    properties.forEach(function (propSet) {\n\t        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", \"all arguments of extendObservable should be objects\");\n\t        extendObservableHelper(target, propSet, ValueMode.Recursive, null);\n\t    });\n\t    return target;\n\t}\n\texports.extendObservable = extendObservable;\n\tfunction extendObservableHelper(target, properties, mode, name) {\n\t    var adm = asObservableObject(target, name, mode);\n\t    for (var key in properties) {\n\t        if (properties.hasOwnProperty(key)) {\n\t            if (target === properties && !isPropertyConfigurable(target, key)) continue;\n\t            setObservableObjectInstanceProperty(adm, key, properties[key]);\n\t        }\n\t    }return target;\n\t}\n\tfunction getDependencyTree(thing, property) {\n\t    return nodeToDependencyTree(getAtom(thing, property));\n\t}\n\tfunction nodeToDependencyTree(node) {\n\t    var result = {\n\t        name: node.name\n\t    };\n\t    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n\t    return result;\n\t}\n\tfunction getObserverTree(thing, property) {\n\t    return nodeToObserverTree(getAtom(thing, property));\n\t}\n\tfunction nodeToObserverTree(node) {\n\t    var result = {\n\t        name: node.name\n\t    };\n\t    if (node.observers && node.observers.length > 0) result.observers = node.observers.asArray().map(nodeToObserverTree);\n\t    return result;\n\t}\n\tfunction intercept(thing, propOrHandler, handler) {\n\t    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n\t}\n\texports.intercept = intercept;\n\tfunction interceptInterceptable(thing, handler) {\n\t    if (isPlainObject(thing) && !isObservableObject(thing)) {\n\t        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n\t        return getAdministration(observable(thing)).intercept(handler);\n\t    }\n\t    return getAdministration(thing).intercept(handler);\n\t}\n\tfunction interceptProperty(thing, property, handler) {\n\t    if (isPlainObject(thing) && !isObservableObject(thing)) {\n\t        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n\t        extendObservable(thing, {\n\t            property: thing[property]\n\t        });\n\t        return interceptProperty(thing, property, handler);\n\t    }\n\t    return getAdministration(thing, property).intercept(handler);\n\t}\n\tfunction isObservable(value, property) {\n\t    if (value === null || value === undefined) return false;\n\t    if (property !== undefined) {\n\t        if (value instanceof ObservableMap || value instanceof ObservableArray) throw new Error(\"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\");else if (isObservableObject(value)) {\n\t            var o = value.$mobx;\n\t            return o.values && !!o.values[property];\n\t        }\n\t        return false;\n\t    }\n\t    return !!value.$mobx || value instanceof BaseAtom || value instanceof Reaction || value instanceof ComputedValue;\n\t}\n\texports.isObservable = isObservable;\n\tvar decoratorImpl = createClassPropertyDecorator(function (target, name, baseValue) {\n\t    var prevA = allowStateChangesStart(true);\n\t    if (typeof baseValue === \"function\") baseValue = asReference(baseValue);\n\t    var adm = asObservableObject(target, undefined, ValueMode.Recursive);\n\t    defineObservableProperty(adm, name, baseValue, true);\n\t    allowStateChangesEnd(prevA);\n\t}, function (name) {\n\t    return this.$mobx.values[name].get();\n\t}, function (name, value) {\n\t    setPropertyValue(this, name, value);\n\t}, true, false);\n\tfunction observableDecorator(target, key, baseDescriptor) {\n\t    invariant(arguments.length >= 2 && arguments.length <= 3, \"Illegal decorator config\", key);\n\t    assertPropertyConfigurable(target, key);\n\t    invariant(!baseDescriptor || !baseDescriptor.get, \"@observable can not be used on getters, use @computed instead\");\n\t    return decoratorImpl.apply(null, arguments);\n\t}\n\tfunction observable(v, keyOrScope) {\n\t    if (v === void 0) {\n\t        v = undefined;\n\t    }\n\t    if (typeof arguments[1] === \"string\") return observableDecorator.apply(null, arguments);\n\t    invariant(arguments.length < 3, \"observable expects zero, one or two arguments\");\n\t    if (isObservable(v)) return v;\n\t    var _a = getValueModeFromValue(v, ValueMode.Recursive),\n\t        mode = _a[0],\n\t        value = _a[1];\n\t    var sourceType = mode === ValueMode.Reference ? ValueType.Reference : getTypeOfValue(value);\n\t    switch (sourceType) {\n\t        case ValueType.Array:\n\t        case ValueType.PlainObject:\n\t            return makeChildObservable(value, mode);\n\t        case ValueType.Reference:\n\t        case ValueType.ComplexObject:\n\t            return new ObservableValue(value, mode);\n\t        case ValueType.ComplexFunction:\n\t            throw new Error(\"[mobx.observable] To be able to make a function reactive it should not have arguments. If you need an observable reference to a function, use `observable(asReference(f))`\");\n\t        case ValueType.ViewFunction:\n\t            deprecated(\"Use `computed(expr)` instead of `observable(expr)`\");\n\t            return computed(v, keyOrScope);\n\t    }\n\t    invariant(false, \"Illegal State\");\n\t}\n\texports.observable = observable;\n\tvar ValueType;\n\t(function (ValueType) {\n\t    ValueType[ValueType[\"Reference\"] = 0] = \"Reference\";\n\t    ValueType[ValueType[\"PlainObject\"] = 1] = \"PlainObject\";\n\t    ValueType[ValueType[\"ComplexObject\"] = 2] = \"ComplexObject\";\n\t    ValueType[ValueType[\"Array\"] = 3] = \"Array\";\n\t    ValueType[ValueType[\"ViewFunction\"] = 4] = \"ViewFunction\";\n\t    ValueType[ValueType[\"ComplexFunction\"] = 5] = \"ComplexFunction\";\n\t})(ValueType || (ValueType = {}));\n\tfunction getTypeOfValue(value) {\n\t    if (value === null || value === undefined) return ValueType.Reference;\n\t    if (typeof value === \"function\") return value.length ? ValueType.ComplexFunction : ValueType.ViewFunction;\n\t    if (Array.isArray(value) || value instanceof ObservableArray) return ValueType.Array;\n\t    if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\") return isPlainObject(value) ? ValueType.PlainObject : ValueType.ComplexObject;\n\t    return ValueType.Reference;\n\t}\n\tfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n\t    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n\t}\n\texports.observe = observe;\n\tfunction observeObservable(thing, listener, fireImmediately) {\n\t    if (isPlainObject(thing) && !isObservableObject(thing)) {\n\t        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n\t        return getAdministration(observable(thing)).observe(listener, fireImmediately);\n\t    }\n\t    return getAdministration(thing).observe(listener, fireImmediately);\n\t}\n\tfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n\t    if (isPlainObject(thing) && !isObservableObject(thing)) {\n\t        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n\t        extendObservable(thing, {\n\t            property: thing[property]\n\t        });\n\t        return observeObservableProperty(thing, property, listener, fireImmediately);\n\t    }\n\t    return getAdministration(thing, property).observe(listener, fireImmediately);\n\t}\n\tfunction toJS(source, detectCycles, __alreadySeen) {\n\t    if (detectCycles === void 0) {\n\t        detectCycles = true;\n\t    }\n\t    if (__alreadySeen === void 0) {\n\t        __alreadySeen = null;\n\t    }\n\t    function cache(value) {\n\t        if (detectCycles) __alreadySeen.push([source, value]);\n\t        return value;\n\t    }\n\t    if (source instanceof Date || source instanceof RegExp) return source;\n\t    if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n\t    if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n\t        for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n\t            if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n\t        }\n\t    }\n\t    if (!source) return source;\n\t    if (Array.isArray(source) || source instanceof ObservableArray) {\n\t        var res = cache([]);\n\t        var toAdd = source.map(function (value) {\n\t            return toJS(value, detectCycles, __alreadySeen);\n\t        });\n\t        res.length = toAdd.length;\n\t        for (var i = 0, l = toAdd.length; i < l; i++) {\n\t            res[i] = toAdd[i];\n\t        }return res;\n\t    }\n\t    if (source instanceof ObservableMap) {\n\t        var res_1 = cache({});\n\t        source.forEach(function (value, key) {\n\t            return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n\t        });\n\t        return res_1;\n\t    }\n\t    if (isObservable(source) && source.$mobx instanceof ObservableValue) return toJS(source(), detectCycles, __alreadySeen);\n\t    if (source instanceof ObservableValue) return toJS(source.get(), detectCycles, __alreadySeen);\n\t    if ((typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n\t        var res = cache({});\n\t        for (var key in source) {\n\t            res[key] = toJS(source[key], detectCycles, __alreadySeen);\n\t        }return res;\n\t    }\n\t    return source;\n\t}\n\texports.toJS = toJS;\n\tfunction toJSON(source, detectCycles, __alreadySeen) {\n\t    if (detectCycles === void 0) {\n\t        detectCycles = true;\n\t    }\n\t    if (__alreadySeen === void 0) {\n\t        __alreadySeen = null;\n\t    }\n\t    deprecated(\"toJSON is deprecated. Use toJS instead\");\n\t    return toJS.apply(null, arguments);\n\t}\n\texports.toJSON = toJSON;\n\tfunction log(msg) {\n\t    console.log(msg);\n\t    return msg;\n\t}\n\tfunction whyRun(thing, prop) {\n\t    switch (arguments.length) {\n\t        case 0:\n\t            thing = globalState.derivationStack[globalState.derivationStack.length - 1];\n\t            if (!thing) return log(\"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested it's value.\");\n\t            break;\n\t        case 2:\n\t            thing = getAtom(thing, prop);\n\t            break;\n\t    }\n\t    thing = getAtom(thing);\n\t    if (thing instanceof ComputedValue) return log(thing.whyRun());else if (thing instanceof Reaction) return log(thing.whyRun());else invariant(false, \"whyRun can only be used on reactions and computed values\");\n\t}\n\texports.whyRun = whyRun;\n\tfunction createAction(actionName, fn) {\n\t    invariant(typeof fn === \"function\", \"`action` can only be invoked on functions\");\n\t    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n\t    var res = function res() {\n\t        return executeAction(actionName, fn, this, arguments);\n\t    };\n\t    res.isMobxAction = true;\n\t    return res;\n\t}\n\tfunction executeAction(actionName, fn, scope, args) {\n\t    var ds = globalState.derivationStack;\n\t    invariant(!(ds[ds.length - 1] instanceof ComputedValue), \"Computed values or transformers should not invoke actions or trigger other side effects\");\n\t    var notifySpy = isSpyEnabled();\n\t    var startTime;\n\t    if (notifySpy) {\n\t        startTime = Date.now();\n\t        var l = args && args.length || 0;\n\t        var flattendArgs = new Array(l);\n\t        if (l > 0) for (var i = 0; i < l; i++) {\n\t            flattendArgs[i] = args[i];\n\t        }spyReportStart({\n\t            type: \"action\",\n\t            name: actionName,\n\t            fn: fn,\n\t            target: scope,\n\t            arguments: flattendArgs\n\t        });\n\t    }\n\t    var prevUntracked = untrackedStart();\n\t    transactionStart(actionName, scope, false);\n\t    var prevAllowStateChanges = allowStateChangesStart(true);\n\t    try {\n\t        return fn.apply(scope, args);\n\t    } finally {\n\t        allowStateChangesEnd(prevAllowStateChanges);\n\t        transactionEnd(false);\n\t        untrackedEnd(prevUntracked);\n\t        if (notifySpy) spyReportEnd({ time: Date.now() - startTime });\n\t    }\n\t}\n\tfunction useStrict(strict) {\n\t    if (arguments.length === 0) return globalState.strictMode;else {\n\t        invariant(globalState.derivationStack.length === 0, \"It is not allowed to set `useStrict` when a derivation is running\");\n\t        globalState.strictMode = strict;\n\t        globalState.allowStateChanges = !strict;\n\t    }\n\t}\n\texports.useStrict = useStrict;\n\tfunction allowStateChanges(allowStateChanges, func) {\n\t    var prev = allowStateChangesStart(allowStateChanges);\n\t    var res = func();\n\t    allowStateChangesEnd(prev);\n\t    return res;\n\t}\n\tfunction allowStateChangesStart(allowStateChanges) {\n\t    var prev = globalState.allowStateChanges;\n\t    globalState.allowStateChanges = allowStateChanges;\n\t    return prev;\n\t}\n\tfunction allowStateChangesEnd(prev) {\n\t    globalState.allowStateChanges = prev;\n\t}\n\tfunction propagateAtomReady(atom) {\n\t    invariant(atom.isDirty, \"atom not dirty\");\n\t    atom.isDirty = false;\n\t    propagateReadiness(atom, true);\n\t}\n\tvar BaseAtom = function () {\n\t    function BaseAtom(name) {\n\t        if (name === void 0) {\n\t            name = \"Atom@\" + getNextId();\n\t        }\n\t        this.name = name;\n\t        this.isDirty = false;\n\t        this.staleObservers = [];\n\t        this.observers = new SimpleSet();\n\t        this.diffValue = 0;\n\t        this.lastAccessedBy = 0;\n\t    }\n\t    BaseAtom.prototype.onBecomeUnobserved = function () {};\n\t    BaseAtom.prototype.reportObserved = function () {\n\t        reportObserved(this);\n\t    };\n\t    BaseAtom.prototype.reportChanged = function () {\n\t        if (!this.isDirty) {\n\t            this.reportStale();\n\t            this.reportReady();\n\t        }\n\t    };\n\t    BaseAtom.prototype.reportStale = function () {\n\t        if (!this.isDirty) {\n\t            this.isDirty = true;\n\t            propagateStaleness(this);\n\t        }\n\t    };\n\t    BaseAtom.prototype.reportReady = function () {\n\t        invariant(this.isDirty, \"atom not dirty\");\n\t        if (globalState.inTransaction > 0) globalState.changedAtoms.push(this);else {\n\t            propagateAtomReady(this);\n\t            runReactions();\n\t        }\n\t    };\n\t    BaseAtom.prototype.toString = function () {\n\t        return this.name;\n\t    };\n\t    return BaseAtom;\n\t}();\n\texports.BaseAtom = BaseAtom;\n\tvar Atom = function (_super) {\n\t    __extends(Atom, _super);\n\t    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n\t        if (name === void 0) {\n\t            name = \"Atom@\" + getNextId();\n\t        }\n\t        if (onBecomeObservedHandler === void 0) {\n\t            onBecomeObservedHandler = noop;\n\t        }\n\t        if (onBecomeUnobservedHandler === void 0) {\n\t            onBecomeUnobservedHandler = noop;\n\t        }\n\t        _super.call(this, name);\n\t        this.name = name;\n\t        this.onBecomeObservedHandler = onBecomeObservedHandler;\n\t        this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n\t        this.isBeingTracked = false;\n\t    }\n\t    Atom.prototype.reportObserved = function () {\n\t        _super.prototype.reportObserved.call(this);\n\t        var tracking = globalState.isTracking;\n\t        if (tracking && !this.isBeingTracked) {\n\t            this.isBeingTracked = true;\n\t            this.onBecomeObservedHandler();\n\t        }\n\t        return tracking;\n\t    };\n\t    Atom.prototype.onBecomeUnobserved = function () {\n\t        this.isBeingTracked = false;\n\t        this.onBecomeUnobservedHandler();\n\t    };\n\t    return Atom;\n\t}(BaseAtom);\n\texports.Atom = Atom;\n\tvar ComputedValue = function () {\n\t    function ComputedValue(derivation, scope, compareStructural, name) {\n\t        this.derivation = derivation;\n\t        this.scope = scope;\n\t        this.compareStructural = compareStructural;\n\t        this.isLazy = true;\n\t        this.isComputing = false;\n\t        this.staleObservers = [];\n\t        this.observers = new SimpleSet();\n\t        this.observing = [];\n\t        this.diffValue = 0;\n\t        this.runId = 0;\n\t        this.lastAccessedBy = 0;\n\t        this.unboundDepsCount = 0;\n\t        this.__mapid = \"#\" + getNextId();\n\t        this.dependencyChangeCount = 0;\n\t        this.dependencyStaleCount = 0;\n\t        this.value = undefined;\n\t        this.name = name || \"ComputedValue@\" + getNextId();\n\t    }\n\t    ComputedValue.prototype.peek = function () {\n\t        this.isComputing = true;\n\t        var prevAllowStateChanges = allowStateChangesStart(false);\n\t        var res = this.derivation.call(this.scope);\n\t        allowStateChangesEnd(prevAllowStateChanges);\n\t        this.isComputing = false;\n\t        return res;\n\t    };\n\t    ;\n\t    ComputedValue.prototype.onBecomeUnobserved = function () {\n\t        clearObserving(this);\n\t        this.isLazy = true;\n\t        this.value = undefined;\n\t    };\n\t    ComputedValue.prototype.onDependenciesReady = function () {\n\t        var changed = this.trackAndCompute();\n\t        return changed;\n\t    };\n\t    ComputedValue.prototype.get = function () {\n\t        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n\t        reportObserved(this);\n\t        if (this.dependencyStaleCount > 0) {\n\t            return this.peek();\n\t        }\n\t        if (this.isLazy) {\n\t            if (isComputingDerivation()) {\n\t                this.isLazy = false;\n\t                this.trackAndCompute();\n\t            } else {\n\t                return this.peek();\n\t            }\n\t        }\n\t        return this.value;\n\t    };\n\t    ComputedValue.prototype.set = function (_) {\n\t        throw new Error(\"[ComputedValue '\" + name + \"'] It is not possible to assign a new value to a computed value.\");\n\t    };\n\t    ComputedValue.prototype.trackAndCompute = function () {\n\t        if (isSpyEnabled()) {\n\t            spyReport({\n\t                object: this,\n\t                type: \"compute\",\n\t                fn: this.derivation,\n\t                target: this.scope\n\t            });\n\t        }\n\t        var oldValue = this.value;\n\t        var newValue = this.value = trackDerivedFunction(this, this.peek);\n\t        return valueDidChange(this.compareStructural, newValue, oldValue);\n\t    };\n\t    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n\t        var _this = this;\n\t        var firstTime = true;\n\t        var prevValue = undefined;\n\t        return autorun(function () {\n\t            var newValue = _this.get();\n\t            if (!firstTime || fireImmediately) {\n\t                var prevU = untrackedStart();\n\t                listener(newValue, prevValue);\n\t                untrackedEnd(prevU);\n\t            }\n\t            firstTime = false;\n\t            prevValue = newValue;\n\t        });\n\t    };\n\t    ComputedValue.prototype.toJSON = function () {\n\t        return this.get();\n\t    };\n\t    ComputedValue.prototype.toString = function () {\n\t        return this.name + \"[\" + this.derivation.toString() + \"]\";\n\t    };\n\t    ComputedValue.prototype.whyRun = function () {\n\t        var isTracking = globalState.derivationStack.length > 0;\n\t        var observing = unique(this.observing).map(function (dep) {\n\t            return dep.name;\n\t        });\n\t        var observers = unique(this.observers.asArray()).map(function (dep) {\n\t            return dep.name;\n\t        });\n\t        var runReason = this.isComputing ? isTracking ? this.observers.length > 0 ? RunReason.INVALIDATED : RunReason.REQUIRED : RunReason.PEEK : RunReason.NOT_RUNNING;\n\t        if (runReason === RunReason.REQUIRED) {\n\t            var requiredBy = globalState.derivationStack[globalState.derivationStack.length - 2];\n\t            if (requiredBy) observers.push(requiredBy.name);\n\t        }\n\t        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + runReasonTexts[runReason] + \" \" + (runReason === RunReason.NOT_RUNNING && this.dependencyStaleCount > 0 ? \"(a next run is scheduled)\" : \"\") + \"\\n\" + (this.isLazy ? \" * This computation is suspended (not in use by any reaction) and won't run automatically.\\n\\tDidn't expect this computation to be suspended at this point?\\n\\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\\n\" : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\tMissing items in this list?\\n\\t  1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n\\t  2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n\t    };\n\t    return ComputedValue;\n\t}();\n\tvar RunReason;\n\t(function (RunReason) {\n\t    RunReason[RunReason[\"PEEK\"] = 0] = \"PEEK\";\n\t    RunReason[RunReason[\"INVALIDATED\"] = 1] = \"INVALIDATED\";\n\t    RunReason[RunReason[\"REQUIRED\"] = 2] = \"REQUIRED\";\n\t    RunReason[RunReason[\"NOT_RUNNING\"] = 3] = \"NOT_RUNNING\";\n\t})(RunReason || (RunReason = {}));\n\tvar runReasonTexts = (_a = {}, _a[RunReason.PEEK] = \"[peek] The value of this computed value was requested outside an reaction\", _a[RunReason.INVALIDATED] = \"[invalidated] Some observables used by this computation did change\", _a[RunReason.REQUIRED] = \"[started] This computation is required by another computed value / reaction\", _a[RunReason.NOT_RUNNING] = \"[idle] This compution is currently not running\", _a);\n\tfunction isComputingDerivation() {\n\t    return globalState.derivationStack.length > 0 && globalState.isTracking;\n\t}\n\tfunction checkIfStateModificationsAreAllowed() {\n\t    if (!globalState.allowStateChanges) {\n\t        invariant(false, globalState.strictMode ? \"It is not allowed to create or change state outside an `action` when MobX is in strict mode. Wrap the current method in `action` if this state change is intended\" : \"It is not allowed to change the state when a computed value or transformer is being evaluated. Use 'autorun' to create reactive functions with side-effects.\");\n\t    }\n\t}\n\tfunction notifyDependencyStale(derivation) {\n\t    if (++derivation.dependencyStaleCount === 1) {\n\t        propagateStaleness(derivation);\n\t    }\n\t}\n\tfunction notifyDependencyReady(derivation, dependencyDidChange) {\n\t    invariant(derivation.dependencyStaleCount > 0, \"unexpected ready notification\");\n\t    if (dependencyDidChange) derivation.dependencyChangeCount += 1;\n\t    if (--derivation.dependencyStaleCount === 0) {\n\t        if (derivation.dependencyChangeCount > 0) {\n\t            derivation.dependencyChangeCount = 0;\n\t            var changed = derivation.onDependenciesReady();\n\t            propagateReadiness(derivation, changed);\n\t        } else {\n\t            propagateReadiness(derivation, false);\n\t        }\n\t    }\n\t}\n\tfunction trackDerivedFunction(derivation, f) {\n\t    var prevObserving = derivation.observing;\n\t    derivation.observing = new Array(prevObserving.length + 100);\n\t    derivation.unboundDepsCount = 0;\n\t    derivation.runId = ++globalState.runId;\n\t    globalState.derivationStack.push(derivation);\n\t    var prevTracking = globalState.isTracking;\n\t    globalState.isTracking = true;\n\t    var hasException = true;\n\t    var result;\n\t    try {\n\t        result = f.call(derivation);\n\t        hasException = false;\n\t    } finally {\n\t        if (hasException) {\n\t            var message = \"[mobx] An uncaught exception occurred while calculating your computed value, autorun or transformer. Or inside the render() method of an observer based React component. \" + \"These functions should never throw exceptions as MobX will not always be able to recover from them. \" + (\"Please fix the error reported after this message or enable 'Pause on (caught) exceptions' in your debugger to find the root cause. In: '\" + derivation.name + \"'. \") + \"For more details see https://github.com/mobxjs/mobx/issues/462\";\n\t            if (isSpyEnabled()) {\n\t                spyReport({\n\t                    type: \"error\",\n\t                    object: this,\n\t                    message: message\n\t                });\n\t            }\n\t            console.warn(message);\n\t            derivation.unboundDepsCount = 0;\n\t            derivation.observing = prevObserving;\n\t            resetGlobalState();\n\t        } else {\n\t            globalState.isTracking = prevTracking;\n\t            globalState.derivationStack.length -= 1;\n\t            bindDependencies(derivation, prevObserving);\n\t        }\n\t    }\n\t    return result;\n\t}\n\tfunction bindDependencies(derivation, prevObserving) {\n\t    var prevLength = prevObserving.length;\n\t    var observing = derivation.observing;\n\t    var newLength = observing.length = derivation.unboundDepsCount;\n\t    for (var i = 0; i < prevLength; i++) {\n\t        prevObserving[i].diffValue = -1;\n\t    }for (var i = 0; i < newLength; i++) {\n\t        var dep = observing[i];\n\t        if (++dep.diffValue > 0) {\n\t            dep.diffValue = 0;\n\t            addObserver(dep, derivation);\n\t        }\n\t    }\n\t    for (var i = 0; i < prevLength; i++) {\n\t        var dep = prevObserving[i];\n\t        if (dep.diffValue < 0) {\n\t            dep.diffValue = 0;\n\t            removeObserver(dep, derivation);\n\t        }\n\t    }\n\t}\n\tfunction clearObserving(derivation) {\n\t    var obs = derivation.observing;\n\t    var l = obs.length;\n\t    for (var i = 0; i < l; i++) {\n\t        removeObserver(obs[i], derivation);\n\t    }obs.length = 0;\n\t}\n\tfunction untracked(action) {\n\t    var prev = untrackedStart();\n\t    var res = action();\n\t    untrackedEnd(prev);\n\t    return res;\n\t}\n\texports.untracked = untracked;\n\tfunction untrackedStart() {\n\t    var prev = globalState.isTracking;\n\t    globalState.isTracking = false;\n\t    return prev;\n\t}\n\tfunction untrackedEnd(prev) {\n\t    globalState.isTracking = prev;\n\t}\n\tvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\n\tvar MobXGlobals = function () {\n\t    function MobXGlobals() {\n\t        this.version = 3;\n\t        this.derivationStack = [];\n\t        this.runId = 0;\n\t        this.mobxGuid = 0;\n\t        this.inTransaction = 0;\n\t        this.isTracking = false;\n\t        this.isRunningReactions = false;\n\t        this.changedAtoms = [];\n\t        this.pendingReactions = [];\n\t        this.allowStateChanges = true;\n\t        this.strictMode = false;\n\t        this.resetId = 0;\n\t        this.spyListeners = [];\n\t    }\n\t    return MobXGlobals;\n\t}();\n\tvar globalState = function () {\n\t    var res = new MobXGlobals();\n\t    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n\t    if (global.__mobxGlobal && global.__mobxGlobal.version !== res.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n\t    if (global.__mobxGlobal) return global.__mobxGlobal;\n\t    return global.__mobxGlobal = res;\n\t}();\n\tfunction registerGlobals() {}\n\tfunction resetGlobalState() {\n\t    globalState.resetId++;\n\t    var defaultGlobals = new MobXGlobals();\n\t    for (var key in defaultGlobals) {\n\t        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n\t    }globalState.allowStateChanges = !globalState.strictMode;\n\t}\n\tfunction addObserver(observable, node) {\n\t    observable.observers.add(node);\n\t}\n\tfunction removeObserver(observable, node) {\n\t    observable.observers.remove(node);\n\t    if (observable.observers.length === 0) observable.onBecomeUnobserved();\n\t}\n\tfunction reportObserved(observable) {\n\t    if (globalState.isTracking === false) return;\n\t    var derivation = globalState.derivationStack[globalState.derivationStack.length - 1];\n\t    if (derivation.runId !== observable.lastAccessedBy) {\n\t        observable.lastAccessedBy = derivation.runId;\n\t        derivation.observing[derivation.unboundDepsCount++] = observable;\n\t    }\n\t}\n\tfunction propagateStaleness(observable) {\n\t    var os = observable.observers.asArray();\n\t    var l = os.length;\n\t    for (var i = 0; i < l; i++) {\n\t        notifyDependencyStale(os[i]);\n\t    }observable.staleObservers = observable.staleObservers.concat(os);\n\t}\n\tfunction propagateReadiness(observable, valueDidActuallyChange) {\n\t    observable.staleObservers.splice(0).forEach(function (o) {\n\t        return notifyDependencyReady(o, valueDidActuallyChange);\n\t    });\n\t}\n\tvar EMPTY_DERIVATION_SET;\n\tvar Reaction = function () {\n\t    function Reaction(name, onInvalidate) {\n\t        if (name === void 0) {\n\t            name = \"Reaction@\" + getNextId();\n\t        }\n\t        this.name = name;\n\t        this.onInvalidate = onInvalidate;\n\t        this.staleObservers = EMPTY_ARRAY;\n\t        this.observers = EMPTY_DERIVATION_SET || (EMPTY_DERIVATION_SET = new SimpleSet());\n\t        this.observing = [];\n\t        this.diffValue = 0;\n\t        this.runId = 0;\n\t        this.lastAccessedBy = 0;\n\t        this.unboundDepsCount = 0;\n\t        this.__mapid = \"#\" + getNextId();\n\t        this.dependencyChangeCount = 0;\n\t        this.dependencyStaleCount = 0;\n\t        this.isDisposed = false;\n\t        this._isScheduled = false;\n\t        this._isTrackPending = false;\n\t        this._isRunning = false;\n\t    }\n\t    Reaction.prototype.onBecomeUnobserved = function () {};\n\t    Reaction.prototype.onDependenciesReady = function () {\n\t        this.schedule();\n\t        return false;\n\t    };\n\t    Reaction.prototype.schedule = function () {\n\t        if (!this._isScheduled) {\n\t            this._isScheduled = true;\n\t            globalState.pendingReactions.push(this);\n\t            runReactions();\n\t        }\n\t    };\n\t    Reaction.prototype.isScheduled = function () {\n\t        return this.dependencyStaleCount > 0 || this._isScheduled;\n\t    };\n\t    Reaction.prototype.runReaction = function () {\n\t        if (!this.isDisposed) {\n\t            this._isScheduled = false;\n\t            this._isTrackPending = true;\n\t            this.onInvalidate();\n\t            if (this._isTrackPending && isSpyEnabled()) {\n\t                spyReport({\n\t                    object: this,\n\t                    type: \"scheduled-reaction\"\n\t                });\n\t            }\n\t        }\n\t    };\n\t    Reaction.prototype.track = function (fn) {\n\t        var notify = isSpyEnabled();\n\t        var startTime;\n\t        if (notify) {\n\t            startTime = Date.now();\n\t            spyReportStart({\n\t                object: this,\n\t                type: \"reaction\",\n\t                fn: fn\n\t            });\n\t        }\n\t        this._isRunning = true;\n\t        trackDerivedFunction(this, fn);\n\t        this._isRunning = false;\n\t        this._isTrackPending = false;\n\t        if (this.isDisposed) {\n\t            clearObserving(this);\n\t        }\n\t        if (notify) {\n\t            spyReportEnd({\n\t                time: Date.now() - startTime\n\t            });\n\t        }\n\t    };\n\t    Reaction.prototype.dispose = function () {\n\t        if (!this.isDisposed) {\n\t            this.isDisposed = true;\n\t            if (!this._isRunning) clearObserving(this);\n\t        }\n\t    };\n\t    Reaction.prototype.getDisposer = function () {\n\t        var r = this.dispose.bind(this);\n\t        r.$mobx = this;\n\t        return r;\n\t    };\n\t    Reaction.prototype.toString = function () {\n\t        return \"Reaction[\" + this.name + \"]\";\n\t    };\n\t    Reaction.prototype.whyRun = function () {\n\t        var observing = unique(this.observing).map(function (dep) {\n\t            return dep.name;\n\t        });\n\t        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\tMissing items in this list?\\n\\t  1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n\\t  2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\";\n\t    };\n\t    return Reaction;\n\t}();\n\texports.Reaction = Reaction;\n\tvar MAX_REACTION_ITERATIONS = 100;\n\tfunction runReactions() {\n\t    if (globalState.isRunningReactions === true || globalState.inTransaction > 0) return;\n\t    globalState.isRunningReactions = true;\n\t    var allReactions = globalState.pendingReactions;\n\t    var iterations = 0;\n\t    while (allReactions.length > 0) {\n\t        if (++iterations === MAX_REACTION_ITERATIONS) throw new Error(\"Reaction doesn't converge to a stable state. Probably there is a cycle in the reactive function: \" + allReactions[0].toString());\n\t        var remainingReactions = allReactions.splice(0);\n\t        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n\t            remainingReactions[i].runReaction();\n\t        }\n\t    }\n\t    globalState.isRunningReactions = false;\n\t}\n\tvar spyEnabled = false;\n\tfunction isSpyEnabled() {\n\t    return spyEnabled;\n\t}\n\tfunction spyReport(event) {\n\t    if (!spyEnabled) return false;\n\t    var listeners = globalState.spyListeners;\n\t    for (var i = 0, l = listeners.length; i < l; i++) {\n\t        listeners[i](event);\n\t    }\n\t}\n\tfunction spyReportStart(event) {\n\t    var change = objectAssign({}, event, { spyReportStart: true });\n\t    spyReport(change);\n\t}\n\tvar END_EVENT = { spyReportEnd: true };\n\tfunction spyReportEnd(change) {\n\t    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n\t}\n\tfunction spy(listener) {\n\t    globalState.spyListeners.push(listener);\n\t    spyEnabled = globalState.spyListeners.length > 0;\n\t    return once(function () {\n\t        var idx = globalState.spyListeners.indexOf(listener);\n\t        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n\t        spyEnabled = globalState.spyListeners.length > 0;\n\t    });\n\t}\n\texports.spy = spy;\n\tfunction trackTransitions(onReport) {\n\t    deprecated(\"trackTransitions is deprecated. Use mobx.spy instead\");\n\t    if (typeof onReport === \"boolean\") {\n\t        deprecated(\"trackTransitions only takes a single callback function. If you are using the mobx-react-devtools, please update them first\");\n\t        onReport = arguments[1];\n\t    }\n\t    if (!onReport) {\n\t        deprecated(\"trackTransitions without callback has been deprecated and is a no-op now. If you are using the mobx-react-devtools, please update them first\");\n\t        return function () {};\n\t    }\n\t    return spy(onReport);\n\t}\n\tfunction transaction(action, thisArg, report) {\n\t    if (thisArg === void 0) {\n\t        thisArg = undefined;\n\t    }\n\t    if (report === void 0) {\n\t        report = true;\n\t    }\n\t    transactionStart(action.name || \"anonymous transaction\", thisArg, report);\n\t    var res = action.call(thisArg);\n\t    transactionEnd(report);\n\t    return res;\n\t}\n\texports.transaction = transaction;\n\tfunction transactionStart(name, thisArg, report) {\n\t    if (thisArg === void 0) {\n\t        thisArg = undefined;\n\t    }\n\t    if (report === void 0) {\n\t        report = true;\n\t    }\n\t    globalState.inTransaction += 1;\n\t    if (report && isSpyEnabled()) {\n\t        spyReportStart({\n\t            type: \"transaction\",\n\t            target: thisArg,\n\t            name: name\n\t        });\n\t    }\n\t}\n\tfunction transactionEnd(report) {\n\t    if (report === void 0) {\n\t        report = true;\n\t    }\n\t    if (--globalState.inTransaction === 0) {\n\t        var values = globalState.changedAtoms.splice(0);\n\t        for (var i = 0, l = values.length; i < l; i++) {\n\t            propagateAtomReady(values[i]);\n\t        }runReactions();\n\t    }\n\t    if (report && isSpyEnabled()) spyReportEnd();\n\t}\n\tfunction hasInterceptors(interceptable) {\n\t    return interceptable.interceptors && interceptable.interceptors.length > 0;\n\t}\n\tfunction registerInterceptor(interceptable, handler) {\n\t    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n\t    interceptors.push(handler);\n\t    return once(function () {\n\t        var idx = interceptors.indexOf(handler);\n\t        if (idx !== -1) interceptors.splice(idx, 1);\n\t    });\n\t}\n\tfunction interceptChange(interceptable, change) {\n\t    var prevU = untrackedStart();\n\t    var interceptors = interceptable.interceptors;\n\t    for (var i = 0, l = interceptors.length; i < l; i++) {\n\t        change = interceptors[i](change);\n\t        invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n\t        if (!change) return null;\n\t    }\n\t    untrackedEnd(prevU);\n\t    return change;\n\t}\n\tfunction hasListeners(listenable) {\n\t    return listenable.changeListeners && listenable.changeListeners.length > 0;\n\t}\n\tfunction registerListener(listenable, handler) {\n\t    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n\t    listeners.push(handler);\n\t    return once(function () {\n\t        var idx = listeners.indexOf(handler);\n\t        if (idx !== -1) listeners.splice(idx, 1);\n\t    });\n\t}\n\tfunction notifyListeners(listenable, change) {\n\t    var prevU = untrackedStart();\n\t    var listeners = listenable.changeListeners;\n\t    if (!listeners) return;\n\t    listeners = listeners.slice();\n\t    for (var i = 0, l = listeners.length; i < l; i++) {\n\t        if (Array.isArray(change)) {\n\t            listeners[i].apply(null, change);\n\t        } else {\n\t            listeners[i](change);\n\t        }\n\t    }\n\t    untrackedEnd(prevU);\n\t}\n\tvar ValueMode;\n\t(function (ValueMode) {\n\t    ValueMode[ValueMode[\"Recursive\"] = 0] = \"Recursive\";\n\t    ValueMode[ValueMode[\"Reference\"] = 1] = \"Reference\";\n\t    ValueMode[ValueMode[\"Structure\"] = 2] = \"Structure\";\n\t    ValueMode[ValueMode[\"Flat\"] = 3] = \"Flat\";\n\t})(ValueMode || (ValueMode = {}));\n\tfunction asReference(value) {\n\t    return new AsReference(value);\n\t}\n\texports.asReference = asReference;\n\tfunction asStructure(value) {\n\t    return new AsStructure(value);\n\t}\n\texports.asStructure = asStructure;\n\tfunction asFlat(value) {\n\t    return new AsFlat(value);\n\t}\n\texports.asFlat = asFlat;\n\tvar AsReference = function () {\n\t    function AsReference(value) {\n\t        this.value = value;\n\t        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n\t    }\n\t    return AsReference;\n\t}();\n\tvar AsStructure = function () {\n\t    function AsStructure(value) {\n\t        this.value = value;\n\t        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n\t    }\n\t    return AsStructure;\n\t}();\n\tvar AsFlat = function () {\n\t    function AsFlat(value) {\n\t        this.value = value;\n\t        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n\t    }\n\t    return AsFlat;\n\t}();\n\tfunction asMap(data, modifierFunc) {\n\t    return map(data, modifierFunc);\n\t}\n\texports.asMap = asMap;\n\tfunction getValueModeFromValue(value, defaultMode) {\n\t    if (value instanceof AsReference) return [ValueMode.Reference, value.value];\n\t    if (value instanceof AsStructure) return [ValueMode.Structure, value.value];\n\t    if (value instanceof AsFlat) return [ValueMode.Flat, value.value];\n\t    return [defaultMode, value];\n\t}\n\tfunction getValueModeFromModifierFunc(func) {\n\t    if (func === asReference) return ValueMode.Reference;else if (func === asStructure) return ValueMode.Structure;else if (func === asFlat) return ValueMode.Flat;\n\t    invariant(func === undefined, \"Cannot determine value mode from function. Please pass in one of these: mobx.asReference, mobx.asStructure or mobx.asFlat, got: \" + func);\n\t    return ValueMode.Recursive;\n\t}\n\tfunction makeChildObservable(value, parentMode, name) {\n\t    var childMode;\n\t    if (isObservable(value)) return value;\n\t    switch (parentMode) {\n\t        case ValueMode.Reference:\n\t            return value;\n\t        case ValueMode.Flat:\n\t            assertUnwrapped(value, \"Items inside 'asFlat' cannot have modifiers\");\n\t            childMode = ValueMode.Reference;\n\t            break;\n\t        case ValueMode.Structure:\n\t            assertUnwrapped(value, \"Items inside 'asStructure' cannot have modifiers\");\n\t            childMode = ValueMode.Structure;\n\t            break;\n\t        case ValueMode.Recursive:\n\t            _a = getValueModeFromValue(value, ValueMode.Recursive), childMode = _a[0], value = _a[1];\n\t            break;\n\t        default:\n\t            invariant(false, \"Illegal State\");\n\t    }\n\t    if (Array.isArray(value)) return createObservableArray(value, childMode, name);\n\t    if (isPlainObject(value) && Object.isExtensible(value)) return extendObservableHelper(value, value, childMode, name);\n\t    return value;\n\t    var _a;\n\t}\n\tfunction assertUnwrapped(value, message) {\n\t    if (value instanceof AsReference || value instanceof AsStructure || value instanceof AsFlat) throw new Error(\"[mobx] asStructure / asReference / asFlat cannot be used here. \" + message);\n\t}\n\tvar safariPrototypeSetterInheritanceBug = function () {\n\t    var v = false;\n\t    var p = {};\n\t    Object.defineProperty(p, \"0\", { set: function set() {\n\t            v = true;\n\t        } });\n\t    Object.create(p)[\"0\"] = 1;\n\t    return v === false;\n\t}();\n\tvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\n\tvar StubArray = function () {\n\t    function StubArray() {}\n\t    return StubArray;\n\t}();\n\tStubArray.prototype = [];\n\tvar ObservableArrayAdministration = function () {\n\t    function ObservableArrayAdministration(name, mode, array, owned) {\n\t        this.mode = mode;\n\t        this.array = array;\n\t        this.owned = owned;\n\t        this.lastKnownLength = 0;\n\t        this.interceptors = null;\n\t        this.changeListeners = null;\n\t        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n\t    }\n\t    ObservableArrayAdministration.prototype.makeReactiveArrayItem = function (value) {\n\t        assertUnwrapped(value, \"Array values cannot have modifiers\");\n\t        if (this.mode === ValueMode.Flat || this.mode === ValueMode.Reference) return value;\n\t        return makeChildObservable(value, this.mode, this.atom.name + \"[..]\");\n\t    };\n\t    ObservableArrayAdministration.prototype.intercept = function (handler) {\n\t        return registerInterceptor(this, handler);\n\t    };\n\t    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n\t        if (fireImmediately === void 0) {\n\t            fireImmediately = false;\n\t        }\n\t        if (fireImmediately) {\n\t            listener({\n\t                object: this.array,\n\t                type: \"splice\",\n\t                index: 0,\n\t                added: this.values.slice(),\n\t                addedCount: this.values.length,\n\t                removed: [],\n\t                removedCount: 0\n\t            });\n\t        }\n\t        return registerListener(this, listener);\n\t    };\n\t    ObservableArrayAdministration.prototype.getArrayLength = function () {\n\t        this.atom.reportObserved();\n\t        return this.values.length;\n\t    };\n\t    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n\t        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n\t        var currentLength = this.values.length;\n\t        if (newLength === currentLength) return;else if (newLength > currentLength) this.spliceWithArray(currentLength, 0, new Array(newLength - currentLength));else this.spliceWithArray(newLength, currentLength - newLength);\n\t    };\n\t    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n\t        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n\t        this.lastKnownLength += delta;\n\t        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n\t    };\n\t    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n\t        checkIfStateModificationsAreAllowed();\n\t        var length = this.values.length;\n\t        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n\t        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n\t        if (newItems === undefined) newItems = [];\n\t        if (hasInterceptors(this)) {\n\t            var change = interceptChange(this, {\n\t                object: this.array,\n\t                type: \"splice\",\n\t                index: index,\n\t                removedCount: deleteCount,\n\t                added: newItems\n\t            });\n\t            if (!change) return EMPTY_ARRAY;\n\t            deleteCount = change.removedCount;\n\t            newItems = change.added;\n\t        }\n\t        newItems = newItems.map(this.makeReactiveArrayItem, this);\n\t        var lengthDelta = newItems.length - deleteCount;\n\t        this.updateArrayLength(length, lengthDelta);\n\t        var res = (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n\t        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n\t        return res;\n\t        var _a;\n\t    };\n\t    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n\t        var notifySpy = !this.owned && isSpyEnabled();\n\t        var notify = hasListeners(this);\n\t        var change = notify || notifySpy ? {\n\t            object: this.array,\n\t            type: \"update\",\n\t            index: index, newValue: newValue, oldValue: oldValue\n\t        } : null;\n\t        if (notifySpy) spyReportStart(change);\n\t        this.atom.reportChanged();\n\t        if (notify) notifyListeners(this, change);\n\t        if (notifySpy) spyReportEnd();\n\t    };\n\t    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n\t        var notifySpy = !this.owned && isSpyEnabled();\n\t        var notify = hasListeners(this);\n\t        var change = notify || notifySpy ? {\n\t            object: this.array,\n\t            type: \"splice\",\n\t            index: index, removed: removed, added: added,\n\t            removedCount: removed.length,\n\t            addedCount: added.length\n\t        } : null;\n\t        if (notifySpy) spyReportStart(change);\n\t        this.atom.reportChanged();\n\t        if (notify) notifyListeners(this, change);\n\t        if (notifySpy) spyReportEnd();\n\t    };\n\t    return ObservableArrayAdministration;\n\t}();\n\tvar ObservableArray = function (_super) {\n\t    __extends(ObservableArray, _super);\n\t    function ObservableArray(initialValues, mode, name, owned) {\n\t        if (owned === void 0) {\n\t            owned = false;\n\t        }\n\t        _super.call(this);\n\t        var adm = new ObservableArrayAdministration(name, mode, this, owned);\n\t        addHiddenFinalProp(this, \"$mobx\", adm);\n\t        if (initialValues && initialValues.length) {\n\t            adm.updateArrayLength(0, initialValues.length);\n\t            adm.values = initialValues.map(adm.makeReactiveArrayItem, adm);\n\t            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n\t        } else {\n\t            adm.values = [];\n\t        }\n\t        if (safariPrototypeSetterInheritanceBug) {\n\t            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n\t        }\n\t    }\n\t    ObservableArray.prototype.intercept = function (handler) {\n\t        return this.$mobx.intercept(handler);\n\t    };\n\t    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n\t        if (fireImmediately === void 0) {\n\t            fireImmediately = false;\n\t        }\n\t        return this.$mobx.observe(listener, fireImmediately);\n\t    };\n\t    ObservableArray.prototype.clear = function () {\n\t        return this.splice(0);\n\t    };\n\t    ObservableArray.prototype.concat = function () {\n\t        var arrays = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            arrays[_i - 0] = arguments[_i];\n\t        }\n\t        this.$mobx.atom.reportObserved();\n\t        return Array.prototype.concat.apply(this.slice(), arrays.map(function (a) {\n\t            return isObservableArray(a) ? a.slice() : a;\n\t        }));\n\t    };\n\t    ObservableArray.prototype.replace = function (newItems) {\n\t        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n\t    };\n\t    ObservableArray.prototype.toJS = function () {\n\t        return this.slice();\n\t    };\n\t    ObservableArray.prototype.toJSON = function () {\n\t        return this.toJS();\n\t    };\n\t    ObservableArray.prototype.peek = function () {\n\t        return this.$mobx.values;\n\t    };\n\t    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n\t        if (fromIndex === void 0) {\n\t            fromIndex = 0;\n\t        }\n\t        this.$mobx.atom.reportObserved();\n\t        var items = this.$mobx.values,\n\t            l = items.length;\n\t        for (var i = fromIndex; i < l; i++) {\n\t            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n\t        }return undefined;\n\t    };\n\t    ObservableArray.prototype.splice = function (index, deleteCount) {\n\t        var newItems = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            newItems[_i - 2] = arguments[_i];\n\t        }\n\t        switch (arguments.length) {\n\t            case 0:\n\t                return [];\n\t            case 1:\n\t                return this.$mobx.spliceWithArray(index);\n\t            case 2:\n\t                return this.$mobx.spliceWithArray(index, deleteCount);\n\t        }\n\t        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n\t    };\n\t    ObservableArray.prototype.push = function () {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i - 0] = arguments[_i];\n\t        }\n\t        var adm = this.$mobx;\n\t        adm.spliceWithArray(adm.values.length, 0, items);\n\t        return adm.values.length;\n\t    };\n\t    ObservableArray.prototype.pop = function () {\n\t        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n\t    };\n\t    ObservableArray.prototype.shift = function () {\n\t        return this.splice(0, 1)[0];\n\t    };\n\t    ObservableArray.prototype.unshift = function () {\n\t        var items = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            items[_i - 0] = arguments[_i];\n\t        }\n\t        var adm = this.$mobx;\n\t        adm.spliceWithArray(0, 0, items);\n\t        return adm.values.length;\n\t    };\n\t    ObservableArray.prototype.reverse = function () {\n\t        this.$mobx.atom.reportObserved();\n\t        var clone = this.slice();\n\t        return clone.reverse.apply(clone, arguments);\n\t    };\n\t    ObservableArray.prototype.sort = function (compareFn) {\n\t        this.$mobx.atom.reportObserved();\n\t        var clone = this.slice();\n\t        return clone.sort.apply(clone, arguments);\n\t    };\n\t    ObservableArray.prototype.remove = function (value) {\n\t        var idx = this.$mobx.values.indexOf(value);\n\t        if (idx > -1) {\n\t            this.splice(idx, 1);\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    ObservableArray.prototype.toString = function () {\n\t        return \"[mobx.array] \" + Array.prototype.toString.apply(this.$mobx.values, arguments);\n\t    };\n\t    ObservableArray.prototype.toLocaleString = function () {\n\t        return \"[mobx.array] \" + Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n\t    };\n\t    return ObservableArray;\n\t}(StubArray);\n\tdeclareIterator(ObservableArray.prototype, function () {\n\t    return arrayAsIterator(this.slice());\n\t});\n\tmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJSON\", \"peek\", \"find\", \"splice\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"toString\", \"toLocaleString\"]);\n\tObject.defineProperty(ObservableArray.prototype, \"length\", {\n\t    enumerable: false,\n\t    configurable: true,\n\t    get: function get() {\n\t        return this.$mobx.getArrayLength();\n\t    },\n\t    set: function set(newLength) {\n\t        this.$mobx.setArrayLength(newLength);\n\t    }\n\t});\n\t[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n\t    var baseFunc = Array.prototype[funcName];\n\t    addHiddenProp(ObservableArray.prototype, funcName, function () {\n\t        this.$mobx.atom.reportObserved();\n\t        return baseFunc.apply(this.$mobx.values, arguments);\n\t    });\n\t});\n\tvar ENTRY_0 = {\n\t    configurable: true,\n\t    enumerable: false,\n\t    set: createArraySetter(0),\n\t    get: createArrayGetter(0)\n\t};\n\tfunction createArrayBufferItem(index) {\n\t    var set = createArraySetter(index);\n\t    var get = createArrayGetter(index);\n\t    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n\t        enumerable: false,\n\t        configurable: true,\n\t        set: set, get: get\n\t    });\n\t}\n\tfunction createArraySetter(index) {\n\t    return function (newValue) {\n\t        var adm = this.$mobx;\n\t        var values = adm.values;\n\t        assertUnwrapped(newValue, \"Modifiers cannot be used on array values. For non-reactive array values use makeReactive(asFlat(array)).\");\n\t        if (index < values.length) {\n\t            checkIfStateModificationsAreAllowed();\n\t            var oldValue = values[index];\n\t            if (hasInterceptors(adm)) {\n\t                var change = interceptChange(adm, {\n\t                    type: \"update\",\n\t                    object: adm.array,\n\t                    index: index, newValue: newValue\n\t                });\n\t                if (!change) return;\n\t                newValue = change.newValue;\n\t            }\n\t            newValue = adm.makeReactiveArrayItem(newValue);\n\t            var changed = adm.mode === ValueMode.Structure ? !deepEquals(oldValue, newValue) : oldValue !== newValue;\n\t            if (changed) {\n\t                values[index] = newValue;\n\t                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n\t            }\n\t        } else if (index === values.length) {\n\t            adm.spliceWithArray(index, 0, [newValue]);\n\t        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n\t    };\n\t}\n\tfunction createArrayGetter(index) {\n\t    return function () {\n\t        var impl = this.$mobx;\n\t        if (impl && index < impl.values.length) {\n\t            impl.atom.reportObserved();\n\t            return impl.values[index];\n\t        }\n\t        console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n\t        return undefined;\n\t    };\n\t}\n\tfunction reserveArrayBuffer(max) {\n\t    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n\t        createArrayBufferItem(index);\n\t    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n\t}\n\treserveArrayBuffer(1000);\n\tfunction createObservableArray(initialValues, mode, name) {\n\t    return new ObservableArray(initialValues, mode, name);\n\t}\n\tfunction fastArray(initialValues) {\n\t    deprecated(\"fastArray is deprecated. Please use `observable(asFlat([]))`\");\n\t    return createObservableArray(initialValues, ValueMode.Flat, null);\n\t}\n\texports.fastArray = fastArray;\n\tfunction isObservableArray(thing) {\n\t    return thing instanceof ObservableArray;\n\t}\n\texports.isObservableArray = isObservableArray;\n\tvar ObservableMapMarker = {};\n\tvar ObservableMap = function () {\n\t    function ObservableMap(initialData, valueModeFunc) {\n\t        var _this = this;\n\t        this.$mobx = ObservableMapMarker;\n\t        this._data = {};\n\t        this._hasMap = {};\n\t        this.name = \"ObservableMap@\" + getNextId();\n\t        this._keys = new ObservableArray(null, ValueMode.Reference, this.name + \".keys()\", true);\n\t        this.interceptors = null;\n\t        this.changeListeners = null;\n\t        this._valueMode = getValueModeFromModifierFunc(valueModeFunc);\n\t        if (this._valueMode === ValueMode.Flat) this._valueMode = ValueMode.Reference;\n\t        allowStateChanges(true, function () {\n\t            if (isPlainObject(initialData)) _this.merge(initialData);else if (Array.isArray(initialData)) initialData.forEach(function (_a) {\n\t                var key = _a[0],\n\t                    value = _a[1];\n\t                return _this.set(key, value);\n\t            });\n\t        });\n\t    }\n\t    ObservableMap.prototype._has = function (key) {\n\t        return typeof this._data[key] !== \"undefined\";\n\t    };\n\t    ObservableMap.prototype.has = function (key) {\n\t        if (!this.isValidKey(key)) return false;\n\t        key = \"\" + key;\n\t        if (this._hasMap[key]) return this._hasMap[key].get();\n\t        return this._updateHasMapEntry(key, false).get();\n\t    };\n\t    ObservableMap.prototype.set = function (key, value) {\n\t        this.assertValidKey(key);\n\t        key = \"\" + key;\n\t        var hasKey = this._has(key);\n\t        assertUnwrapped(value, \"[mobx.map.set] Expected unwrapped value to be inserted to key '\" + key + \"'. If you need to use modifiers pass them as second argument to the constructor\");\n\t        if (hasInterceptors(this)) {\n\t            var change = interceptChange(this, {\n\t                type: hasKey ? \"update\" : \"add\",\n\t                object: this,\n\t                newValue: value,\n\t                name: key\n\t            });\n\t            if (!change) return;\n\t            value = change.newValue;\n\t        }\n\t        if (hasKey) {\n\t            this._updateValue(key, value);\n\t        } else {\n\t            this._addValue(key, value);\n\t        }\n\t    };\n\t    ObservableMap.prototype.delete = function (key) {\n\t        var _this = this;\n\t        this.assertValidKey(key);\n\t        key = \"\" + key;\n\t        if (hasInterceptors(this)) {\n\t            var change = interceptChange(this, {\n\t                type: \"delete\",\n\t                object: this,\n\t                name: key\n\t            });\n\t            if (!change) return;\n\t        }\n\t        if (this._has(key)) {\n\t            var notifySpy = isSpyEnabled();\n\t            var notify = hasListeners(this);\n\t            var change = notify || notifySpy ? {\n\t                type: \"delete\",\n\t                object: this,\n\t                oldValue: this._data[key].value,\n\t                name: key\n\t            } : null;\n\t            if (notifySpy) spyReportStart(change);\n\t            transaction(function () {\n\t                _this._keys.remove(key);\n\t                _this._updateHasMapEntry(key, false);\n\t                var observable = _this._data[key];\n\t                observable.setNewValue(undefined);\n\t                _this._data[key] = undefined;\n\t            }, undefined, false);\n\t            if (notify) notifyListeners(this, change);\n\t            if (notifySpy) spyReportEnd();\n\t        }\n\t    };\n\t    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n\t        var entry = this._hasMap[key];\n\t        if (entry) {\n\t            entry.setNewValue(value);\n\t        } else {\n\t            entry = this._hasMap[key] = new ObservableValue(value, ValueMode.Reference, this.name + \".\" + key + \"?\", false);\n\t        }\n\t        return entry;\n\t    };\n\t    ObservableMap.prototype._updateValue = function (name, newValue) {\n\t        var observable = this._data[name];\n\t        newValue = observable.prepareNewValue(newValue);\n\t        if (newValue !== UNCHANGED) {\n\t            var notifySpy = isSpyEnabled();\n\t            var notify = hasListeners(this);\n\t            var change = notify || notifySpy ? {\n\t                type: \"update\",\n\t                object: this,\n\t                oldValue: observable.value,\n\t                name: name, newValue: newValue\n\t            } : null;\n\t            if (notifySpy) spyReportStart(change);\n\t            observable.setNewValue(newValue);\n\t            if (notify) notifyListeners(this, change);\n\t            if (notifySpy) spyReportEnd();\n\t        }\n\t    };\n\t    ObservableMap.prototype._addValue = function (name, newValue) {\n\t        var _this = this;\n\t        transaction(function () {\n\t            var observable = _this._data[name] = new ObservableValue(newValue, _this._valueMode, _this.name + \".\" + name, false);\n\t            newValue = observable.value;\n\t            _this._updateHasMapEntry(name, true);\n\t            _this._keys.push(name);\n\t        }, undefined, false);\n\t        var notifySpy = isSpyEnabled();\n\t        var notify = hasListeners(this);\n\t        var change = notify || notifySpy ? {\n\t            type: \"add\",\n\t            object: this,\n\t            name: name, newValue: newValue\n\t        } : null;\n\t        if (notifySpy) spyReportStart(change);\n\t        if (notify) notifyListeners(this, change);\n\t        if (notifySpy) spyReportEnd();\n\t    };\n\t    ObservableMap.prototype.get = function (key) {\n\t        key = \"\" + key;\n\t        if (this.has(key)) return this._data[key].get();\n\t        return undefined;\n\t    };\n\t    ObservableMap.prototype.keys = function () {\n\t        return arrayAsIterator(this._keys.slice());\n\t    };\n\t    ObservableMap.prototype.values = function () {\n\t        return arrayAsIterator(this._keys.map(this.get, this));\n\t    };\n\t    ObservableMap.prototype.entries = function () {\n\t        var _this = this;\n\t        return arrayAsIterator(this._keys.map(function (key) {\n\t            return [key, _this.get(key)];\n\t        }));\n\t    };\n\t    ObservableMap.prototype.forEach = function (callback, thisArg) {\n\t        var _this = this;\n\t        this.keys().forEach(function (key) {\n\t            return callback.call(thisArg, _this.get(key), key);\n\t        });\n\t    };\n\t    ObservableMap.prototype.merge = function (other) {\n\t        var _this = this;\n\t        transaction(function () {\n\t            if (other instanceof ObservableMap) other.keys().forEach(function (key) {\n\t                return _this.set(key, other.get(key));\n\t            });else Object.keys(other).forEach(function (key) {\n\t                return _this.set(key, other[key]);\n\t            });\n\t        }, undefined, false);\n\t        return this;\n\t    };\n\t    ObservableMap.prototype.clear = function () {\n\t        var _this = this;\n\t        transaction(function () {\n\t            untracked(function () {\n\t                _this.keys().forEach(_this.delete, _this);\n\t            });\n\t        }, undefined, false);\n\t    };\n\t    Object.defineProperty(ObservableMap.prototype, \"size\", {\n\t        get: function get() {\n\t            return this._keys.length;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    ObservableMap.prototype.toJS = function () {\n\t        var _this = this;\n\t        var res = {};\n\t        this.keys().forEach(function (key) {\n\t            return res[key] = _this.get(key);\n\t        });\n\t        return res;\n\t    };\n\t    ObservableMap.prototype.toJs = function () {\n\t        deprecated(\"toJs is deprecated, use toJS instead\");\n\t        return this.toJS();\n\t    };\n\t    ObservableMap.prototype.toJSON = function () {\n\t        return this.toJS();\n\t    };\n\t    ObservableMap.prototype.isValidKey = function (key) {\n\t        if (key === null || key === undefined) return false;\n\t        if (typeof key !== \"string\" && typeof key !== \"number\" && typeof key !== \"boolean\") return false;\n\t        return true;\n\t    };\n\t    ObservableMap.prototype.assertValidKey = function (key) {\n\t        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"'\");\n\t    };\n\t    ObservableMap.prototype.toString = function () {\n\t        var _this = this;\n\t        return this.name + \"[{ \" + this.keys().map(function (key) {\n\t            return key + \": \" + (\"\" + _this.get(key));\n\t        }).join(\", \") + \" }]\";\n\t    };\n\t    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n\t        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable maps.\");\n\t        return registerListener(this, listener);\n\t    };\n\t    ObservableMap.prototype.intercept = function (handler) {\n\t        return registerInterceptor(this, handler);\n\t    };\n\t    return ObservableMap;\n\t}();\n\texports.ObservableMap = ObservableMap;\n\tdeclareIterator(ObservableMap.prototype, function () {\n\t    return this.entries();\n\t});\n\tfunction map(initialValues, valueModifier) {\n\t    return new ObservableMap(initialValues, valueModifier);\n\t}\n\texports.map = map;\n\tfunction isObservableMap(thing) {\n\t    return thing instanceof ObservableMap;\n\t}\n\texports.isObservableMap = isObservableMap;\n\tvar ObservableObjectAdministration = function () {\n\t    function ObservableObjectAdministration(target, name, mode) {\n\t        this.target = target;\n\t        this.name = name;\n\t        this.mode = mode;\n\t        this.values = {};\n\t        this.changeListeners = null;\n\t        this.interceptors = null;\n\t    }\n\t    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n\t        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n\t        return registerListener(this, callback);\n\t    };\n\t    ObservableObjectAdministration.prototype.intercept = function (handler) {\n\t        return registerInterceptor(this, handler);\n\t    };\n\t    return ObservableObjectAdministration;\n\t}();\n\tfunction asObservableObject(target, name, mode) {\n\t    if (mode === void 0) {\n\t        mode = ValueMode.Recursive;\n\t    }\n\t    if (isObservableObject(target)) return target.$mobx;\n\t    if (!isPlainObject(target)) name = target.constructor.name + \"@\" + getNextId();\n\t    if (!name) name = \"ObservableObject@\" + getNextId();\n\t    var adm = new ObservableObjectAdministration(target, name, mode);\n\t    addHiddenFinalProp(target, \"$mobx\", adm);\n\t    return adm;\n\t}\n\tfunction setObservableObjectInstanceProperty(adm, propName, value) {\n\t    if (adm.values[propName]) adm.target[propName] = value;else defineObservableProperty(adm, propName, value, true);\n\t}\n\tfunction defineObservableProperty(adm, propName, newValue, asInstanceProperty) {\n\t    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n\t    var observable;\n\t    var name = adm.name + \".\" + propName;\n\t    var isComputed = true;\n\t    if (typeof newValue === \"function\" && newValue.length === 0 && !isAction(newValue)) observable = new ComputedValue(newValue, adm.target, false, name);else if (newValue instanceof AsStructure && typeof newValue.value === \"function\" && newValue.value.length === 0) observable = new ComputedValue(newValue.value, adm.target, true, name);else {\n\t        isComputed = false;\n\t        if (hasInterceptors(adm)) {\n\t            var change = interceptChange(adm, {\n\t                object: adm.target,\n\t                name: propName,\n\t                type: \"add\",\n\t                newValue: newValue\n\t            });\n\t            if (!change) return;\n\t            newValue = change.newValue;\n\t        }\n\t        observable = new ObservableValue(newValue, adm.mode, name, false);\n\t        newValue = observable.value;\n\t    }\n\t    adm.values[propName] = observable;\n\t    if (asInstanceProperty) {\n\t        Object.defineProperty(adm.target, propName, isComputed ? generateComputedPropConfig(propName) : generateObservablePropConfig(propName));\n\t    }\n\t    if (!isComputed) notifyPropertyAddition(adm, adm.target, propName, newValue);\n\t}\n\tvar observablePropertyConfigs = {};\n\tvar computedPropertyConfigs = {};\n\tfunction generateObservablePropConfig(propName) {\n\t    var config = observablePropertyConfigs[propName];\n\t    if (config) return config;\n\t    return observablePropertyConfigs[propName] = {\n\t        configurable: true,\n\t        enumerable: true,\n\t        get: function get() {\n\t            return this.$mobx.values[propName].get();\n\t        },\n\t        set: function set(v) {\n\t            setPropertyValue(this, propName, v);\n\t        }\n\t    };\n\t}\n\tfunction generateComputedPropConfig(propName) {\n\t    var config = computedPropertyConfigs[propName];\n\t    if (config) return config;\n\t    return computedPropertyConfigs[propName] = {\n\t        configurable: true,\n\t        enumerable: false,\n\t        get: function get() {\n\t            return this.$mobx.values[propName].get();\n\t        },\n\t        set: throwingComputedValueSetter\n\t    };\n\t}\n\tfunction setPropertyValue(instance, name, newValue) {\n\t    var adm = instance.$mobx;\n\t    var observable = adm.values[name];\n\t    if (hasInterceptors(adm)) {\n\t        var change = interceptChange(adm, {\n\t            type: \"update\",\n\t            object: instance,\n\t            name: name, newValue: newValue\n\t        });\n\t        if (!change) return;\n\t        newValue = change.newValue;\n\t    }\n\t    newValue = observable.prepareNewValue(newValue);\n\t    if (newValue !== UNCHANGED) {\n\t        var notify = hasListeners(adm);\n\t        var notifySpy = isSpyEnabled();\n\t        var change = notifyListeners || hasListeners ? {\n\t            type: \"update\",\n\t            object: instance,\n\t            oldValue: observable.value,\n\t            name: name, newValue: newValue\n\t        } : null;\n\t        if (notifySpy) spyReportStart(change);\n\t        observable.setNewValue(newValue);\n\t        if (notify) notifyListeners(adm, change);\n\t        if (notifySpy) spyReportEnd();\n\t    }\n\t}\n\tfunction notifyPropertyAddition(adm, object, name, newValue) {\n\t    var notify = hasListeners(adm);\n\t    var notifySpy = isSpyEnabled();\n\t    var change = notify || notifySpy ? {\n\t        type: \"add\",\n\t        object: object, name: name, newValue: newValue\n\t    } : null;\n\t    if (notifySpy) spyReportStart(change);\n\t    if (notify) notifyListeners(adm, change);\n\t    if (notifySpy) spyReportEnd();\n\t}\n\tfunction isObservableObject(thing) {\n\t    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n\t        runLazyInitializers(thing);\n\t        return thing.$mobx instanceof ObservableObjectAdministration;\n\t    }\n\t    return false;\n\t}\n\texports.isObservableObject = isObservableObject;\n\tvar UNCHANGED = {};\n\tvar ObservableValue = function (_super) {\n\t    __extends(ObservableValue, _super);\n\t    function ObservableValue(value, mode, name, notifySpy) {\n\t        if (name === void 0) {\n\t            name = \"ObservableValue@\" + getNextId();\n\t        }\n\t        if (notifySpy === void 0) {\n\t            notifySpy = true;\n\t        }\n\t        _super.call(this, name);\n\t        this.mode = mode;\n\t        this.hasUnreportedChange = false;\n\t        this.value = undefined;\n\t        var _a = getValueModeFromValue(value, ValueMode.Recursive),\n\t            childmode = _a[0],\n\t            unwrappedValue = _a[1];\n\t        if (this.mode === ValueMode.Recursive) this.mode = childmode;\n\t        this.value = makeChildObservable(unwrappedValue, this.mode, this.name);\n\t        if (notifySpy && isSpyEnabled()) {\n\t            spyReport({ type: \"create\", object: this, newValue: this.value });\n\t        }\n\t    }\n\t    ObservableValue.prototype.set = function (newValue) {\n\t        var oldValue = this.value;\n\t        newValue = this.prepareNewValue(newValue);\n\t        if (newValue !== UNCHANGED) {\n\t            var notifySpy = isSpyEnabled();\n\t            if (notifySpy) {\n\t                spyReportStart({\n\t                    type: \"update\",\n\t                    object: this,\n\t                    newValue: newValue, oldValue: oldValue\n\t                });\n\t            }\n\t            this.setNewValue(newValue);\n\t            if (notifySpy) spyReportEnd();\n\t        }\n\t    };\n\t    ObservableValue.prototype.prepareNewValue = function (newValue) {\n\t        assertUnwrapped(newValue, \"Modifiers cannot be used on non-initial values.\");\n\t        checkIfStateModificationsAreAllowed();\n\t        if (hasInterceptors(this)) {\n\t            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n\t            if (!change) return UNCHANGED;\n\t            newValue = change.newValue;\n\t        }\n\t        var changed = valueDidChange(this.mode === ValueMode.Structure, this.value, newValue);\n\t        if (changed) return makeChildObservable(newValue, this.mode, this.name);\n\t        return UNCHANGED;\n\t    };\n\t    ObservableValue.prototype.setNewValue = function (newValue) {\n\t        var oldValue = this.value;\n\t        this.value = newValue;\n\t        this.reportChanged();\n\t        if (hasListeners(this)) notifyListeners(this, [newValue, oldValue]);\n\t    };\n\t    ObservableValue.prototype.get = function () {\n\t        this.reportObserved();\n\t        return this.value;\n\t    };\n\t    ObservableValue.prototype.intercept = function (handler) {\n\t        return registerInterceptor(this, handler);\n\t    };\n\t    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n\t        if (fireImmediately) listener(this.value, undefined);\n\t        return registerListener(this, listener);\n\t    };\n\t    ObservableValue.prototype.toJSON = function () {\n\t        return this.get();\n\t    };\n\t    ObservableValue.prototype.toString = function () {\n\t        return this.name + \"[\" + this.value + \"]\";\n\t    };\n\t    return ObservableValue;\n\t}(BaseAtom);\n\tfunction getAtom(thing, property) {\n\t    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n\t        if (isObservableArray(thing)) {\n\t            invariant(property === undefined, \"It is not possible to get index atoms from arrays\");\n\t            return thing.$mobx.atom;\n\t        }\n\t        if (isObservableMap(thing)) {\n\t            if (property === undefined) return getAtom(thing._keys);\n\t            var observable_1 = thing._data[property] || thing._hasMap[property];\n\t            invariant(!!observable_1, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n\t            return observable_1;\n\t        }\n\t        runLazyInitializers(thing);\n\t        if (isObservableObject(thing)) {\n\t            invariant(!!property, \"please specify a property\");\n\t            var observable_2 = thing.$mobx.values[property];\n\t            invariant(!!observable_2, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n\t            return observable_2;\n\t        }\n\t        if (thing instanceof BaseAtom || thing instanceof ComputedValue || thing instanceof Reaction) {\n\t            return thing;\n\t        }\n\t    } else if (typeof thing === \"function\") {\n\t        if (thing.$mobx instanceof Reaction) {\n\t            return thing.$mobx;\n\t        }\n\t    }\n\t    invariant(false, \"Cannot obtain atom from \" + thing);\n\t}\n\tfunction getAdministration(thing, property) {\n\t    invariant(thing, \"Expection some object\");\n\t    if (property !== undefined) return getAdministration(getAtom(thing, property));\n\t    if (thing instanceof BaseAtom || thing instanceof ComputedValue || thing instanceof Reaction) return thing;\n\t    if (isObservableMap(thing)) return thing;\n\t    runLazyInitializers(thing);\n\t    if (thing.$mobx) return thing.$mobx;\n\t    invariant(false, \"Cannot obtain administration from \" + thing);\n\t}\n\tfunction getDebugName(thing, property) {\n\t    var named;\n\t    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n\t    return named.name;\n\t}\n\tfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n\t    function classPropertyDecorator(target, key, descriptor, customArgs) {\n\t        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n\t        if (!descriptor) {\n\t            var newDescriptor = {\n\t                enumerable: enumerable,\n\t                configurable: true,\n\t                get: function get() {\n\t                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n\t                    return _get.call(this, key);\n\t                },\n\t                set: function set(v) {\n\t                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n\t                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n\t                    } else {\n\t                        _set.call(this, key, v);\n\t                    }\n\t                }\n\t            };\n\t            if (arguments.length < 3) {\n\t                Object.defineProperty(target, key, newDescriptor);\n\t            }\n\t            return newDescriptor;\n\t        } else {\n\t            if (!target.hasOwnProperty(\"__mobxLazyInitializers\")) {\n\t                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n\t            }\n\t            var value_1 = descriptor.value,\n\t                initializer_1 = descriptor.initializer;\n\t            target.__mobxLazyInitializers.push(function (instance) {\n\t                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n\t            });\n\t            return {\n\t                enumerable: enumerable, configurable: true,\n\t                get: function get() {\n\t                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n\t                    return _get.call(this, key);\n\t                },\n\t                set: function set(v) {\n\t                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n\t                    _set.call(this, key, v);\n\t                }\n\t            };\n\t        }\n\t    }\n\t    if (allowCustomArguments) {\n\t        return function () {\n\t            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n\t            var outerArgs = arguments;\n\t            return function (target, key, descriptor) {\n\t                return classPropertyDecorator(target, key, descriptor, outerArgs);\n\t            };\n\t        };\n\t    }\n\t    return classPropertyDecorator;\n\t}\n\tfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n\t    if (!instance.hasOwnProperty(\"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n\t    instance.__mobxInitializedProps[key] = true;\n\t    onInitialize(instance, key, v, customArgs, baseDescriptor);\n\t}\n\tfunction runLazyInitializers(instance) {\n\t    if (instance.__mobxDidRunLazyInitializers === true) return;\n\t    if (instance.__mobxLazyInitializers) {\n\t        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n\t        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n\t            return initializer(instance);\n\t        });\n\t    }\n\t}\n\tfunction quacksLikeADecorator(args) {\n\t    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n\t}\n\tfunction iteratorSymbol() {\n\t    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\t}\n\tvar IS_ITERATING_MARKER = \"__$$iterating\";\n\tfunction arrayAsIterator(array) {\n\t    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n\t    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n\t    var idx = -1;\n\t    addHiddenFinalProp(array, \"next\", function next() {\n\t        idx++;\n\t        return {\n\t            done: idx >= this.length,\n\t            value: idx < this.length ? this[idx] : undefined\n\t        };\n\t    });\n\t    return array;\n\t}\n\tfunction declareIterator(prototType, iteratorFactory) {\n\t    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n\t}\n\tvar SimpleSet = function () {\n\t    function SimpleSet() {\n\t        this.size = 0;\n\t        this.data = {};\n\t    }\n\t    Object.defineProperty(SimpleSet.prototype, \"length\", {\n\t        get: function get() {\n\t            return this.size;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    SimpleSet.prototype.asArray = function () {\n\t        var res = new Array(this.size);\n\t        var i = 0;\n\t        for (var key in this.data) {\n\t            res[i] = this.data[key];\n\t            i++;\n\t        }\n\t        return res;\n\t    };\n\t    SimpleSet.prototype.add = function (value) {\n\t        var m = value.__mapid;\n\t        if (!(m in this.data)) {\n\t            this.data[m] = value;\n\t            this.size++;\n\t        }\n\t    };\n\t    SimpleSet.prototype.remove = function (value) {\n\t        if (value.__mapid in this.data) {\n\t            delete this.data[value.__mapid];\n\t            this.size--;\n\t        }\n\t    };\n\t    return SimpleSet;\n\t}();\n\texports.SimpleSet = SimpleSet;\n\tvar SimpleEventEmitter = function () {\n\t    function SimpleEventEmitter() {\n\t        this.listeners = [];\n\t        deprecated(\"extras.SimpleEventEmitter is deprecated and will be removed in the next major release\");\n\t    }\n\t    SimpleEventEmitter.prototype.emit = function () {\n\t        var listeners = this.listeners.slice();\n\t        for (var i = 0, l = listeners.length; i < l; i++) {\n\t            listeners[i].apply(null, arguments);\n\t        }\n\t    };\n\t    SimpleEventEmitter.prototype.on = function (listener) {\n\t        var _this = this;\n\t        this.listeners.push(listener);\n\t        return once(function () {\n\t            var idx = _this.listeners.indexOf(listener);\n\t            if (idx !== -1) _this.listeners.splice(idx, 1);\n\t        });\n\t    };\n\t    SimpleEventEmitter.prototype.once = function (listener) {\n\t        var subscription = this.on(function () {\n\t            subscription();\n\t            listener.apply(this, arguments);\n\t        });\n\t        return subscription;\n\t    };\n\t    return SimpleEventEmitter;\n\t}();\n\texports.SimpleEventEmitter = SimpleEventEmitter;\n\tvar EMPTY_ARRAY = [];\n\tObject.freeze(EMPTY_ARRAY);\n\tfunction getNextId() {\n\t    return ++globalState.mobxGuid;\n\t}\n\tfunction invariant(check, message, thing) {\n\t    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n\t}\n\tvar deprecatedMessages = [];\n\tfunction deprecated(msg) {\n\t    if (deprecatedMessages.indexOf(msg) !== -1) return;\n\t    deprecatedMessages.push(msg);\n\t    console.error(\"[mobx] Deprecated: \" + msg);\n\t}\n\tfunction once(func) {\n\t    var invoked = false;\n\t    return function () {\n\t        if (invoked) return;\n\t        invoked = true;\n\t        return func.apply(this, arguments);\n\t    };\n\t}\n\tvar noop = function noop() {};\n\tfunction unique(list) {\n\t    var res = [];\n\t    list.forEach(function (item) {\n\t        if (res.indexOf(item) === -1) res.push(item);\n\t    });\n\t    return res;\n\t}\n\tfunction joinStrings(things, limit, separator) {\n\t    if (limit === void 0) {\n\t        limit = 100;\n\t    }\n\t    if (separator === void 0) {\n\t        separator = \" - \";\n\t    }\n\t    if (!things) return \"\";\n\t    var sliced = things.slice(0, limit);\n\t    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n\t}\n\tfunction isPlainObject(value) {\n\t    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" && Object.getPrototypeOf(value) === Object.prototype;\n\t}\n\tfunction objectAssign() {\n\t    var res = arguments[0];\n\t    for (var i = 1, l = arguments.length; i < l; i++) {\n\t        var source = arguments[i];\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                res[key] = source[key];\n\t            }\n\t        }\n\t    }\n\t    return res;\n\t}\n\tfunction valueDidChange(compareStructural, oldValue, newValue) {\n\t    return compareStructural ? !deepEquals(oldValue, newValue) : oldValue !== newValue;\n\t}\n\tfunction makeNonEnumerable(object, propNames) {\n\t    for (var i = 0; i < propNames.length; i++) {\n\t        addHiddenProp(object, propNames[i], object[propNames[i]]);\n\t    }\n\t}\n\tfunction addHiddenProp(object, propName, value) {\n\t    Object.defineProperty(object, propName, {\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true,\n\t        value: value\n\t    });\n\t}\n\tfunction addHiddenFinalProp(object, propName, value) {\n\t    Object.defineProperty(object, propName, {\n\t        enumerable: false,\n\t        writable: false,\n\t        configurable: false,\n\t        value: value\n\t    });\n\t}\n\tfunction isPropertyConfigurable(object, prop) {\n\t    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n\t    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n\t}\n\tfunction assertPropertyConfigurable(object, prop) {\n\t    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n\t}\n\tfunction getEnumerableKeys(obj) {\n\t    var res = [];\n\t    for (var key in obj) {\n\t        res.push(key);\n\t    }return res;\n\t}\n\tfunction deepEquals(a, b) {\n\t    if (a === null && b === null) return true;\n\t    if (a === undefined && b === undefined) return true;\n\t    var aIsArray = Array.isArray(a) || isObservableArray(a);\n\t    if (aIsArray !== (Array.isArray(b) || isObservableArray(b))) {\n\t        return false;\n\t    } else if (aIsArray) {\n\t        if (a.length !== b.length) return false;\n\t        for (var i = a.length - 1; i >= 0; i--) {\n\t            if (!deepEquals(a[i], b[i])) return false;\n\t        }return true;\n\t    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n\t        if (a === null || b === null) return false;\n\t        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n\t        for (var prop in a) {\n\t            if (!(prop in b)) return false;\n\t            if (!deepEquals(a[prop], b[prop])) return false;\n\t        }\n\t        return true;\n\t    }\n\t    return a === b;\n\t}\n\tvar _a;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(10);\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/*!\n\t * inferno v0.7.25\n\t * (c) 2016 Dominic Gannaway\n\t * Released under the MIT License.\n\t */\n\t(function (global, factory) {\n\t\t( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Inferno = factory();\n\t})(undefined, function () {\n\t\t'use strict';\n\t\n\t\t// Runs only once in applications lifetime\n\t\n\t\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\t\n\t\tfunction isNullOrUndefined(obj) {\n\t\t\treturn isUndefined(obj) || isNull(obj);\n\t\t}\n\t\n\t\tfunction isAttrAnEvent$1(attr) {\n\t\t\treturn attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n\t\t}\n\t\n\t\tfunction isNull(obj) {\n\t\t\treturn obj === null;\n\t\t}\n\t\n\t\tfunction isUndefined(obj) {\n\t\t\treturn obj === undefined;\n\t\t}\n\t\n\t\tfunction VNode(blueprint) {\n\t\t\tthis.bp = blueprint;\n\t\t\tthis.dom = null;\n\t\t\tthis.instance = null;\n\t\t\tthis.tag = null;\n\t\t\tthis.children = null;\n\t\t\tthis.style = null;\n\t\t\tthis.className = null;\n\t\t\tthis.attrs = null;\n\t\t\tthis.events = null;\n\t\t\tthis.hooks = null;\n\t\t\tthis.key = null;\n\t\t\tthis.clipData = null;\n\t\t}\n\t\n\t\tVNode.prototype = {\n\t\t\tsetAttrs: function setAttrs(attrs) {\n\t\t\t\tthis.attrs = attrs;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tsetTag: function setTag(tag) {\n\t\t\t\tthis.tag = tag;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tsetStyle: function setStyle(style) {\n\t\t\t\tthis.style = style;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tsetClassName: function setClassName(className) {\n\t\t\t\tthis.className = className;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tsetChildren: function setChildren(children) {\n\t\t\t\tthis.children = children;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tsetHooks: function setHooks(hooks) {\n\t\t\t\tthis.hooks = hooks;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tsetEvents: function setEvents(events) {\n\t\t\t\tthis.events = events;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tsetKey: function setKey(key) {\n\t\t\t\tthis.key = key;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\t\n\t\tfunction createVNode(bp) {\n\t\t\treturn new VNode(bp);\n\t\t}\n\t\n\t\tfunction isAttrAnEvent(attr) {\n\t\t\treturn attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n\t\t}\n\t\n\t\tfunction isAttrAHook(hook) {\n\t\t\treturn hook === 'onCreated' || hook === 'onAttached' || hook === 'onWillDetach' || hook === 'onWillUpdate' || hook === 'onDidUpdate';\n\t\t}\n\t\n\t\tfunction isAttrAComponentHook(hook) {\n\t\t\treturn hook === 'onComponentWillMount' || hook === 'onComponentDidMount' || hook === 'onComponentWillUnmount' || hook === 'onComponentShouldUpdate' || hook === 'onComponentWillUpdate' || hook === 'onComponentDidUpdate';\n\t\t}\n\t\n\t\tfunction createBlueprint(shape, childrenType) {\n\t\t\tvar tag = shape.tag || null;\n\t\t\tvar tagIsDynamic = tag && tag.arg !== undefined ? true : false;\n\t\n\t\t\tvar children = isNullOrUndefined(shape.children) ? null : shape.children;\n\t\t\tvar childrenIsDynamic = children && children.arg !== undefined ? true : false;\n\t\n\t\t\tvar attrs = shape.attrs || null;\n\t\t\tvar attrsIsDynamic = attrs && attrs.arg !== undefined ? true : false;\n\t\n\t\t\tvar hooks = shape.hooks || null;\n\t\t\tvar hooksIsDynamic = hooks && hooks.arg !== undefined ? true : false;\n\t\n\t\t\tvar events = shape.events || null;\n\t\t\tvar eventsIsDynamic = events && events.arg !== undefined ? true : false;\n\t\n\t\t\tvar key = shape.key === undefined ? null : shape.key;\n\t\t\tvar keyIsDynamic = !isNullOrUndefined(key) && !isNullOrUndefined(key.arg);\n\t\n\t\t\tvar style = shape.style || null;\n\t\t\tvar styleIsDynamic = style && style.arg !== undefined ? true : false;\n\t\n\t\t\tvar className = shape.className === undefined ? null : shape.className;\n\t\t\tvar classNameIsDynamic = className && className.arg !== undefined ? true : false;\n\t\n\t\t\tvar spread = shape.spread === undefined ? null : shape.spread;\n\t\t\tvar hasSpread = shape.spread !== undefined;\n\t\n\t\t\tvar blueprint = {\n\t\t\t\tlazy: shape.lazy || false,\n\t\t\t\tdom: null,\n\t\t\t\tpool: [],\n\t\t\t\ttag: tagIsDynamic ? null : tag,\n\t\t\t\tclassName: className !== '' && className ? className : null,\n\t\t\t\tstyle: style !== '' && style ? style : null,\n\t\t\t\tisComponent: tagIsDynamic,\n\t\t\t\thasAttrs: attrsIsDynamic || (attrs ? true : false),\n\t\t\t\thasHooks: hooksIsDynamic,\n\t\t\t\thasEvents: eventsIsDynamic,\n\t\t\t\thasStyle: styleIsDynamic || (style !== '' && style ? true : false),\n\t\t\t\thasClassName: classNameIsDynamic || (className !== '' && className ? true : false),\n\t\t\t\tchildrenType: childrenType === undefined ? children ? 5 : 0 : childrenType,\n\t\t\t\tattrKeys: null,\n\t\t\t\teventKeys: null,\n\t\t\t\tisSVG: shape.isSVG || false\n\t\t\t};\n\t\n\t\t\treturn function () {\n\t\t\t\tvar vNode = new VNode(blueprint);\n\t\n\t\t\t\tif (tagIsDynamic === true) {\n\t\t\t\t\tvNode.tag = arguments[tag.arg];\n\t\t\t\t}\n\t\t\t\tif (childrenIsDynamic === true) {\n\t\t\t\t\tvNode.children = arguments[children.arg];\n\t\t\t\t}\n\t\t\t\tif (hasSpread) {\n\t\t\t\t\tvar _spread = arguments[spread.arg];\n\t\t\t\t\tvar attrs$1;\n\t\t\t\t\tvar events$1;\n\t\t\t\t\tvar hooks$1;\n\t\t\t\t\tvar attrKeys = [];\n\t\t\t\t\tvar eventKeys = [];\n\t\n\t\t\t\t\tfor (var prop in _spread) {\n\t\t\t\t\t\tvar value = _spread[prop];\n\t\n\t\t\t\t\t\tif (prop === 'className' || prop === 'class' && !blueprint.isSVG) {\n\t\t\t\t\t\t\tvNode.className = value;\n\t\t\t\t\t\t\tblueprint.hasClassName = true;\n\t\t\t\t\t\t} else if (prop === 'style') {\n\t\t\t\t\t\t\tvNode.style = value;\n\t\t\t\t\t\t\tblueprint.hasStyle = true;\n\t\t\t\t\t\t} else if (prop === 'key') {\n\t\t\t\t\t\t\tvNode.key = value;\n\t\t\t\t\t\t} else if (isAttrAHook(prop) || isAttrAComponentHook(prop)) {\n\t\t\t\t\t\t\tif (!hooks$1) {\n\t\t\t\t\t\t\t\thooks$1 = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thooks$1[prop[2].toLowerCase() + prop.substring(3)] = value;\n\t\t\t\t\t\t} else if (isAttrAnEvent(prop)) {\n\t\t\t\t\t\t\tif (!events$1) {\n\t\t\t\t\t\t\t\tevents$1 = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\teventKeys.push(prop.toLowerCase());\n\t\t\t\t\t\t\tevents$1[prop.toLowerCase()] = value;\n\t\t\t\t\t\t} else if (prop === 'children') {\n\t\t\t\t\t\t\tvNode.children = value;\n\t\t\t\t\t\t\tblueprint.childrenType = blueprint.childrenType || 5;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!attrs$1) {\n\t\t\t\t\t\t\t\tattrs$1 = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tattrKeys.push(prop);\n\t\t\t\t\t\t\tattrs$1[prop] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (attrs$1) {\n\t\t\t\t\t\tvNode.attrs = attrs$1;\n\t\t\t\t\t\tblueprint.attrKeys = attrKeys;\n\t\t\t\t\t\tblueprint.hasAttrs = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (events$1) {\n\t\t\t\t\t\tvNode.events = events$1;\n\t\t\t\t\t\tblueprint.eventKeys = eventKeys;\n\t\t\t\t\t\tblueprint.hasEvents = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (hooks$1) {\n\t\t\t\t\t\tvNode.hooks = hooks$1;\n\t\t\t\t\t\tblueprint.hasHooks = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (attrsIsDynamic === true) {\n\t\t\t\t\t\tvNode.attrs = arguments[attrs.arg];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvNode.attrs = attrs;\n\t\t\t\t\t}\n\t\t\t\t\tif (hooksIsDynamic === true) {\n\t\t\t\t\t\tvNode.hooks = arguments[hooks.arg];\n\t\t\t\t\t}\n\t\t\t\t\tif (eventsIsDynamic === true) {\n\t\t\t\t\t\tvNode.events = arguments[events.arg];\n\t\t\t\t\t}\n\t\t\t\t\tif (keyIsDynamic === true) {\n\t\t\t\t\t\tvNode.key = arguments[key.arg];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvNode.key = key;\n\t\t\t\t\t}\n\t\t\t\t\tif (styleIsDynamic === true) {\n\t\t\t\t\t\tvNode.style = arguments[style.arg];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvNode.style = blueprint.style;\n\t\t\t\t\t}\n\t\t\t\t\tif (classNameIsDynamic === true) {\n\t\t\t\t\t\tvNode.className = arguments[className.arg];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvNode.className = blueprint.className;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn vNode;\n\t\t\t};\n\t\t}\n\t\n\t\tfunction VText(text) {\n\t\t\tthis.text = text;\n\t\t\tthis.dom = null;\n\t\t}\n\t\n\t\tfunction createVText(text) {\n\t\t\treturn new VText(text);\n\t\t}\n\t\n\t\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\t\tfunction documentCreateElement(tag, isSVG) {\n\t\t\tvar dom;\n\t\n\t\t\tif (isSVG === true) {\n\t\t\t\tdom = document.createElementNS('http://www.w3.org/2000/svg', tag);\n\t\t\t} else {\n\t\t\t\tdom = document.createElement(tag);\n\t\t\t}\n\t\t\treturn dom;\n\t\t}\n\t\n\t\tfunction createUniversalElement(tag, attrs, isSVG) {\n\t\t\tif (isBrowser) {\n\t\t\t\tvar dom = documentCreateElement(tag, isSVG);\n\t\t\t\tif (attrs) {\n\t\t\t\t\tcreateStaticAttributes(attrs, dom);\n\t\t\t\t}\n\t\t\t\treturn dom;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction createStaticAttributes(attrs, dom) {\n\t\t\tvar attrKeys = Object.keys(attrs);\n\t\n\t\t\tfor (var i = 0; i < attrKeys.length; i++) {\n\t\t\t\tvar attr = attrKeys[i];\n\t\t\t\tvar value = attrs[attr];\n\t\n\t\t\t\tif (attr === 'className') {\n\t\t\t\t\tdom.className = value;\n\t\t\t\t} else {\n\t\t\t\t\tif (value === true) {\n\t\t\t\t\t\tdom.setAttribute(attr, attr);\n\t\t\t\t\t} else if (!isNullOrUndefined(value) && value !== false && !isAttrAnEvent$1(attr)) {\n\t\t\t\t\t\tdom.setAttribute(attr, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tvar index = {\n\t\t\tcreateBlueprint: createBlueprint,\n\t\t\tcreateVNode: createVNode,\n\t\t\tcreateVText: createVText,\n\t\t\tuniversal: {\n\t\t\t\tcreateElement: createUniversalElement\n\t\t\t}\n\t\t};\n\t\n\t\treturn index;\n\t});\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(12);\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/*!\n\t * inferno-dom v0.7.25\n\t * (c) 2016 Dominic Gannaway\n\t * Released under the MIT License.\n\t */\n\t(function (global, factory) {\n\t\t( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.InfernoDOM = factory();\n\t})(undefined, function () {\n\t\t'use strict';\n\t\n\t\tfunction addChildrenToProps(children, props) {\n\t\t\tif (!isNullOrUndefined(children)) {\n\t\t\t\tvar isChildrenArray = isArray(children);\n\t\t\t\tif (isChildrenArray && children.length > 0 || !isChildrenArray) {\n\t\t\t\t\tif (props) {\n\t\t\t\t\t\tprops = Object.assign({}, props, { children: children });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprops = {\n\t\t\t\t\t\t\tchildren: children\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn props;\n\t\t}\n\t\n\t\tvar NO_RENDER = 'NO_RENDER';\n\t\n\t\t// Runs only once in applications lifetime\n\t\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\t\n\t\tfunction isArray(obj) {\n\t\t\treturn obj instanceof Array;\n\t\t}\n\t\n\t\tfunction isStatefulComponent(obj) {\n\t\t\treturn obj.prototype && obj.prototype.render !== undefined;\n\t\t}\n\t\n\t\tfunction isStringOrNumber(obj) {\n\t\t\treturn isString(obj) || isNumber(obj);\n\t\t}\n\t\n\t\tfunction isNullOrUndefined(obj) {\n\t\t\treturn isUndefined(obj) || isNull(obj);\n\t\t}\n\t\n\t\tfunction isInvalidNode(obj) {\n\t\t\treturn isNull(obj) || obj === false || obj === true || isUndefined(obj);\n\t\t}\n\t\n\t\tfunction isFunction(obj) {\n\t\t\treturn typeof obj === 'function';\n\t\t}\n\t\n\t\tfunction isString(obj) {\n\t\t\treturn typeof obj === 'string';\n\t\t}\n\t\n\t\tfunction isNumber(obj) {\n\t\t\treturn typeof obj === 'number';\n\t\t}\n\t\n\t\tfunction isNull(obj) {\n\t\t\treturn obj === null;\n\t\t}\n\t\n\t\tfunction isTrue(obj) {\n\t\t\treturn obj === true;\n\t\t}\n\t\n\t\tfunction isUndefined(obj) {\n\t\t\treturn obj === undefined;\n\t\t}\n\t\n\t\tfunction deepScanChildrenForNode(children, node) {\n\t\t\tif (!isInvalidNode(children)) {\n\t\t\t\tif (isArray(children)) {\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tvar child = children[i];\n\t\n\t\t\t\t\t\tif (!isInvalidNode(child)) {\n\t\t\t\t\t\t\tif (child === node) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else if (child.children) {\n\t\t\t\t\t\t\t\treturn deepScanChildrenForNode(child.children, node);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (children === node) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else if (children.children) {\n\t\t\t\t\t\treturn deepScanChildrenForNode(children.children, node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\n\t\tfunction getRefInstance$1(node, instance) {\n\t\t\tvar children = instance.props.children;\n\t\n\t\t\tif (deepScanChildrenForNode(children, node)) {\n\t\t\t\treturn getRefInstance$1(node, instance._parentComponent);\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t\n\t\tvar recyclingEnabled = true;\n\t\n\t\tfunction recycle(node, bp, lifecycle, context, instance) {\n\t\t\tif (bp !== undefined) {\n\t\t\t\tvar pool = bp.pool;\n\t\t\t\tvar recycledNode = pool.pop();\n\t\n\t\t\t\tif (!isNullOrUndefined(recycledNode)) {\n\t\t\t\t\tpatch(recycledNode, node, null, lifecycle, context, instance, bp.isSVG);\n\t\t\t\t\treturn node.dom;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\n\t\tfunction pool(node) {\n\t\t\tvar bp = node.bp;\n\t\n\t\t\tif (!isNullOrUndefined(bp)) {\n\t\t\t\tbp.pool.push(node);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\n\t\tfunction unmount(input, parentDom) {\n\t\t\tif (isVList(input)) {\n\t\t\t\tunmountVList(input, parentDom, true);\n\t\t\t} else if (isVNode(input)) {\n\t\t\t\tunmountVNode(input, parentDom, false);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction unmountVList(vList, parentDom, removePointer) {\n\t\t\tvar items = vList.items;\n\t\t\tvar itemsLength = items.length;\n\t\t\tvar pointer = vList.pointer;\n\t\n\t\t\tif (itemsLength > 0) {\n\t\t\t\tfor (var i = 0; i < itemsLength; i++) {\n\t\t\t\t\tvar item = items[i];\n\t\n\t\t\t\t\tif (isVList(item)) {\n\t\t\t\t\t\tunmountVList(item, parentDom, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (parentDom) {\n\t\t\t\t\t\t\tremoveChild(parentDom, item.dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tunmount(item, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parentDom && removePointer) {\n\t\t\t\tremoveChild(parentDom, pointer);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction unmountVNode(node, parentDom, shallow) {\n\t\t\tvar instance = node.instance;\n\t\t\tvar instanceHooks = null;\n\t\t\tvar instanceChildren = null;\n\t\n\t\t\tif (!isNullOrUndefined(instance)) {\n\t\t\t\tinstanceHooks = instance.hooks;\n\t\t\t\tinstanceChildren = instance.children;\n\t\n\t\t\t\tif (instance.render !== undefined) {\n\t\t\t\t\tinstance.componentWillUnmount();\n\t\t\t\t\tinstance._unmounted = true;\n\t\t\t\t\tcomponentToDOMNodeMap.delete(instance);\n\t\t\t\t\t!shallow && unmount(instance._lastNode, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar hooks = node.hooks || instanceHooks;\n\t\n\t\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\t\tif (!isNullOrUndefined(hooks.willDetach)) {\n\t\t\t\t\thooks.willDetach(node.dom);\n\t\t\t\t}\n\t\t\t\tif (!isNullOrUndefined(hooks.componentWillUnmount)) {\n\t\t\t\t\thooks.componentWillUnmount(node.dom, hooks);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar children = (isNullOrUndefined(instance) ? node.children : null) || instanceChildren;\n\t\n\t\t\tif (!isNullOrUndefined(children)) {\n\t\t\t\tif (isArray(children)) {\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tunmount(children[i], null);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tunmount(children, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction VText(text) {\n\t\t\tthis.text = text;\n\t\t\tthis.dom = null;\n\t\t}\n\t\n\t\tfunction VPlaceholder() {\n\t\t\tthis.placeholder = true;\n\t\t\tthis.dom = null;\n\t\t}\n\t\n\t\tfunction VList(items) {\n\t\t\tthis.dom = null;\n\t\t\tthis.pointer = null;\n\t\t\tthis.items = items;\n\t\t}\n\t\n\t\tfunction createVText(text) {\n\t\t\treturn new VText(text);\n\t\t}\n\t\n\t\tfunction createVPlaceholder() {\n\t\t\treturn new VPlaceholder();\n\t\t}\n\t\n\t\tfunction createVList(items) {\n\t\t\treturn new VList(items);\n\t\t}\n\t\n\t\tfunction constructDefaults(string, object, value) {\n\t\t\t/* eslint no-return-assign: 0 */\n\t\t\tstring.split(',').forEach(function (i) {\n\t\t\t\treturn object[i] = value;\n\t\t\t});\n\t\t}\n\t\n\t\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\t\tvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\n\t\tvar strictProps = {};\n\t\tvar booleanProps = {};\n\t\tvar namespaces = {};\n\t\tvar isUnitlessNumber = {};\n\t\n\t\tconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\n\t\tconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\n\t\tconstructDefaults('volume,value', strictProps, true);\n\t\tconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,selected,readonly,multiple,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\n\t\tconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\t\n\t\tfunction isVText(o) {\n\t\t\treturn o.text !== undefined;\n\t\t}\n\t\n\t\tfunction isVPlaceholder(o) {\n\t\t\treturn o.placeholder === true;\n\t\t}\n\t\n\t\tfunction isVList(o) {\n\t\t\treturn o.items !== undefined;\n\t\t}\n\t\n\t\tfunction isVNode(o) {\n\t\t\treturn o.tag !== undefined || o.bp !== undefined;\n\t\t}\n\t\n\t\tfunction insertOrAppend(parentDom, newNode, nextNode) {\n\t\t\tif (isNullOrUndefined(nextNode)) {\n\t\t\t\tparentDom.appendChild(newNode);\n\t\t\t} else {\n\t\t\t\tparentDom.insertBefore(newNode, nextNode);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction replaceVListWithNode(parentDom, vList, dom) {\n\t\t\tvar pointer = vList.pointer;\n\t\n\t\t\tunmountVList(vList, parentDom, false);\n\t\t\treplaceNode(parentDom, dom, pointer);\n\t\t}\n\t\n\t\tfunction documentCreateElement(tag, isSVG) {\n\t\t\tvar dom;\n\t\n\t\t\tif (isSVG === true) {\n\t\t\t\tdom = document.createElementNS('http://www.w3.org/2000/svg', tag);\n\t\t\t} else {\n\t\t\t\tdom = document.createElement(tag);\n\t\t\t}\n\t\t\treturn dom;\n\t\t}\n\t\n\t\tfunction appendText(text, parentDom, singleChild) {\n\t\t\tif (parentDom === null) {\n\t\t\t\treturn document.createTextNode(text);\n\t\t\t} else {\n\t\t\t\tif (singleChild) {\n\t\t\t\t\tif (text !== '') {\n\t\t\t\t\t\tparentDom.textContent = text;\n\t\t\t\t\t\treturn parentDom.firstChild;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar textNode = document.createTextNode('');\n\t\n\t\t\t\t\t\tparentDom.appendChild(textNode);\n\t\t\t\t\t\treturn textNode;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar textNode$1 = document.createTextNode(text);\n\t\n\t\t\t\t\tparentDom.appendChild(textNode$1);\n\t\t\t\t\treturn textNode$1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tvar lastInstance = null;\n\t\t\tvar instanceLastNode = lastNode._lastNode;\n\t\n\t\t\tif (!isNullOrUndefined(instanceLastNode)) {\n\t\t\t\tlastInstance = lastNode;\n\t\t\t\tlastNode = instanceLastNode;\n\t\t\t}\n\t\t\tunmount(lastNode, false);\n\t\t\tvar dom = mount(nextNode, null, lifecycle, context, instance, isSVG);\n\t\n\t\t\tnextNode.dom = dom;\n\t\t\treplaceNode(parentDom, dom, lastNode.dom);\n\t\t\tif (lastInstance !== null) {\n\t\t\t\tlastInstance._lastNode = nextNode;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction replaceNode(parentDom, nextDom, lastDom) {\n\t\t\tparentDom.replaceChild(nextDom, lastDom);\n\t\t}\n\t\n\t\tfunction normalise(object) {\n\t\t\tif (isStringOrNumber(object)) {\n\t\t\t\treturn createVText(object);\n\t\t\t} else if (isInvalidNode(object)) {\n\t\t\t\treturn createVPlaceholder();\n\t\t\t} else if (isArray(object)) {\n\t\t\t\treturn createVList(object);\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\t\n\t\tfunction normaliseChild(children, i) {\n\t\t\tvar child = children[i];\n\t\n\t\t\treturn children[i] = normalise(child);\n\t\t}\n\t\n\t\tfunction remove(node, parentDom) {\n\t\t\tif (isVList(node)) {\n\t\t\t\treturn unmount(node, parentDom);\n\t\t\t}\n\t\t\tvar dom = node.dom;\n\t\t\tif (dom === parentDom) {\n\t\t\t\tdom.innerHTML = '';\n\t\t\t} else {\n\t\t\t\tremoveChild(parentDom, dom);\n\t\t\t\tif (recyclingEnabled) {\n\t\t\t\t\tpool(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunmount(node, false);\n\t\t}\n\t\n\t\tfunction removeChild(parentDom, dom) {\n\t\t\tparentDom.removeChild(dom);\n\t\t}\n\t\n\t\tfunction removeEvents(events, lastEventKeys, dom) {\n\t\t\tvar eventKeys = lastEventKeys || Object.keys(events);\n\t\n\t\t\tfor (var i = 0; i < eventKeys.length; i++) {\n\t\t\t\tvar event = eventKeys[i];\n\t\n\t\t\t\tdom[event] = null;\n\t\t\t}\n\t\t}\n\t\n\t\t// TODO: for node we need to check if document is valid\n\t\tfunction getActiveNode() {\n\t\t\treturn document.activeElement;\n\t\t}\n\t\n\t\tfunction removeAllChildren(dom, children) {\n\t\t\tif (recyclingEnabled) {\n\t\t\t\tvar childrenLength = children.length;\n\t\n\t\t\t\tif (childrenLength > 5) {\n\t\t\t\t\tfor (var i = 0; i < childrenLength; i++) {\n\t\t\t\t\t\tvar child = children[i];\n\t\n\t\t\t\t\t\tif (!isInvalidNode(child)) {\n\t\t\t\t\t\t\tpool(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdom.textContent = '';\n\t\t}\n\t\n\t\tfunction resetActiveNode(activeNode) {\n\t\t\tif (activeNode !== null && activeNode !== document.body && document.activeElement !== activeNode) {\n\t\t\t\tactiveNode.focus(); // TODO: verify are we doing new focus event, if user has focus listener this might trigger it\n\t\t\t}\n\t\t}\n\t\n\t\tfunction isKeyed(lastChildren, nextChildren) {\n\t\t\tif (lastChildren.complex) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn nextChildren.length && !isNullOrUndefined(nextChildren[0]) && !isNullOrUndefined(nextChildren[0].key) && lastChildren.length && !isNullOrUndefined(lastChildren[0]) && !isNullOrUndefined(lastChildren[0].key);\n\t\t}\n\t\n\t\tfunction selectOptionValueIfNeeded(vdom, values) {\n\t\t\tif (vdom.tag !== 'option') {\n\t\t\t\tfor (var i = 0, len = vdom.children.length; i < len; i++) {\n\t\t\t\t\tselectOptionValueIfNeeded(vdom.children[i], values);\n\t\t\t\t}\n\t\t\t\t// NOTE! Has to be a return here to catch optGroup elements\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar value = vdom.attrs && vdom.attrs.value;\n\t\n\t\t\tif (values[value]) {\n\t\t\t\tvdom.attrs = vdom.attrs || {};\n\t\t\t\tvdom.attrs.selected = 'selected';\n\t\t\t\tvdom.dom.selected = true;\n\t\t\t} else {\n\t\t\t\tvdom.dom.selected = false;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction selectValue(vdom) {\n\t\t\tvar value = vdom.attrs && vdom.attrs.value;\n\t\n\t\t\tvar values = {};\n\t\t\tif (isArray(value)) {\n\t\t\t\tfor (var i = 0, len = value.length; i < len; i++) {\n\t\t\t\t\tvalues[value[i]] = value[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalues[value] = value;\n\t\t\t}\n\t\t\tfor (var i$1 = 0, len$1 = vdom.children.length; i$1 < len$1; i$1++) {\n\t\t\t\tselectOptionValueIfNeeded(vdom.children[i$1], values);\n\t\t\t}\n\t\n\t\t\tif (vdom.attrs && vdom.attrs[value]) {\n\t\t\t\tdelete vdom.attrs.value; // TODO! Avoid deletion here. Set to null or undef. Not sure what you want to usev\n\t\t\t}\n\t\t}\n\t\n\t\tfunction handleAttachedHooks(hooks, lifecycle, dom) {\n\t\t\tif (!isNullOrUndefined(hooks.created)) {\n\t\t\t\thooks.created(dom);\n\t\t\t}\n\t\t\tif (!isNullOrUndefined(hooks.attached)) {\n\t\t\t\tlifecycle.addListener(function () {\n\t\t\t\t\thooks.attached(dom);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\n\t\tfunction setValueProperty(nextNode) {\n\t\t\tvar value = nextNode.attrs.value;\n\t\t\tif (!isNullOrUndefined(value)) {\n\t\t\t\tnextNode.dom.value = value;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction setFormElementProperties(nextTag, nextNode) {\n\t\t\tif (nextTag === 'input' && nextNode.attrs) {\n\t\t\t\tvar inputType = nextNode.attrs.type;\n\t\t\t\tif (inputType === 'text') {\n\t\t\t\t\tsetValueProperty(nextNode);\n\t\t\t\t} else if (inputType === 'checkbox' || inputType === 'radio') {\n\t\t\t\t\tvar checked = nextNode.attrs.checked;\n\t\t\t\t\tnextNode.dom.checked = !!checked;\n\t\t\t\t}\n\t\t\t} else if (nextTag === 'textarea') {\n\t\t\t\tsetValueProperty(nextNode);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction mount(input, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tif (isVPlaceholder(input)) {\n\t\t\t\treturn mountVPlaceholder(input, parentDom);\n\t\t\t} else if (isVText(input)) {\n\t\t\t\treturn mountVText(input, parentDom);\n\t\t\t} else if (isVList(input)) {\n\t\t\t\treturn mountVList(input, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t} else if (isVNode(input)) {\n\t\t\t\treturn mountVNode$1(input, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t} else {\n\t\t\t\tvar normalisedInput = normalise(input);\n\t\n\t\t\t\tif (input !== normalisedInput) {\n\t\t\t\t\treturn mount(normalisedInput, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Inferno Error: invalid object \\\"\" + (typeof input === 'undefined' ? 'undefined' : _typeof(input)) + \"\\\" passed to mount()\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction mountVNode$1(vNode, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tvar bp = vNode.bp;\n\t\n\t\t\tif (isUndefined(bp)) {\n\t\t\t\treturn mountVNodeWithoutBlueprint(vNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t} else {\n\t\t\t\tif (recyclingEnabled) {\n\t\t\t\t\tvar dom = recycle(vNode, bp, lifecycle, context, instance);\n\t\n\t\t\t\t\tif (!isNull(dom)) {\n\t\t\t\t\t\tif (!isNull(parentDom)) {\n\t\t\t\t\t\t\tparentDom.appendChild(dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn dom;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mountVNodeWithBlueprint(vNode, bp, parentDom, lifecycle, context, instance);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction mountVList(vList, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tvar items = vList.items;\n\t\t\tvar pointer = document.createTextNode('');\n\t\t\tvar dom = document.createDocumentFragment();\n\t\n\t\t\tmountArrayChildren(items, dom, lifecycle, context, instance, isSVG);\n\t\t\tvList.pointer = pointer;\n\t\t\tvList.dom = dom;\n\t\t\tdom.appendChild(pointer);\n\t\t\tif (parentDom) {\n\t\t\t\tinsertOrAppend(parentDom, dom);\n\t\t\t}\n\t\t\treturn dom;\n\t\t}\n\t\n\t\tfunction mountVText(vText, parentDom) {\n\t\t\tvar dom = document.createTextNode(vText.text);\n\t\n\t\t\tvText.dom = dom;\n\t\t\tif (parentDom) {\n\t\t\t\tinsertOrAppend(parentDom, dom);\n\t\t\t}\n\t\t\treturn dom;\n\t\t}\n\t\n\t\tfunction mountVPlaceholder(vPlaceholder, parentDom) {\n\t\t\tvar dom = document.createTextNode('');\n\t\n\t\t\tvPlaceholder.dom = dom;\n\t\t\tif (parentDom) {\n\t\t\t\tinsertOrAppend(parentDom, dom);\n\t\t\t}\n\t\t\treturn dom;\n\t\t}\n\t\n\t\tfunction handleSelects(node) {\n\t\t\tif (node.tag === 'select') {\n\t\t\t\tselectValue(node);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction mountBlueprintAttrs(node, bp, dom, instance) {\n\t\t\thandleSelects(node);\n\t\t\tvar attrs = node.attrs;\n\t\n\t\t\tif (isNull(bp.attrKeys)) {\n\t\t\t\tvar newKeys = Object.keys(attrs);\n\t\t\t\tbp.attrKeys = bp.attrKeys ? bp.attrKeys.concat(newKeys) : newKeys;\n\t\t\t}\n\t\t\tvar attrKeys = bp.attrKeys;\n\t\n\t\t\tmountAttributes(node, attrs, attrKeys, dom, instance);\n\t\t}\n\t\n\t\tfunction mountBlueprintEvents(node, bp, dom) {\n\t\t\tvar events = node.events;\n\t\n\t\t\tif (isNull(bp.eventKeys)) {\n\t\t\t\tbp.eventKeys = Object.keys(events);\n\t\t\t}\n\t\t\tvar eventKeys = bp.eventKeys;\n\t\n\t\t\tmountEvents(events, eventKeys, dom);\n\t\t}\n\t\n\t\tfunction mountVNodeWithBlueprint(node, bp, parentDom, lifecycle, context, instance) {\n\t\t\tvar tag = node.tag;\n\t\n\t\t\tif (isTrue(bp.isComponent)) {\n\t\t\t\treturn mountComponent(node, tag, node.attrs || {}, node.hooks, node.children, instance, parentDom, lifecycle, context);\n\t\t\t}\n\t\t\tvar dom = documentCreateElement(bp.tag, bp.isSVG);\n\t\n\t\t\tnode.dom = dom;\n\t\t\tif (isTrue(bp.hasHooks)) {\n\t\t\t\thandleAttachedHooks(node.hooks, lifecycle, dom);\n\t\t\t}\n\t\t\tif (isTrue(bp.lazy)) {\n\t\t\t\thandleLazyAttached(node, lifecycle, dom);\n\t\t\t}\n\t\t\tvar children = node.children;\n\t\t\t// bp.childrenType:\n\t\t\t// 0: no children\n\t\t\t// 1: text node\n\t\t\t// 2: single child\n\t\t\t// 3: multiple children\n\t\t\t// 4: multiple children (keyed)\n\t\t\t// 5: variable children (defaults to no optimisation)\n\t\n\t\t\tswitch (bp.childrenType) {\n\t\t\t\tcase 1:\n\t\t\t\t\tappendText(children, dom, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmount(node.children, dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tmountArrayChildren(children, dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tmount(children[i], dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\tmountChildren(node, children, dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\n\t\t\tif (isTrue(bp.hasAttrs)) {\n\t\t\t\tmountBlueprintAttrs(node, bp, dom, instance);\n\t\t\t}\n\t\t\tif (isTrue(bp.hasClassName)) {\n\t\t\t\tdom.className = node.className;\n\t\t\t}\n\t\t\tif (isTrue(bp.hasStyle)) {\n\t\t\t\tpatchStyle(null, node.style, dom);\n\t\t\t}\n\t\t\tif (isTrue(bp.hasEvents)) {\n\t\t\t\tmountBlueprintEvents(node, bp, dom);\n\t\t\t}\n\t\t\tif (!isNull(parentDom)) {\n\t\t\t\tparentDom.appendChild(dom);\n\t\t\t}\n\t\t\treturn dom;\n\t\t}\n\t\n\t\tfunction mountVNodeWithoutBlueprint(node, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tvar tag = node.tag;\n\t\n\t\t\tif (isFunction(tag)) {\n\t\t\t\treturn mountComponent(node, tag, node.attrs || {}, node.hooks, node.children, instance, parentDom, lifecycle, context);\n\t\t\t}\n\t\t\tif (!isString(tag) || tag === '') {\n\t\t\t\tthrow Error('Inferno Error: Expected function or string for element tag type');\n\t\t\t}\n\t\t\tif (tag === 'svg') {\n\t\t\t\tisSVG = true;\n\t\t\t}\n\t\t\tvar dom = documentCreateElement(tag, isSVG);\n\t\t\tvar children = node.children;\n\t\t\tvar attrs = node.attrs;\n\t\t\tvar events = node.events;\n\t\t\tvar hooks = node.hooks;\n\t\t\tvar className = node.className;\n\t\t\tvar style = node.style;\n\t\n\t\t\tnode.dom = dom;\n\t\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\t\thandleAttachedHooks(hooks, lifecycle, dom);\n\t\t\t}\n\t\t\tif (!isInvalidNode(children)) {\n\t\t\t\tmountChildren(node, children, dom, lifecycle, context, instance, isSVG);\n\t\t\t}\n\t\t\tif (!isNullOrUndefined(attrs)) {\n\t\t\t\thandleSelects(node);\n\t\t\t\tmountAttributes(node, attrs, Object.keys(attrs), dom, instance);\n\t\t\t}\n\t\t\tif (!isNullOrUndefined(className)) {\n\t\t\t\tdom.className = className;\n\t\t\t}\n\t\t\tif (!isNullOrUndefined(style)) {\n\t\t\t\tpatchStyle(null, style, dom);\n\t\t\t}\n\t\t\tif (!isNullOrUndefined(events)) {\n\t\t\t\tmountEvents(events, Object.keys(events), dom);\n\t\t\t}\n\t\t\tif (!isNull(parentDom)) {\n\t\t\t\tparentDom.appendChild(dom);\n\t\t\t}\n\t\t\treturn dom;\n\t\t}\n\t\n\t\tfunction mountArrayChildren(children, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tchildren.complex = false;\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = normaliseChild(children, i);\n\t\n\t\t\t\tif (isVText(child)) {\n\t\t\t\t\tmountVText(child, parentDom);\n\t\t\t\t\tchildren.complex = true;\n\t\t\t\t} else if (isVPlaceholder(child)) {\n\t\t\t\t\tmountVPlaceholder(child, parentDom);\n\t\t\t\t\tchildren.complex = true;\n\t\t\t\t} else if (isVList(child)) {\n\t\t\t\t\tmountVList(child, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t\tchildren.complex = true;\n\t\t\t\t} else {\n\t\t\t\t\tmount(child, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction mountChildren(node, children, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tif (isArray(children)) {\n\t\t\t\tmountArrayChildren(children, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t} else if (isStringOrNumber(children)) {\n\t\t\t\tappendText(children, parentDom, true);\n\t\t\t} else if (!isInvalidNode(children)) {\n\t\t\t\tmount(children, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction mountRef(instance, value, refValue) {\n\t\t\tif (!isInvalidNode(instance) && isString(value)) {\n\t\t\t\tinstance.refs[value] = refValue;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction mountEvents(events, eventKeys, dom) {\n\t\t\tfor (var i = 0; i < eventKeys.length; i++) {\n\t\t\t\tvar event = eventKeys[i];\n\t\n\t\t\t\tdom[event] = events[event];\n\t\t\t}\n\t\t}\n\t\n\t\tfunction mountComponent(parentNode, Component, props, hooks, children, lastInstance, parentDom, lifecycle, context) {\n\t\t\tprops = addChildrenToProps(children, props);\n\t\n\t\t\tvar dom;\n\t\t\tif (isStatefulComponent(Component)) {\n\t\t\t\tvar instance = new Component(props, context);\n\t\n\t\t\t\tinstance._patch = patch;\n\t\t\t\tinstance._componentToDOMNodeMap = componentToDOMNodeMap;\n\t\t\t\tif (!isNullOrUndefined(lastInstance) && props.ref) {\n\t\t\t\t\tmountRef(lastInstance, props.ref, instance);\n\t\t\t\t}\n\t\t\t\tvar childContext = instance.getChildContext();\n\t\n\t\t\t\tif (!isNullOrUndefined(childContext)) {\n\t\t\t\t\tcontext = Object.assign({}, context, childContext);\n\t\t\t\t}\n\t\t\t\tinstance.context = context;\n\t\t\t\tinstance._unmounted = false;\n\t\t\t\tinstance._parentNode = parentNode;\n\t\t\t\tif (lastInstance) {\n\t\t\t\t\tinstance._parentComponent = lastInstance;\n\t\t\t\t}\n\t\t\t\tinstance._pendingSetState = true;\n\t\t\t\tinstance.componentWillMount();\n\t\t\t\tvar node = instance.render();\n\t\n\t\t\t\tif (isInvalidNode(node)) {\n\t\t\t\t\tnode = createVPlaceholder();\n\t\t\t\t}\n\t\t\t\tinstance._pendingSetState = false;\n\t\t\t\tdom = mount(node, null, lifecycle, context, instance, false);\n\t\t\t\tinstance._lastNode = node;\n\t\t\t\tinstance.componentDidMount();\n\t\t\t\tif (parentDom !== null && !isInvalidNode(dom)) {\n\t\t\t\t\tparentDom.appendChild(dom);\n\t\t\t\t}\n\t\t\t\tcomponentToDOMNodeMap.set(instance, dom);\n\t\t\t\tparentNode.dom = dom;\n\t\t\t\tparentNode.instance = instance;\n\t\t\t} else {\n\t\t\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\t\t\tif (!isNullOrUndefined(hooks.componentWillMount)) {\n\t\t\t\t\t\thooks.componentWillMount(null, props);\n\t\t\t\t\t}\n\t\t\t\t\tif (!isNullOrUndefined(hooks.componentDidMount)) {\n\t\t\t\t\t\tlifecycle.addListener(function () {\n\t\t\t\t\t\t\thooks.componentDidMount(dom, props);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t/* eslint new-cap: 0 */\n\t\t\t\tvar node$1 = Component(props, context);\n\t\n\t\t\t\tif (isInvalidNode(node$1)) {\n\t\t\t\t\tnode$1 = createVPlaceholder();\n\t\t\t\t}\n\t\t\t\tdom = mount(node$1, null, lifecycle, context, null, false);\n\t\n\t\t\t\tparentNode.instance = node$1;\n\t\n\t\t\t\tif (parentDom !== null && !isInvalidNode(dom)) {\n\t\t\t\t\tparentDom.appendChild(dom);\n\t\t\t\t}\n\t\t\t\tparentNode.dom = dom;\n\t\t\t}\n\t\t\treturn dom;\n\t\t}\n\t\n\t\tfunction mountAttributes(node, attrs, attrKeys, dom, instance) {\n\t\t\tfor (var i = 0; i < attrKeys.length; i++) {\n\t\t\t\tvar attr = attrKeys[i];\n\t\n\t\t\t\tif (attr === 'ref') {\n\t\t\t\t\tmountRef(getRefInstance$1(node, instance), attrs[attr], dom);\n\t\t\t\t} else {\n\t\t\t\t\tpatchAttribute(attr, null, attrs[attr], dom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patch(lastInput, nextInput, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tif (lastInput !== nextInput) {\n\t\t\t\tif (isInvalidNode(lastInput)) {\n\t\t\t\t\tmount(nextInput, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t} else if (isInvalidNode(nextInput)) {\n\t\t\t\t\tremove(lastInput, parentDom);\n\t\t\t\t} else if (isStringOrNumber(lastInput)) {\n\t\t\t\t\tif (isStringOrNumber(nextInput)) {\n\t\t\t\t\t\tparentDom.firstChild.nodeValue = nextInput;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar dom = mount(nextInput, null, lifecycle, context, instance, isSVG);\n\t\n\t\t\t\t\t\tnextInput.dom = dom;\n\t\t\t\t\t\treplaceNode(parentDom, dom, parentDom.firstChild);\n\t\t\t\t\t}\n\t\t\t\t} else if (isStringOrNumber(nextInput)) {\n\t\t\t\t\treplaceNode(parentDom, document.createTextNode(nextInput), lastInput.dom);\n\t\t\t\t} else {\n\t\t\t\t\tif (isVList(nextInput)) {\n\t\t\t\t\t\tif (isVList(lastInput)) {\n\t\t\t\t\t\t\tpatchVList(lastInput, nextInput, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treplaceNode(parentDom, mountVList(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (isVList(lastInput)) {\n\t\t\t\t\t\treplaceVListWithNode(parentDom, lastInput, mount(nextInput, null, lifecycle, context, instance, isSVG));\n\t\t\t\t\t} else if (isVPlaceholder(nextInput)) {\n\t\t\t\t\t\tif (isVPlaceholder(lastInput)) {\n\t\t\t\t\t\t\tpatchVFragment(lastInput, nextInput);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treplaceNode(parentDom, mountVPlaceholder(nextInput, null), lastInput.dom);\n\t\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (isVPlaceholder(lastInput)) {\n\t\t\t\t\t\treplaceNode(parentDom, mount(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\t} else if (isVText(nextInput)) {\n\t\t\t\t\t\tif (isVText(lastInput)) {\n\t\t\t\t\t\t\tpatchVText(lastInput, nextInput);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treplaceNode(parentDom, mountVText(nextInput, null), lastInput.dom);\n\t\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (isVText(lastInput)) {\n\t\t\t\t\t\treplaceNode(parentDom, mount(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\t} else if (isVNode(nextInput)) {\n\t\t\t\t\t\tif (isVNode(lastInput)) {\n\t\t\t\t\t\t\tpatchVNode(lastInput, nextInput, parentDom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treplaceNode(parentDom, mountVNode(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (isVNode(lastInput)) {\n\t\t\t\t\t\treplaceNode(parentDom, mount(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn patch(lastInput, normalise(nextInput), parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nextInput;\n\t\t}\n\t\n\t\tfunction patchTextNode(dom, lastChildren, nextChildren) {\n\t\t\tif (isStringOrNumber(lastChildren)) {\n\t\t\t\tdom.firstChild.nodeValue = nextChildren;\n\t\t\t} else {\n\t\t\t\tdom.textContent = nextChildren;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchRef(instance, lastValue, nextValue, dom) {\n\t\t\tif (instance) {\n\t\t\t\tif (isString(lastValue)) {\n\t\t\t\t\tdelete instance.refs[lastValue];\n\t\t\t\t}\n\t\t\t\tif (isString(nextValue)) {\n\t\t\t\t\tinstance.refs[nextValue] = dom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchChildren(lastNode, nextNode, dom, lifecycle, context, instance, isSVG) {\n\t\t\tvar nextChildren = nextNode.children;\n\t\t\tvar lastChildren = lastNode.children;\n\t\n\t\t\tif (lastChildren === nextChildren) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isInvalidNode(lastChildren)) {\n\t\t\t\tif (isStringOrNumber(nextChildren)) {\n\t\t\t\t\tpatchTextNode(dom, lastChildren, nextChildren);\n\t\t\t\t} else if (!isInvalidNode(nextChildren)) {\n\t\t\t\t\tif (isArray(nextChildren)) {\n\t\t\t\t\t\tmountArrayChildren(nextChildren, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmount(nextChildren, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isInvalidNode(nextChildren)) {\n\t\t\t\t\tremoveAllChildren(dom, lastChildren);\n\t\t\t\t} else {\n\t\t\t\t\tif (isArray(lastChildren)) {\n\t\t\t\t\t\tif (isArray(nextChildren)) {\n\t\t\t\t\t\t\tnextChildren.complex = lastChildren.complex;\n\t\t\t\t\t\t\tif (isKeyed(lastChildren, nextChildren)) {\n\t\t\t\t\t\t\t\tpatchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpatchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpatchNonKeyedChildren(lastChildren, [nextChildren], dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (isArray(nextChildren)) {\n\t\t\t\t\t\t\tvar lastChild = lastChildren;\n\t\n\t\t\t\t\t\t\tif (isStringOrNumber(lastChildren)) {\n\t\t\t\t\t\t\t\tlastChild = createVText(lastChild);\n\t\t\t\t\t\t\t\tlastChild.dom = dom.firstChild;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpatchNonKeyedChildren([lastChild], nextChildren, dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t\t} else if (isStringOrNumber(nextChildren)) {\n\t\t\t\t\t\t\tpatchTextNode(dom, lastChildren, nextChildren);\n\t\t\t\t\t\t} else if (isStringOrNumber(lastChildren)) {\n\t\t\t\t\t\t\tpatch(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpatchVNode(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchVNode(lastVNode, nextVNode, parentDom, lifecycle, context, instance, isSVG, skipLazyCheck) {\n\t\t\tvar lastBp = lastVNode.bp;\n\t\t\tvar nextBp = nextVNode.bp;\n\t\n\t\t\tif (lastBp === undefined || nextBp === undefined) {\n\t\t\t\tpatchVNodeWithoutBlueprint(lastVNode, nextVNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t} else {\n\t\t\t\tpatchVNodeWithBlueprint(lastVNode, nextVNode, lastBp, nextBp, parentDom, lifecycle, context, instance, skipLazyCheck);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchVNodeWithBlueprint(lastVNode, nextVNode, lastBp, nextBp, parentDom, lifecycle, context, instance, skipLazyCheck) {\n\t\t\tvar nextHooks;\n\t\n\t\t\tif (nextBp.hasHooks === true) {\n\t\t\t\tnextHooks = nextVNode.hooks;\n\t\t\t\tif (nextHooks && !isNullOrUndefined(nextHooks.willUpdate)) {\n\t\t\t\t\tnextHooks.willUpdate(lastVNode.dom);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar nextTag = nextVNode.tag || nextBp.tag;\n\t\t\tvar lastTag = lastVNode.tag || lastBp.tag;\n\t\n\t\t\tif (lastTag !== nextTag) {\n\t\t\t\tif (lastBp.isComponent === true) {\n\t\t\t\t\tvar lastNodeInstance = lastVNode.instance;\n\t\n\t\t\t\t\tif (nextBp.isComponent === true) {\n\t\t\t\t\t\treplaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, instance, false);\n\t\t\t\t\t} else if (isStatefulComponent(lastTag)) {\n\t\t\t\t\t\tunmountVNode(lastVNode, null, true);\n\t\t\t\t\t\tvar lastNode = lastNodeInstance._lastNode;\n\t\t\t\t\t\tpatchVNodeWithBlueprint(lastNode, nextVNode, lastNode.bp, nextBp, parentDom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunmountVNode(lastVNode, null, true);\n\t\t\t\t\t\tpatchVNodeWithBlueprint(lastNodeInstance, nextVNode, lastNodeInstance.bp, nextBp, parentDom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treplaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t}\n\t\t\t} else if (isNullOrUndefined(lastTag)) {\n\t\t\t\tnextVNode.dom = lastVNode.dom;\n\t\t\t} else {\n\t\t\t\tif (lastBp.isComponent === true) {\n\t\t\t\t\tif (nextBp.isComponent === true) {\n\t\t\t\t\t\tvar instance$1 = lastVNode.instance;\n\t\n\t\t\t\t\t\tif (!isNullOrUndefined(instance$1) && instance$1._unmounted) {\n\t\t\t\t\t\t\tvar newDom = mountComponent(nextVNode, lastTag, nextVNode.attrs || {}, nextVNode.hooks, nextVNode.children, instance$1, parentDom, lifecycle, context);\n\t\t\t\t\t\t\tif (parentDom !== null) {\n\t\t\t\t\t\t\t\treplaceNode(parentDom, newDom, lastVNode.dom);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnextVNode.instance = instance$1;\n\t\t\t\t\t\t\tnextVNode.dom = lastVNode.dom;\n\t\t\t\t\t\t\tpatchComponent(true, nextVNode, nextVNode.tag, lastBp, nextBp, instance$1, lastVNode.attrs || {}, nextVNode.attrs || {}, nextVNode.hooks, lastVNode.children, nextVNode.children, parentDom, lifecycle, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar dom = lastVNode.dom;\n\t\t\t\t\tvar lastChildrenType = lastBp.childrenType;\n\t\t\t\t\tvar nextChildrenType = nextBp.childrenType;\n\t\t\t\t\tnextVNode.dom = dom;\n\t\n\t\t\t\t\tif (nextBp.lazy === true && skipLazyCheck === false) {\n\t\t\t\t\t\tvar clipData = lastVNode.clipData;\n\t\n\t\t\t\t\t\tif (lifecycle.scrollY === null) {\n\t\t\t\t\t\t\tlifecycle.refresh();\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tnextVNode.clipData = clipData;\n\t\t\t\t\t\tif (clipData.pending === true || clipData.top - lifecycle.scrollY > lifecycle.screenHeight) {\n\t\t\t\t\t\t\tif (setClipNode(clipData, dom, lastVNode, nextVNode, parentDom, lifecycle, context, instance, lastBp.isSVG)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (clipData.bottom < lifecycle.scrollY) {\n\t\t\t\t\t\t\tif (setClipNode(clipData, dom, lastVNode, nextVNode, parentDom, lifecycle, context, instance, lastBp.isSVG)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (lastChildrenType > 0 || nextChildrenType > 0) {\n\t\t\t\t\t\tif (nextChildrenType === 5 || lastChildrenType === 5) {\n\t\t\t\t\t\t\tpatchChildren(lastVNode, nextVNode, dom, lifecycle, context, instance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar lastChildren = lastVNode.children;\n\t\t\t\t\t\t\tvar nextChildren = nextVNode.children;\n\t\n\t\t\t\t\t\t\tif (lastChildrenType === 0 || isInvalidNode(lastChildren)) {\n\t\t\t\t\t\t\t\tif (nextChildrenType > 2) {\n\t\t\t\t\t\t\t\t\tmountArrayChildren(nextChildren, dom, lifecycle, context, instance);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmount(nextChildren, dom, lifecycle, context, instance);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (nextChildrenType === 0 || isInvalidNode(nextChildren)) {\n\t\t\t\t\t\t\t\tif (lastChildrenType > 2) {\n\t\t\t\t\t\t\t\t\tremoveAllChildren(dom, lastChildren);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tremove(lastChildren, dom);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (lastChildren !== nextChildren) {\n\t\t\t\t\t\t\t\t\tif (lastChildrenType === 4 && nextChildrenType === 4) {\n\t\t\t\t\t\t\t\t\t\tpatchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, nextBp.isSVG, null);\n\t\t\t\t\t\t\t\t\t} else if (lastChildrenType === 2 && nextChildrenType === 2) {\n\t\t\t\t\t\t\t\t\t\tpatch(lastChildren, nextChildren, dom, lifecycle, context, instance, true, nextBp.isSVG);\n\t\t\t\t\t\t\t\t\t} else if (lastChildrenType === 1 && nextChildrenType === 1) {\n\t\t\t\t\t\t\t\t\t\tpatchTextNode(dom, lastChildren, nextChildren);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpatchChildren(lastVNode, nextVNode, dom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (lastBp.hasAttrs === true || nextBp.hasAttrs === true) {\n\t\t\t\t\t\tpatchAttributes(lastVNode, nextVNode, lastBp.attrKeys, nextBp.attrKeys, dom, instance);\n\t\t\t\t\t}\n\t\t\t\t\tif (lastBp.hasEvents === true || nextBp.hasEvents === true) {\n\t\t\t\t\t\tpatchEvents(lastVNode.events, nextVNode.events, lastBp.eventKeys, nextBp.eventKeys, dom);\n\t\t\t\t\t}\n\t\t\t\t\tif (lastBp.hasClassName === true || nextBp.hasClassName === true) {\n\t\t\t\t\t\tvar nextClassName = nextVNode.className;\n\t\n\t\t\t\t\t\tif (lastVNode.className !== nextClassName) {\n\t\t\t\t\t\t\tif (isNullOrUndefined(nextClassName)) {\n\t\t\t\t\t\t\t\tdom.removeAttribute('class');\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdom.className = nextClassName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (lastBp.hasStyle === true || nextBp.hasStyle === true) {\n\t\t\t\t\t\tvar nextStyle = nextVNode.style;\n\t\t\t\t\t\tvar lastStyle = lastVNode.style;\n\t\n\t\t\t\t\t\tif (lastStyle !== nextStyle) {\n\t\t\t\t\t\t\tpatchStyle(lastStyle, nextStyle, dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (nextBp.hasHooks === true && !isNullOrUndefined(nextHooks.didUpdate)) {\n\t\t\t\t\t\tnextHooks.didUpdate(dom);\n\t\t\t\t\t}\n\t\t\t\t\tsetFormElementProperties(nextTag, nextVNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchVNodeWithoutBlueprint(lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tvar nextHooks = nextNode.hooks;\n\t\t\tvar nextHooksDefined = !isNullOrUndefined(nextHooks);\n\t\n\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.willUpdate)) {\n\t\t\t\tnextHooks.willUpdate(lastNode.dom);\n\t\t\t}\n\t\t\tvar nextTag = nextNode.tag || (isNullOrUndefined(nextNode.bp) ? null : nextNode.bp.tag);\n\t\t\tvar lastTag = lastNode.tag || (isNullOrUndefined(lastNode.bp) ? null : lastNode.bp.tag);\n\t\n\t\t\tif (nextTag === 'svg') {\n\t\t\t\tisSVG = true;\n\t\t\t}\n\t\t\tif (lastTag !== nextTag) {\n\t\t\t\tvar lastNodeInstance = lastNode.instance;\n\t\n\t\t\t\tif (isFunction(lastTag)) {\n\t\t\t\t\tif (isFunction(nextTag)) {\n\t\t\t\t\t\treplaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t} else if (isStatefulComponent(lastTag)) {\n\t\t\t\t\t\tunmountVNode(lastNode, null, true);\n\t\t\t\t\t\tpatchVNodeWithoutBlueprint(lastNodeInstance._lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunmountVNode(lastNode, null, true);\n\t\t\t\t\t\tpatchVNodeWithoutBlueprint(lastNodeInstance, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treplaceWithNewNode(lastNodeInstance || lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t}\n\t\t\t} else if (isNullOrUndefined(lastTag)) {\n\t\t\t\tnextNode.dom = lastNode.dom;\n\t\t\t} else {\n\t\t\t\tif (isFunction(lastTag)) {\n\t\t\t\t\tif (isFunction(nextTag)) {\n\t\t\t\t\t\tvar instance$1 = lastNode._instance;\n\t\n\t\t\t\t\t\tif (!isNullOrUndefined(instance$1) && instance$1._unmounted) {\n\t\t\t\t\t\t\tvar newDom = mountComponent(nextNode, lastTag, nextNode.attrs || {}, nextNode.hooks, nextNode.children, instance$1, parentDom, lifecycle, context);\n\t\t\t\t\t\t\tif (parentDom !== null) {\n\t\t\t\t\t\t\t\treplaceNode(parentDom, newDom, lastNode.dom);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnextNode.instance = lastNode.instance;\n\t\t\t\t\t\t\tnextNode.dom = lastNode.dom;\n\t\t\t\t\t\t\tpatchComponent(false, nextNode, nextNode.tag, null, null, nextNode.instance, lastNode.attrs || {}, nextNode.attrs || {}, nextNode.hooks, lastNode.children, nextNode.children, parentDom, lifecycle, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar dom = lastNode.dom;\n\t\t\t\t\tvar nextClassName = nextNode.className;\n\t\t\t\t\tvar nextStyle = nextNode.style;\n\t\n\t\t\t\t\tnextNode.dom = dom;\n\t\n\t\t\t\t\tpatchChildren(lastNode, nextNode, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t\tpatchAttributes(lastNode, nextNode, null, null, dom, instance);\n\t\t\t\t\tpatchEvents(lastNode.events, nextNode.events, null, null, dom);\n\t\n\t\t\t\t\tif (lastNode.className !== nextClassName) {\n\t\t\t\t\t\tif (isNullOrUndefined(nextClassName)) {\n\t\t\t\t\t\t\tdom.removeAttribute('class');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdom.className = nextClassName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (lastNode.style !== nextStyle) {\n\t\t\t\t\t\tpatchStyle(lastNode.style, nextStyle, dom);\n\t\t\t\t\t}\n\t\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.didUpdate)) {\n\t\t\t\t\t\tnextHooks.didUpdate(dom);\n\t\t\t\t\t}\n\t\t\t\t\tsetFormElementProperties(nextTag, nextNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchAttributes(lastNode, nextNode, lastAttrKeys, nextAttrKeys, dom, instance) {\n\t\t\tif (lastNode.tag === 'select') {\n\t\t\t\tselectValue(nextNode);\n\t\t\t}\n\t\t\tvar nextAttrs = nextNode.attrs;\n\t\t\tvar lastAttrs = lastNode.attrs;\n\t\t\tvar nextAttrsIsUndef = isNullOrUndefined(nextAttrs);\n\t\t\tvar lastAttrsIsNotUndef = !isNullOrUndefined(lastAttrs);\n\t\n\t\t\tif (!nextAttrsIsUndef) {\n\t\t\t\tvar nextAttrsKeys = nextAttrKeys || Object.keys(nextAttrs);\n\t\t\t\tvar attrKeysLength = nextAttrsKeys.length;\n\t\n\t\t\t\tfor (var i = 0; i < attrKeysLength; i++) {\n\t\t\t\t\tvar attr = nextAttrsKeys[i];\n\t\t\t\t\tvar lastAttrVal = lastAttrsIsNotUndef && lastAttrs[attr];\n\t\t\t\t\tvar nextAttrVal = nextAttrs[attr];\n\t\n\t\t\t\t\tif (lastAttrVal !== nextAttrVal) {\n\t\t\t\t\t\tif (attr === 'ref') {\n\t\t\t\t\t\t\tpatchRef(instance, lastAttrVal, nextAttrVal, dom);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpatchAttribute(attr, lastAttrVal, nextAttrVal, dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lastAttrsIsNotUndef) {\n\t\t\t\tvar lastAttrsKeys = lastAttrKeys || Object.keys(lastAttrs);\n\t\t\t\tvar attrKeysLength$1 = lastAttrsKeys.length;\n\t\n\t\t\t\tfor (var i$1 = 0; i$1 < attrKeysLength$1; i$1++) {\n\t\t\t\t\tvar attr$1 = lastAttrsKeys[i$1];\n\t\n\t\t\t\t\tif (nextAttrsIsUndef || isNullOrUndefined(nextAttrs[attr$1])) {\n\t\t\t\t\t\tif (attr$1 === 'ref') {\n\t\t\t\t\t\t\tpatchRef(getRefInstance(node, instance), lastAttrs[attr$1], null, dom);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdom.removeAttribute(attr$1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n\t\t\tif (isString(nextAttrValue)) {\n\t\t\t\tdom.style.cssText = nextAttrValue;\n\t\t\t} else if (isNullOrUndefined(lastAttrValue)) {\n\t\t\t\tif (!isNullOrUndefined(nextAttrValue)) {\n\t\t\t\t\tvar styleKeys = Object.keys(nextAttrValue);\n\t\n\t\t\t\t\tfor (var i = 0; i < styleKeys.length; i++) {\n\t\t\t\t\t\tvar style = styleKeys[i];\n\t\t\t\t\t\tvar value = nextAttrValue[style];\n\t\n\t\t\t\t\t\tif (isNumber(value) && !isUnitlessNumber[style]) {\n\t\t\t\t\t\t\tdom.style[style] = value + 'px';\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdom.style[style] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (isNullOrUndefined(nextAttrValue)) {\n\t\t\t\tdom.removeAttribute('style');\n\t\t\t} else {\n\t\t\t\tvar styleKeys$1 = Object.keys(nextAttrValue);\n\t\n\t\t\t\tfor (var i$1 = 0; i$1 < styleKeys$1.length; i$1++) {\n\t\t\t\t\tvar style$1 = styleKeys$1[i$1];\n\t\t\t\t\tvar value$1 = nextAttrValue[style$1];\n\t\n\t\t\t\t\tif (isNumber(value$1) && !isUnitlessNumber[style$1]) {\n\t\t\t\t\t\tdom.style[style$1] = value$1 + 'px';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.style[style$1] = value$1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar lastStyleKeys = Object.keys(lastAttrValue);\n\t\n\t\t\t\tfor (var i$2 = 0; i$2 < lastStyleKeys.length; i$2++) {\n\t\t\t\t\tvar style$2 = lastStyleKeys[i$2];\n\t\t\t\t\tif (isNullOrUndefined(nextAttrValue[style$2])) {\n\t\t\t\t\t\tdom.style[style$2] = '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchEvents(lastEvents, nextEvents, _lastEventKeys, _nextEventKeys, dom) {\n\t\t\tvar nextEventsDefined = !isNullOrUndefined(nextEvents);\n\t\t\tvar lastEventsDefined = !isNullOrUndefined(lastEvents);\n\t\t\tvar lastEventKeys;\n\t\n\t\t\tif (lastEventsDefined) {\n\t\t\t\tlastEventKeys = _lastEventKeys || Object.keys(lastEvents);\n\t\t\t}\n\t\t\tif (nextEventsDefined) {\n\t\t\t\tvar nextEventKeys = _nextEventKeys || Object.keys(nextEvents);\n\t\n\t\t\t\tif (lastEventsDefined) {\n\t\t\t\t\tfor (var i = 0; i < nextEventKeys.length; i++) {\n\t\t\t\t\t\tvar event = nextEventKeys[i];\n\t\t\t\t\t\tvar lastEvent = lastEvents[event];\n\t\t\t\t\t\tvar nextEvent = nextEvents[event];\n\t\n\t\t\t\t\t\tif (lastEvent !== nextEvent) {\n\t\t\t\t\t\t\tdom[event] = nextEvent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i$1 = 0; i$1 < lastEventKeys.length; i$1++) {\n\t\t\t\t\t\tvar event$1 = lastEventKeys[i$1];\n\t\n\t\t\t\t\t\tif (isNullOrUndefined(nextEvents[event$1])) {\n\t\t\t\t\t\t\tdom[event$1] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmountEvents(nextEvents, nextEventKeys, dom);\n\t\t\t\t}\n\t\t\t} else if (lastEventsDefined) {\n\t\t\t\tremoveEvents(lastEvents, lastEventKeys, dom);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchAttribute(attrName, lastAttrValue, nextAttrValue, dom) {\n\t\t\tif (attrName === 'dangerouslySetInnerHTML') {\n\t\t\t\tvar lastHtml = lastAttrValue && lastAttrValue.__html;\n\t\t\t\tvar nextHtml = nextAttrValue && nextAttrValue.__html;\n\t\n\t\t\t\tif (isNullOrUndefined(nextHtml)) {\n\t\t\t\t\tthrow new Error('Inferno Error: dangerouslySetInnerHTML requires an object with a __html propety containing the innerHTML content');\n\t\t\t\t}\n\t\t\t\tif (lastHtml !== nextHtml) {\n\t\t\t\t\tdom.innerHTML = nextHtml;\n\t\t\t\t}\n\t\t\t} else if (attrName === 'eventData') {\n\t\t\t\tdom.eventData = nextAttrValue;\n\t\t\t} else if (strictProps[attrName]) {\n\t\t\t\tdom[attrName] = nextAttrValue === null ? '' : nextAttrValue;\n\t\t\t} else {\n\t\t\t\tif (booleanProps[attrName]) {\n\t\t\t\t\tdom[attrName] = nextAttrValue ? true : false;\n\t\t\t\t} else {\n\t\t\t\t\tvar ns = namespaces[attrName];\n\t\n\t\t\t\t\tif (nextAttrValue === false || isNullOrUndefined(nextAttrValue)) {\n\t\t\t\t\t\tif (ns !== undefined) {\n\t\t\t\t\t\t\tdom.removeAttributeNS(ns, attrName);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdom.removeAttribute(attrName);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ns !== undefined) {\n\t\t\t\t\t\t\tdom.setAttributeNS(ns, attrName, nextAttrValue === true ? attrName : nextAttrValue);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdom.setAttribute(attrName, nextAttrValue === true ? attrName : nextAttrValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchComponent(hasBlueprint, lastNode, Component, lastBp, nextBp, instance, lastProps, nextProps, nextHooks, lastChildren, nextChildren, parentDom, lifecycle, context) {\n\t\t\tnextProps = addChildrenToProps(nextChildren, nextProps);\n\t\n\t\t\tif (isStatefulComponent(Component)) {\n\t\t\t\tvar prevProps = instance.props;\n\t\t\t\tvar prevState = instance.state;\n\t\t\t\tvar nextState = instance.state;\n\t\n\t\t\t\tvar childContext = instance.getChildContext();\n\t\t\t\tif (!isNullOrUndefined(childContext)) {\n\t\t\t\t\tcontext = Object.assign({}, context, childContext);\n\t\t\t\t}\n\t\t\t\tinstance.context = context;\n\t\t\t\tvar nextNode = instance._updateComponent(prevState, nextState, prevProps, nextProps);\n\t\n\t\t\t\tif (nextNode === NO_RENDER) {\n\t\t\t\t\tnextNode = instance._lastNode;\n\t\t\t\t} else if (isNullOrUndefined(nextNode)) {\n\t\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t\t}\n\t\t\t\tpatch(instance._lastNode, nextNode, parentDom, lifecycle, context, instance, null, false);\n\t\t\t\tlastNode.dom = nextNode.dom;\n\t\t\t\tinstance._lastNode = nextNode;\n\t\t\t\tinstance.componentDidUpdate(prevProps, prevState);\n\t\t\t\tcomponentToDOMNodeMap.set(instance, nextNode.dom);\n\t\t\t} else {\n\t\t\t\tvar shouldUpdate = true;\n\t\t\t\tvar nextHooksDefined = hasBlueprint && nextBp.hasHooks === true || !isNullOrUndefined(nextHooks);\n\t\n\t\t\t\tlastProps = addChildrenToProps(lastChildren, lastProps);\n\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.componentShouldUpdate)) {\n\t\t\t\t\tshouldUpdate = nextHooks.componentShouldUpdate(lastNode.dom, lastProps, nextProps);\n\t\t\t\t}\n\t\t\t\tif (shouldUpdate !== false) {\n\t\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.componentWillUpdate)) {\n\t\t\t\t\t\tnextHooks.componentWillUpdate(lastNode.dom, lastProps, nextProps);\n\t\t\t\t\t}\n\t\t\t\t\tvar nextNode$1 = Component(nextProps, context);\n\t\n\t\t\t\t\tif (isInvalidNode(nextNode$1)) {\n\t\t\t\t\t\tnextNode$1 = createVPlaceholder();\n\t\t\t\t\t}\n\t\t\t\t\tnextNode$1.dom = lastNode.dom;\n\t\t\t\t\tpatch(instance, nextNode$1, parentDom, lifecycle, context, null, null, false);\n\t\t\t\t\tlastNode.instance = nextNode$1;\n\t\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.componentDidUpdate)) {\n\t\t\t\t\t\tnextHooks.componentDidUpdate(lastNode.dom, lastProps, nextProps);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchVList(lastVList, nextVList, parentDom, lifecycle, context, instance, isSVG) {\n\t\t\tvar lastItems = lastVList.items;\n\t\t\tvar nextItems = nextVList.items;\n\t\t\tvar pointer = lastVList.pointer;\n\t\n\t\t\tnextVList.dom = lastVList.dom;\n\t\t\tnextVList.pointer = pointer;\n\t\t\tif (!lastItems !== nextItems) {\n\t\t\t\tif (isKeyed(lastItems, nextItems)) {\n\t\t\t\t\tpatchKeyedChildren(lastItems, nextItems, parentDom, lifecycle, context, instance, isSVG, nextVList);\n\t\t\t\t} else {\n\t\t\t\t\tpatchNonKeyedChildren(lastItems, nextItems, parentDom, lifecycle, context, instance, isSVG, nextVList);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, parentVList) {\n\t\t\tvar lastChildrenLength = lastChildren.length;\n\t\t\tvar nextChildrenLength = nextChildren.length;\n\t\t\tvar commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n\t\t\tvar i = 0;\n\t\n\t\t\tfor (; i < commonLength; i++) {\n\t\t\t\tvar lastChild = lastChildren[i];\n\t\t\t\tvar nextChild = normaliseChild(nextChildren, i);\n\t\n\t\t\t\tpatch(lastChild, nextChild, dom, lifecycle, context, instance, isSVG);\n\t\t\t}\n\t\t\tif (lastChildrenLength < nextChildrenLength) {\n\t\t\t\tfor (i = commonLength; i < nextChildrenLength; i++) {\n\t\t\t\t\tvar child = normaliseChild(nextChildren, i);\n\t\n\t\t\t\t\tinsertOrAppend(dom, mount(child, null, lifecycle, context, instance, isSVG), parentVList && parentVList.pointer);\n\t\t\t\t}\n\t\t\t} else if (lastChildrenLength > nextChildrenLength) {\n\t\t\t\tfor (i = commonLength; i < lastChildrenLength; i++) {\n\t\t\t\t\tremove(lastChildren[i], dom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchVFragment(lastVFragment, nextVFragment) {\n\t\t\tnextVFragment.dom = lastVFragment.dom;\n\t\t}\n\t\n\t\tfunction patchVText(lastVText, nextVText) {\n\t\t\tvar nextText = nextVText.text;\n\t\t\tvar dom = lastVText.dom;\n\t\n\t\t\tnextVText.dom = dom;\n\t\t\tif (lastVText.text !== nextText) {\n\t\t\t\tdom.nodeValue = nextText;\n\t\t\t}\n\t\t}\n\t\n\t\tfunction patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, parentVList) {\n\t\t\tvar lastChildrenLength = lastChildren.length;\n\t\t\tvar nextChildrenLength = nextChildren.length;\n\t\t\tvar lastEndIndex = lastChildrenLength - 1;\n\t\t\tvar nextEndIndex = nextChildrenLength - 1;\n\t\t\tvar lastStartIndex = 0;\n\t\t\tvar nextStartIndex = 0;\n\t\t\tvar lastStartNode = null;\n\t\t\tvar nextStartNode = null;\n\t\t\tvar nextEndNode = null;\n\t\t\tvar lastEndNode = null;\n\t\t\tvar nextNode;\n\t\n\t\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\t\tnextStartNode = nextChildren[nextStartIndex];\n\t\t\t\tlastStartNode = lastChildren[lastStartIndex];\n\t\n\t\t\t\tif (nextStartNode.key !== lastStartNode.key) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpatchVNode(lastStartNode, nextStartNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\tnextStartIndex++;\n\t\t\t\tlastStartIndex++;\n\t\t\t}\n\t\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\t\tnextEndNode = nextChildren[nextEndIndex];\n\t\t\t\tlastEndNode = lastChildren[lastEndIndex];\n\t\n\t\t\t\tif (nextEndNode.key !== lastEndNode.key) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpatchVNode(lastEndNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\tnextEndIndex--;\n\t\t\t\tlastEndIndex--;\n\t\t\t}\n\t\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\t\tnextEndNode = nextChildren[nextEndIndex];\n\t\t\t\tlastStartNode = lastChildren[lastStartIndex];\n\t\n\t\t\t\tif (nextEndNode.key !== lastStartNode.key) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextNode = nextEndIndex + 1 < nextChildrenLength ? nextChildren[nextEndIndex + 1].dom : null;\n\t\t\t\tpatchVNode(lastStartNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\tinsertOrAppend(dom, nextEndNode.dom, nextNode);\n\t\t\t\tnextEndIndex--;\n\t\t\t\tlastStartIndex++;\n\t\t\t}\n\t\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\t\tnextStartNode = nextChildren[nextStartIndex];\n\t\t\t\tlastEndNode = lastChildren[lastEndIndex];\n\t\n\t\t\t\tif (nextStartNode.key !== lastEndNode.key) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextNode = lastChildren[lastStartIndex].dom;\n\t\t\t\tpatchVNode(lastEndNode, nextStartNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\tinsertOrAppend(dom, nextStartNode.dom, nextNode);\n\t\t\t\tnextStartIndex++;\n\t\t\t\tlastEndIndex--;\n\t\t\t}\n\t\n\t\t\tif (lastStartIndex > lastEndIndex) {\n\t\t\t\tif (nextStartIndex <= nextEndIndex) {\n\t\t\t\t\tnextNode = nextEndIndex + 1 < nextChildrenLength ? nextChildren[nextEndIndex + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\tfor (; nextStartIndex <= nextEndIndex; nextStartIndex++) {\n\t\t\t\t\t\tinsertOrAppend(dom, mount(nextChildren[nextStartIndex], null, lifecycle, context, instance, isSVG), nextNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (nextStartIndex > nextEndIndex) {\n\t\t\t\twhile (lastStartIndex <= lastEndIndex) {\n\t\t\t\t\tremove(lastChildren[lastStartIndex++], dom);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar aLength = lastEndIndex - lastStartIndex + 1;\n\t\t\t\tvar bLength = nextEndIndex - nextStartIndex + 1;\n\t\t\t\tvar sources = new Array(bLength);\n\t\n\t\t\t\t// Mark all nodes as inserted.\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < bLength; i++) {\n\t\t\t\t\tsources[i] = -1;\n\t\t\t\t}\n\t\t\t\tvar moved = false;\n\t\t\t\tvar removeOffset = 0;\n\t\t\t\tvar lastTarget = 0;\n\t\t\t\tvar index;\n\t\t\t\tvar removed = true;\n\t\t\t\tvar k = 0;\n\t\n\t\t\t\tif (bLength <= 4 || aLength * bLength <= 16) {\n\t\t\t\t\tfor (i = lastStartIndex; i <= lastEndIndex; i++) {\n\t\t\t\t\t\tremoved = true;\n\t\t\t\t\t\tlastEndNode = lastChildren[i];\n\t\t\t\t\t\tif (k < bLength) {\n\t\t\t\t\t\t\tfor (index = nextStartIndex; index <= nextEndIndex; index++) {\n\t\t\t\t\t\t\t\tnextEndNode = nextChildren[index];\n\t\t\t\t\t\t\t\tif (lastEndNode.key === nextEndNode.key) {\n\t\t\t\t\t\t\t\t\tsources[index - nextStartIndex] = i;\n\t\n\t\t\t\t\t\t\t\t\tif (lastTarget > index) {\n\t\t\t\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlastTarget = index;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tpatchVNode(lastEndNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\t\tremoved = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tremove(lastEndNode, dom);\n\t\t\t\t\t\t\tremoveOffset++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar prevItemsMap = new Map();\n\t\n\t\t\t\t\tfor (i = nextStartIndex; i <= nextEndIndex; i++) {\n\t\t\t\t\t\tprevItemsMap.set(nextChildren[i].key, i);\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = lastStartIndex; i <= lastEndIndex; i++) {\n\t\t\t\t\t\tremoved = true;\n\t\t\t\t\t\tlastEndNode = lastChildren[i];\n\t\n\t\t\t\t\t\tif (k < nextChildrenLength) {\n\t\t\t\t\t\t\tindex = prevItemsMap.get(lastEndNode.key);\n\t\n\t\t\t\t\t\t\tif (index !== undefined) {\n\t\t\t\t\t\t\t\tnextEndNode = nextChildren[index];\n\t\t\t\t\t\t\t\tsources[index - nextStartIndex] = i;\n\t\t\t\t\t\t\t\tif (lastTarget > index) {\n\t\t\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlastTarget = index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpatchVNode(lastEndNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\tremoved = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (removed) {\n\t\t\t\t\t\t\tremove(lastEndNode, dom);\n\t\t\t\t\t\t\tremoveOffset++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar pos;\n\t\t\t\tif (moved) {\n\t\t\t\t\tvar seq = lis_algorithm(sources);\n\t\t\t\t\tindex = seq.length - 1;\n\t\t\t\t\tfor (i = bLength - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (sources[i] === -1) {\n\t\t\t\t\t\t\tpos = i + nextStartIndex;\n\t\t\t\t\t\t\tnextNode = pos + 1 < nextChildrenLength ? nextChildren[pos + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\t\t\tinsertOrAppend(dom, mount(nextChildren[pos], null, lifecycle, context, instance, isSVG), nextNode);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (index < 0 || i !== seq[index]) {\n\t\t\t\t\t\t\t\tpos = i + nextStartIndex;\n\t\t\t\t\t\t\t\tnextNode = pos + 1 < nextChildrenLength ? nextChildren[pos + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\t\t\t\tinsertOrAppend(dom, nextChildren[pos].dom, nextNode);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (aLength - removeOffset !== bLength) {\n\t\t\t\t\tfor (i = bLength - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (sources[i] === -1) {\n\t\t\t\t\t\t\tpos = i + nextStartIndex;\n\t\t\t\t\t\t\tnextNode = pos + 1 < nextChildrenLength ? nextChildren[pos + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\t\t\tinsertOrAppend(dom, mount(nextChildren[pos], null, lifecycle, context, instance, isSVG), nextNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n\t\tfunction lis_algorithm(a) {\n\t\t\tvar p = a.slice(0);\n\t\t\tvar result = [];\n\t\t\tresult.push(0);\n\t\t\tvar i;\n\t\t\tvar j;\n\t\t\tvar u;\n\t\t\tvar v;\n\t\t\tvar c;\n\t\n\t\t\tfor (i = 0; i < a.length; i++) {\n\t\t\t\tif (a[i] === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tj = result[result.length - 1];\n\t\t\t\tif (a[j] < a[i]) {\n\t\t\t\t\tp[i] = j;\n\t\t\t\t\tresult.push(i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tu = 0;\n\t\t\t\tv = result.length - 1;\n\t\n\t\t\t\twhile (u < v) {\n\t\t\t\t\tc = (u + v) / 2 | 0;\n\t\t\t\t\tif (a[result[c]] < a[i]) {\n\t\t\t\t\t\tu = c + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (a[i] < a[result[u]]) {\n\t\t\t\t\tif (u > 0) {\n\t\t\t\t\t\tp[i] = result[u - 1];\n\t\t\t\t\t}\n\t\t\t\t\tresult[u] = i;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tu = result.length;\n\t\t\tv = result[u - 1];\n\t\n\t\t\twhile (u-- > 0) {\n\t\t\t\tresult[u] = v;\n\t\t\t\tv = p[v];\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\t}\n\t\n\t\tvar screenWidth = isBrowser && window.screen.width;\n\t\tvar screenHeight = isBrowser && window.screen.height;\n\t\tvar scrollX = 0;\n\t\tvar scrollY = 0;\n\t\tvar lastScrollTime = 0;\n\t\n\t\tif (isBrowser) {\n\t\t\twindow.onscroll = function () {\n\t\t\t\tscrollX = window.scrollX;\n\t\t\t\tscrollY = window.scrollY;\n\t\t\t\tlastScrollTime = performance.now();\n\t\t\t};\n\t\n\t\t\twindow.resize = function () {\n\t\t\t\tscrollX = window.scrollX;\n\t\t\t\tscrollY = window.scrollY;\n\t\t\t\tscreenWidth = window.screen.width;\n\t\t\t\tscreenHeight = window.screen.height;\n\t\t\t\tlastScrollTime = performance.now();\n\t\t\t};\n\t\t}\n\t\n\t\tfunction Lifecycle() {\n\t\t\tthis._listeners = [];\n\t\t\tthis.scrollX = null;\n\t\t\tthis.scrollY = null;\n\t\t\tthis.screenHeight = screenHeight;\n\t\t\tthis.screenWidth = screenWidth;\n\t\t}\n\t\n\t\tLifecycle.prototype = {\n\t\t\trefresh: function refresh() {\n\t\t\t\tthis.scrollX = isBrowser && window.scrollX;\n\t\t\t\tthis.scrollY = isBrowser && window.scrollY;\n\t\t\t},\n\t\t\taddListener: function addListener(callback) {\n\t\t\t\tthis._listeners.push(callback);\n\t\t\t},\n\t\t\ttrigger: function trigger() {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tfor (var i = 0; i < this._listeners.length; i++) {\n\t\t\t\t\tthis$1._listeners[i]();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tfunction handleLazyAttached(node, lifecycle, dom) {\n\t\t\tlifecycle.addListener(function () {\n\t\t\t\tvar rect = dom.getBoundingClientRect();\n\t\n\t\t\t\tif (lifecycle.scrollY === null) {\n\t\t\t\t\tlifecycle.refresh();\n\t\t\t\t}\n\t\t\t\tnode.clipData = {\n\t\t\t\t\ttop: rect.top + lifecycle.scrollY,\n\t\t\t\t\tleft: rect.left + lifecycle.scrollX,\n\t\t\t\t\tbottom: rect.bottom + lifecycle.scrollY,\n\t\t\t\t\tright: rect.right + lifecycle.scrollX,\n\t\t\t\t\tpending: false\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\n\t\tfunction hydrateChild(child, childNodes, counter, parentDom, lifecycle, context, instance) {\n\t\t\tvar domNode = childNodes[counter.i];\n\t\n\t\t\tif (isVText(child)) {\n\t\t\t\tvar text = child.text;\n\t\n\t\t\t\tchild.dom = domNode;\n\t\t\t\tif (domNode.nodeType === 3 && text !== '') {\n\t\t\t\t\tdomNode.nodeValue = text;\n\t\t\t\t} else {\n\t\t\t\t\tvar newDomNode = mountVText(text);\n\t\n\t\t\t\t\treplaceNode(parentDom, newDomNode, domNode);\n\t\t\t\t\tchildNodes.splice(childNodes.indexOf(domNode), 1, newDomNode);\n\t\t\t\t\tchild.dom = newDomNode;\n\t\t\t\t}\n\t\t\t} else if (isVPlaceholder(child)) {\n\t\t\t\tchild.dom = domNode;\n\t\t\t} else if (isVList(child)) {\n\t\t\t\tvar items = child.items;\n\t\n\t\t\t\t// this doesn't really matter, as it won't be used again, but it's what it should be given the purpose of VList\n\t\t\t\tchild.dom = document.createDocumentFragment();\n\t\t\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\t\t\tvar rebuild = hydrateChild(normaliseChild(items, i), childNodes, counter, parentDom, lifecycle, context, instance);\n\t\n\t\t\t\t\tif (rebuild) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// at the end of every VList, there should be a \"pointer\". It's an empty TextNode used for tracking the VList\n\t\t\t\tvar pointer = childNodes[counter.i++];\n\t\n\t\t\t\tif (pointer && pointer.nodeType === 3) {\n\t\t\t\t\tchild.pointer = pointer;\n\t\t\t\t} else {\n\t\t\t\t\t// there is a problem, we need to rebuild this tree\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar rebuild$1 = hydrateNode(child, domNode, parentDom, lifecycle, context, instance, false);\n\t\n\t\t\t\tif (rebuild$1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcounter.i++;\n\t\t}\n\t\n\t\tfunction getChildNodesWithoutComments(domNode) {\n\t\t\tvar childNodes = [];\n\t\t\tvar rawChildNodes = domNode.childNodes;\n\t\t\tvar length = rawChildNodes.length;\n\t\t\tvar i = 0;\n\t\n\t\t\twhile (i < length) {\n\t\t\t\tvar rawChild = rawChildNodes[i];\n\t\n\t\t\t\tif (rawChild.nodeType === 8) {\n\t\t\t\t\tif (rawChild.data === '!') {\n\t\t\t\t\t\tvar placeholder = document.createTextNode('');\n\t\n\t\t\t\t\t\tdomNode.replaceChild(placeholder, rawChild);\n\t\t\t\t\t\tchildNodes.push(placeholder);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdomNode.removeChild(rawChild);\n\t\t\t\t\t\tlength--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchildNodes.push(rawChild);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn childNodes;\n\t\t}\n\t\n\t\tfunction hydrateComponent(node, Component, props, hooks, children, domNode, parentDom, lifecycle, context, lastInstance, isRoot) {\n\t\t\tprops = addChildrenToProps(children, props);\n\t\n\t\t\tif (isStatefulComponent(Component)) {\n\t\t\t\tvar instance = node.instance = new Component(props);\n\t\n\t\t\t\tinstance._patch = patch;\n\t\t\t\tif (!isNullOrUndefined(lastInstance) && props.ref) {\n\t\t\t\t\tmountRef(lastInstance, props.ref, instance);\n\t\t\t\t}\n\t\t\t\tvar childContext = instance.getChildContext();\n\t\n\t\t\t\tif (!isNullOrUndefined(childContext)) {\n\t\t\t\t\tcontext = Object.assign({}, context, childContext);\n\t\t\t\t}\n\t\t\t\tinstance.context = context;\n\t\t\t\tinstance._unmounted = false;\n\t\t\t\tinstance._parentNode = node;\n\t\t\t\tif (lastInstance) {\n\t\t\t\t\tinstance._parentComponent = lastInstance;\n\t\t\t\t}\n\t\t\t\tinstance._pendingSetState = true;\n\t\t\t\tinstance.componentWillMount();\n\t\t\t\tvar nextNode = instance.render();\n\t\n\t\t\t\tinstance._pendingSetState = false;\n\t\t\t\tif (isInvalidNode(nextNode)) {\n\t\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t\t}\n\t\t\t\thydrateNode(nextNode, domNode, parentDom, lifecycle, context, instance, isRoot);\n\t\t\t\tinstance._lastNode = nextNode;\n\t\t\t\tinstance.componentDidMount();\n\t\t\t} else {\n\t\t\t\tvar instance$1 = node.instance = Component(props);\n\t\n\t\t\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\t\t\tif (!isNullOrUndefined(hooks.componentWillMount)) {\n\t\t\t\t\t\thooks.componentWillMount(null, props);\n\t\t\t\t\t}\n\t\t\t\t\tif (!isNullOrUndefined(hooks.componentDidMount)) {\n\t\t\t\t\t\tlifecycle.addListener(function () {\n\t\t\t\t\t\t\thooks.componentDidMount(domNode, props);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn hydrateNode(instance$1, domNode, parentDom, lifecycle, context, instance$1, isRoot);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction hydrateNode(node, domNode, parentDom, lifecycle, context, instance, isRoot) {\n\t\t\tvar bp = node.bp;\n\t\t\tvar tag = node.tag || bp.tag;\n\t\n\t\t\tif (isFunction(tag)) {\n\t\t\t\tnode.dom = domNode;\n\t\t\t\thydrateComponent(node, tag, node.attrs || {}, node.hooks, node.children, domNode, parentDom, lifecycle, context, instance, isRoot);\n\t\t\t} else {\n\t\t\t\tif (domNode.nodeType !== 1 || tag !== domNode.tagName.toLowerCase()) {\n\t\t\t\t\t// TODO remake node\n\t\t\t\t} else {\n\t\t\t\t\tnode.dom = domNode;\n\t\t\t\t\tvar hooks = node.hooks;\n\t\n\t\t\t\t\tif (bp && bp.hasHooks === true || !isNullOrUndefined(hooks)) {\n\t\t\t\t\t\thandleAttachedHooks(hooks, lifecycle, domNode);\n\t\t\t\t\t}\n\t\t\t\t\tvar children = node.children;\n\t\n\t\t\t\t\tif (!isNullOrUndefined(children)) {\n\t\t\t\t\t\tif (isStringOrNumber(children)) {\n\t\t\t\t\t\t\tif (domNode.textContent !== children) {\n\t\t\t\t\t\t\t\tdomNode.textContent = children;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar childNodes = getChildNodesWithoutComments(domNode);\n\t\t\t\t\t\t\tvar counter = { i: 0 };\n\t\t\t\t\t\t\tvar rebuild = false;\n\t\n\t\t\t\t\t\t\tif (isArray(children)) {\n\t\t\t\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\t\t\t\trebuild = hydrateChild(normaliseChild(children, i), childNodes, counter, domNode, lifecycle, context, instance);\n\t\n\t\t\t\t\t\t\t\t\tif (rebuild) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (childNodes.length === 1) {\n\t\t\t\t\t\t\t\t\trebuild = hydrateChild(children, childNodes, counter, domNode, lifecycle, context, instance);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\trebuild = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (rebuild) {\n\t\t\t\t\t\t\t\t// TODO scrap children and rebuild again\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar className = node.className;\n\t\t\t\t\tvar style = node.style;\n\t\n\t\t\t\t\tif (!isNullOrUndefined(className)) {\n\t\t\t\t\t\tdomNode.className = className;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isNullOrUndefined(style)) {\n\t\t\t\t\t\tpatchStyle(null, style, domNode);\n\t\t\t\t\t}\n\t\t\t\t\tif (bp && bp.hasAttrs === true) {\n\t\t\t\t\t\tmountBlueprintAttrs(node, bp, domNode, instance);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar attrs = node.attrs;\n\t\n\t\t\t\t\t\tif (!isNullOrUndefined(attrs)) {\n\t\t\t\t\t\t\thandleSelects(node);\n\t\t\t\t\t\t\tmountAttributes(node, attrs, Object.keys(attrs), domNode, instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (bp && bp.hasEvents === true) {\n\t\t\t\t\t\tmountBlueprintEvents(node, bp, domNode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar events = node.events;\n\t\n\t\t\t\t\t\tif (!isNullOrUndefined(events)) {\n\t\t\t\t\t\t\tmountEvents(events, Object.keys(events), domNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar documetBody = isBrowser ? document.body : null;\n\t\n\t\tfunction hydrate(node, parentDom, lifecycle) {\n\t\t\tif (parentDom && parentDom.nodeType === 1) {\n\t\t\t\tvar rootNode = parentDom.querySelector('[data-infernoroot]');\n\t\n\t\t\t\tif (rootNode && rootNode.parentNode === parentDom) {\n\t\t\t\t\thydrateNode(node, rootNode, parentDom, lifecycle, {}, true);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// clear parentDom, unless it's document.body\n\t\t\tif (parentDom !== documetBody) {\n\t\t\t\tparentDom.textContent = '';\n\t\t\t} else {\n\t\t\t\tconsole.warn('Inferno Warning: rendering to the \"document.body\" is dangerous! Use a dedicated container element instead.');\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar roots = new Map();\n\t\tvar componentToDOMNodeMap = new Map();\n\t\n\t\tfunction findDOMNode(domNode) {\n\t\t\treturn componentToDOMNodeMap.get(domNode) || null;\n\t\t}\n\t\n\t\tfunction render(input, parentDom) {\n\t\t\tvar root = roots.get(parentDom);\n\t\t\tvar lifecycle = new Lifecycle();\n\t\n\t\t\tif (isUndefined(root)) {\n\t\t\t\tif (!isInvalidNode(input)) {\n\t\t\t\t\tif (!hydrate(input, parentDom, lifecycle)) {\n\t\t\t\t\t\tmount(input, parentDom, lifecycle, {}, null, false);\n\t\t\t\t\t}\n\t\t\t\t\tlifecycle.trigger();\n\t\t\t\t\troots.set(parentDom, { input: input });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar activeNode = getActiveNode();\n\t\t\t\tvar nextInput = patch(root.input, input, parentDom, lifecycle, {}, null, false);\n\t\n\t\t\t\tlifecycle.trigger();\n\t\t\t\tif (isNull(input)) {\n\t\t\t\t\troots.delete(parentDom);\n\t\t\t\t}\n\t\t\t\troot.input = nextInput;\n\t\t\t\tresetActiveNode(activeNode);\n\t\t\t}\n\t\t}\n\t\n\t\tvar index = {\n\t\t\trender: render,\n\t\t\tfindDOMNode: findDOMNode,\n\t\t\tmount: mount,\n\t\t\tpatch: patch,\n\t\t\tunmount: unmount\n\t\t};\n\t\n\t\treturn index;\n\t});\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(14);\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t/*!\n\t * inferno-create-class v0.7.25\n\t * (c) 2016 Dominic Gannaway\n\t * Released under the MIT License.\n\t */\n\t(function (global, factory) {\n\t\t( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.InfernoCreateClass = factory();\n\t})(undefined, function () {\n\t\t'use strict';\n\t\n\t\tvar NO_RENDER = 'NO_RENDER';\n\t\n\t\t// Runs only once in applications lifetime\n\t\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\t\n\t\tfunction isNullOrUndefined(obj) {\n\t\t\treturn isUndefined(obj) || isNull(obj);\n\t\t}\n\t\n\t\tfunction isNull(obj) {\n\t\t\treturn obj === null;\n\t\t}\n\t\n\t\tfunction isUndefined(obj) {\n\t\t\treturn obj === undefined;\n\t\t}\n\t\n\t\tfunction VPlaceholder() {\n\t\t\tthis.placeholder = true;\n\t\t\tthis.dom = null;\n\t\t}\n\t\n\t\tfunction createVPlaceholder() {\n\t\t\treturn new VPlaceholder();\n\t\t}\n\t\n\t\tvar documetBody = isBrowser ? document.body : null;\n\t\n\t\tfunction constructDefaults(string, object, value) {\n\t\t\t/* eslint no-return-assign: 0 */\n\t\t\tstring.split(',').forEach(function (i) {\n\t\t\t\treturn object[i] = value;\n\t\t\t});\n\t\t}\n\t\n\t\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\t\tvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\n\t\tvar strictProps = {};\n\t\tvar booleanProps = {};\n\t\tvar namespaces = {};\n\t\tvar isUnitlessNumber = {};\n\t\n\t\tconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\n\t\tconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\n\t\tconstructDefaults('volume,value', strictProps, true);\n\t\tconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,selected,readonly,multiple,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\n\t\tconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\t\n\t\tvar screenWidth = isBrowser && window.screen.width;\n\t\tvar screenHeight = isBrowser && window.screen.height;\n\t\tvar scrollX = 0;\n\t\tvar scrollY = 0;\n\t\tvar lastScrollTime = 0;\n\t\n\t\tif (isBrowser) {\n\t\t\twindow.onscroll = function () {\n\t\t\t\tscrollX = window.scrollX;\n\t\t\t\tscrollY = window.scrollY;\n\t\t\t\tlastScrollTime = performance.now();\n\t\t\t};\n\t\n\t\t\twindow.resize = function () {\n\t\t\t\tscrollX = window.scrollX;\n\t\t\t\tscrollY = window.scrollY;\n\t\t\t\tscreenWidth = window.screen.width;\n\t\t\t\tscreenHeight = window.screen.height;\n\t\t\t\tlastScrollTime = performance.now();\n\t\t\t};\n\t\t}\n\t\n\t\tfunction Lifecycle() {\n\t\t\tthis._listeners = [];\n\t\t\tthis.scrollX = null;\n\t\t\tthis.scrollY = null;\n\t\t\tthis.screenHeight = screenHeight;\n\t\t\tthis.screenWidth = screenWidth;\n\t\t}\n\t\n\t\tLifecycle.prototype = {\n\t\t\trefresh: function refresh() {\n\t\t\t\tthis.scrollX = isBrowser && window.scrollX;\n\t\t\t\tthis.scrollY = isBrowser && window.scrollY;\n\t\t\t},\n\t\t\taddListener: function addListener(callback) {\n\t\t\t\tthis._listeners.push(callback);\n\t\t\t},\n\t\t\ttrigger: function trigger() {\n\t\t\t\tvar this$1 = this;\n\t\n\t\t\t\tfor (var i = 0; i < this._listeners.length; i++) {\n\t\t\t\t\tthis$1._listeners[i]();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tvar noOp = 'Inferno Error: Can only update a mounted or mounting component. This usually means you called setState() or forceUpdate() on an unmounted component. This is a no-op.';\n\t\n\t\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\t\tfunction getActiveNode() {\n\t\t\treturn document.activeElement;\n\t\t}\n\t\n\t\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\t\tfunction resetActiveNode(activeNode) {\n\t\t\tif (activeNode !== document.body && document.activeElement !== activeNode) {\n\t\t\t\tactiveNode.focus(); // TODO: verify are we doing new focus event, if user has focus listener this might trigger it\n\t\t\t}\n\t\t}\n\t\n\t\tfunction queueStateChanges(component, newState, callback) {\n\t\t\tfor (var stateKey in newState) {\n\t\t\t\tcomponent._pendingState[stateKey] = newState[stateKey];\n\t\t\t}\n\t\t\tif (!component._pendingSetState) {\n\t\t\t\tcomponent._pendingSetState = true;\n\t\t\t\tapplyState(component, false, callback);\n\t\t\t} else {\n\t\t\t\tcomponent.state = Object.assign({}, component.state, component._pendingState);\n\t\t\t\tcomponent._pendingState = {};\n\t\t\t}\n\t\t}\n\t\n\t\tfunction applyState(component, force, callback) {\n\t\t\tif ((!component._deferSetState || force) && !component._blockRender) {\n\t\t\t\tcomponent._pendingSetState = false;\n\t\t\t\tvar pendingState = component._pendingState;\n\t\t\t\tvar prevState = component.state;\n\t\t\t\tvar nextState = Object.assign({}, prevState, pendingState);\n\t\t\t\tvar props = component.props;\n\t\n\t\t\t\tcomponent._pendingState = {};\n\t\t\t\tvar nextNode = component._updateComponent(prevState, nextState, props, props, force);\n\t\n\t\t\t\tif (nextNode === NO_RENDER) {\n\t\t\t\t\tnextNode = component._lastNode;\n\t\t\t\t} else if (isNullOrUndefined(nextNode)) {\n\t\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t\t}\n\t\t\t\tvar lastNode = component._lastNode;\n\t\t\t\tvar parentDom = lastNode.dom.parentNode;\n\t\t\t\tvar activeNode = getActiveNode();\n\t\t\t\tvar subLifecycle = new Lifecycle();\n\t\n\t\t\t\tcomponent._patch(lastNode, nextNode, parentDom, subLifecycle, component.context, component, null);\n\t\t\t\tcomponent._lastNode = nextNode;\n\t\t\t\tcomponent._componentToDOMNodeMap.set(component, nextNode.dom);\n\t\t\t\tcomponent._parentNode.dom = nextNode.dom;\n\t\t\t\tcomponent.componentDidUpdate(props, prevState);\n\t\t\t\tsubLifecycle.trigger();\n\t\t\t\tif (!isNullOrUndefined(callback)) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t\tresetActiveNode(activeNode);\n\t\t\t}\n\t\t}\n\t\n\t\tvar Component = function Component(props, context) {\n\t\t\tif (context === void 0) context = {};\n\t\n\t\t\t/** @type {object} */\n\t\t\tthis.props = props || {};\n\t\n\t\t\t/** @type {object} */\n\t\t\tthis.state = {};\n\t\n\t\t\t/** @type {object} */\n\t\t\tthis.refs = {};\n\t\t\tthis._blockRender = false;\n\t\t\tthis._blockSetState = false;\n\t\t\tthis._deferSetState = false;\n\t\t\tthis._pendingSetState = false;\n\t\t\tthis._pendingState = {};\n\t\t\tthis._parentNode = null;\n\t\t\tthis._lastNode = null;\n\t\t\tthis._unmounted = true;\n\t\t\tthis.context = context;\n\t\t\tthis._patch = null;\n\t\t\tthis._parentComponent = null;\n\t\t\tthis._componentToDOMNodeMap = null;\n\t\t};\n\t\n\t\tComponent.prototype.render = function render() {};\n\t\n\t\tComponent.prototype.forceUpdate = function forceUpdate(callback) {\n\t\t\tif (this._unmounted) {\n\t\t\t\tthrow Error(noOp);\n\t\t\t}\n\t\t\tapplyState(this, true, callback);\n\t\t};\n\t\n\t\tComponent.prototype.setState = function setState(newState, callback) {\n\t\t\tif (this._unmounted) {\n\t\t\t\tthrow Error(noOp);\n\t\t\t}\n\t\t\tif (this._blockSetState === false) {\n\t\t\t\tqueueStateChanges(this, newState, callback);\n\t\t\t} else {\n\t\t\t\tthrow Error('Inferno Warning: Cannot update state via setState() in componentWillUpdate()');\n\t\t\t}\n\t\t};\n\t\n\t\tComponent.prototype.componentDidMount = function componentDidMount() {};\n\t\n\t\tComponent.prototype.componentWillMount = function componentWillMount() {};\n\t\n\t\tComponent.prototype.componentWillUnmount = function componentWillUnmount() {};\n\t\n\t\tComponent.prototype.componentDidUpdate = function componentDidUpdate() {};\n\t\n\t\tComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate() {\n\t\t\treturn true;\n\t\t};\n\t\n\t\tComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps() {};\n\t\n\t\tComponent.prototype.componentWillUpdate = function componentWillUpdate() {};\n\t\n\t\tComponent.prototype.getChildContext = function getChildContext() {};\n\t\n\t\tComponent.prototype._updateComponent = function _updateComponent(prevState, nextState, prevProps, nextProps, force) {\n\t\t\tif (this._unmounted === true) {\n\t\t\t\tthis._unmounted = false;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!isNullOrUndefined(nextProps) && isNullOrUndefined(nextProps.children)) {\n\t\t\t\tnextProps.children = prevProps.children;\n\t\t\t}\n\t\t\tif (prevProps !== nextProps || prevState !== nextState || force) {\n\t\t\t\tif (prevProps !== nextProps) {\n\t\t\t\t\tthis._blockRender = true;\n\t\t\t\t\tthis.componentWillReceiveProps(nextProps);\n\t\t\t\t\tthis._blockRender = false;\n\t\t\t\t\tif (this._pendingSetState) {\n\t\t\t\t\t\tnextState = Object.assign({}, nextState, this._pendingState);\n\t\t\t\t\t\tthis._pendingSetState = false;\n\t\t\t\t\t\tthis._pendingState = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar shouldUpdate = this.shouldComponentUpdate(nextProps, nextState);\n\t\n\t\t\t\tif (shouldUpdate !== false || force) {\n\t\t\t\t\tthis._blockSetState = true;\n\t\t\t\t\tthis.componentWillUpdate(nextProps, nextState);\n\t\t\t\t\tthis._blockSetState = false;\n\t\t\t\t\tthis.props = nextProps;\n\t\t\t\t\tthis.state = nextState;\n\t\t\t\t\treturn this.render();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn NO_RENDER;\n\t\t};\n\t\n\t\t// don't autobind these methods since they already have guaranteed context.\n\t\tvar AUTOBIND_BLACKLIST = {\n\t\t\tconstructor: 1,\n\t\t\trender: 1,\n\t\t\tshouldComponentUpdate: 1,\n\t\t\tcomponentWillRecieveProps: 1,\n\t\t\tcomponentWillUpdate: 1,\n\t\t\tcomponentDidUpdate: 1,\n\t\t\tcomponentWillMount: 1,\n\t\t\tcomponentDidMount: 1,\n\t\t\tcomponentWillUnmount: 1,\n\t\t\tcomponentDidUnmount: 1\n\t\t};\n\t\n\t\tfunction F() {}\n\t\n\t\tfunction extend(base, props, all) {\n\t\t\tfor (var key in props) {\n\t\t\t\tif (all === true || !isNullOrUndefined(props[key])) {\n\t\t\t\t\tbase[key] = props[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn base;\n\t\t}\n\t\n\t\tfunction bindAll(ctx) {\n\t\t\tfor (var i in ctx) {\n\t\t\t\tvar v = ctx[i];\n\t\t\t\tif (typeof v === 'function' && !v.__bound && !AUTOBIND_BLACKLIST.hasOwnProperty(i)) {\n\t\t\t\t\t(ctx[i] = v.bind(ctx)).__bound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction createClass(obj) {\n\t\t\tfunction Cl(props) {\n\t\t\t\textend(this, obj);\n\t\t\t\tComponent.call(this, props);\n\t\t\t\tbindAll(this);\n\t\t\t\tif (this.getInitialState) {\n\t\t\t\t\tthis.state = this.getInitialState();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tF.prototype = Component.prototype;\n\t\t\tCl.prototype = new F();\n\t\t\tCl.prototype.constructor = Cl;\n\t\t\tCl.displayName = obj.displayName || 'Component';\n\t\t\treturn Cl;\n\t\t}\n\t\n\t\treturn createClass;\n\t});\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** dist/bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c5877cff6679273a3361\n **/","\"use strict\";\nconst bar_1 = require('./components/bar');\nconst inferno_dom_1 = require('inferno-dom');\ninferno_dom_1.render(<bar_1.default />, document.body);\n//# sourceMappingURL=index.jsx.map\n\n\n/** WEBPACK FOOTER **\n ** ./bin/index.jsx\n **/","\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst component_1 = require('../common/component/component');\nconst mobx_inferno_1 = require('mobx-inferno');\nlet Bar = class Bar extends component_1.default {\n    constructor(props) {\n        super(props);\n    }\n    componentStyle() {\n        return {\n            background: 'green'\n        };\n    }\n    render() {\n        return (<div class={this.style}>\n        <div>\n          <div>PMENU</div>\n          <div>STRUCTURE</div>\n          <div>ADD</div>\n        </div>\n        <div open={this.props.children.length > 0}>{this.props.children}</div>\n      </div>);\n    }\n};\nBar = __decorate([\n    mobx_inferno_1.observer, \n    __metadata('design:paramtypes', [Object])\n], Bar);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Bar;\n//# sourceMappingURL=bar.jsx.map\n\n\n/** WEBPACK FOOTER **\n ** ./bin/components/bar.jsx\n **/","\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst inferno_component_1 = require('inferno-component');\nconst styler_1 = require('./styler');\nlet StyledComponent = class StyledComponent extends inferno_component_1.default {\n    constructor(props) {\n        super(props);\n    }\n    componentStyle() {\n        return {\n            background: 'red'\n        };\n    }\n    render() {\n        return <div class={this.style}></div>;\n    }\n};\nStyledComponent = __decorate([\n    styler_1.styled, \n    __metadata('design:paramtypes', [Object])\n], StyledComponent);\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = StyledComponent;\n//# sourceMappingURL=component.jsx.map\n\n\n/** WEBPACK FOOTER **\n ** ./bin/common/component/component.jsx\n **/","'use strict';\n\nmodule.exports = require('inferno/dist/inferno-component');\n\n\n/** WEBPACK FOOTER **\n ** ./~/inferno-component/inferno-component.js\n **/","/*!\n * inferno-component v0.7.25\n * (c) 2016 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.InfernoComponent = factory());\n}(this, function () { 'use strict';\n\n\tvar NO_RENDER = 'NO_RENDER';\n\n\t// Runs only once in applications lifetime\n\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\n\tfunction isNullOrUndefined(obj) {\n\t\treturn isUndefined(obj) || isNull(obj);\n\t}\n\n\tfunction isNull(obj) {\n\t\treturn obj === null;\n\t}\n\n\tfunction isUndefined(obj) {\n\t\treturn obj === undefined;\n\t}\n\n\tfunction VPlaceholder() {\n\t\tthis.placeholder = true;\n\t\tthis.dom = null;\n\t}\n\n\tfunction createVPlaceholder() {\n\t\treturn new VPlaceholder();\n\t}\n\n\tvar documetBody = isBrowser ? document.body : null;\n\n\tfunction constructDefaults(string, object, value) {\n\t\t/* eslint no-return-assign: 0 */\n\t\tstring.split(',').forEach(function (i) { return object[i] = value; });\n\t}\n\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\tvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\n\tvar strictProps = {};\n\tvar booleanProps = {};\n\tvar namespaces = {};\n\tvar isUnitlessNumber = {};\n\n\tconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\n\tconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\n\tconstructDefaults('volume,value', strictProps, true);\n\tconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,selected,readonly,multiple,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\n\tconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\n\tvar screenWidth = isBrowser && window.screen.width;\n\tvar screenHeight = isBrowser && window.screen.height;\n\tvar scrollX = 0;\n\tvar scrollY = 0;\n\tvar lastScrollTime = 0;\n\n\tif (isBrowser) {\n\t\twindow.onscroll = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\n\t\twindow.resize = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tscreenWidth = window.screen.width;\n\t\t\tscreenHeight = window.screen.height;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\t}\n\n\tfunction Lifecycle() {\n\t\tthis._listeners = [];\n\t\tthis.scrollX = null;\n\t\tthis.scrollY = null;\n\t\tthis.screenHeight = screenHeight;\n\t\tthis.screenWidth = screenWidth;\n\t}\n\n\tLifecycle.prototype = {\n\t\trefresh: function refresh() {\n\t\t\tthis.scrollX = isBrowser && window.scrollX;\n\t\t\tthis.scrollY = isBrowser && window.scrollY;\n\t\t},\n\t\taddListener: function addListener(callback) {\n\t\t\tthis._listeners.push(callback);\n\t\t},\n\t\ttrigger: function trigger() {\n\t\t\tvar this$1 = this;\n\n\t\t\tfor (var i = 0; i < this._listeners.length; i++) {\n\t\t\t\tthis$1._listeners[i]();\n\t\t\t}\n\t\t}\n\t};\n\n\tvar noOp = 'Inferno Error: Can only update a mounted or mounting component. This usually means you called setState() or forceUpdate() on an unmounted component. This is a no-op.';\n\n\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\tfunction getActiveNode() {\n\t\treturn document.activeElement;\n\t}\n\n\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\tfunction resetActiveNode(activeNode) {\n\t\tif (activeNode !== document.body && document.activeElement !== activeNode) {\n\t\t\tactiveNode.focus(); // TODO: verify are we doing new focus event, if user has focus listener this might trigger it\n\t\t}\n\t}\n\n\tfunction queueStateChanges(component, newState, callback) {\n\t\tfor (var stateKey in newState) {\n\t\t\tcomponent._pendingState[stateKey] = newState[stateKey];\n\t\t}\n\t\tif (!component._pendingSetState) {\n\t\t\tcomponent._pendingSetState = true;\n\t\t\tapplyState(component, false, callback);\n\t\t} else {\n\t\t\tcomponent.state = Object.assign({}, component.state, component._pendingState);\n\t\t\tcomponent._pendingState = {};\n\t\t}\n\t}\n\n\tfunction applyState(component, force, callback) {\n\t\tif ((!component._deferSetState || force) && !component._blockRender) {\n\t\t\tcomponent._pendingSetState = false;\n\t\t\tvar pendingState = component._pendingState;\n\t\t\tvar prevState = component.state;\n\t\t\tvar nextState = Object.assign({}, prevState, pendingState);\n\t\t\tvar props = component.props;\n\n\t\t\tcomponent._pendingState = {};\n\t\t\tvar nextNode = component._updateComponent(prevState, nextState, props, props, force);\n\n\t\t\tif (nextNode === NO_RENDER) {\n\t\t\t\tnextNode = component._lastNode;\n\t\t\t} else if (isNullOrUndefined(nextNode)) {\n\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t}\n\t\t\tvar lastNode = component._lastNode;\n\t\t\tvar parentDom = lastNode.dom.parentNode;\n\t\t\tvar activeNode = getActiveNode();\n\t\t\tvar subLifecycle = new Lifecycle();\n\n\t\t\tcomponent._patch(lastNode, nextNode, parentDom, subLifecycle, component.context, component, null);\n\t\t\tcomponent._lastNode = nextNode;\n\t\t\tcomponent._componentToDOMNodeMap.set(component, nextNode.dom);\n\t\t\tcomponent._parentNode.dom = nextNode.dom;\n\t\t\tcomponent.componentDidUpdate(props, prevState);\n\t\t\tsubLifecycle.trigger();\n\t\t\tif (!isNullOrUndefined(callback)) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\tresetActiveNode(activeNode);\n\t\t}\n\t}\n\n\tvar Component = function Component(props, context) {\n\t\tif ( context === void 0 ) context = {};\n\n\t\t/** @type {object} */\n\t\tthis.props = props || {};\n\n\t\t/** @type {object} */\n\t\tthis.state = {};\n\n\t\t/** @type {object} */\n\t\tthis.refs = {};\n\t\tthis._blockRender = false;\n\t\tthis._blockSetState = false;\n\t\tthis._deferSetState = false;\n\t\tthis._pendingSetState = false;\n\t\tthis._pendingState = {};\n\t\tthis._parentNode = null;\n\t\tthis._lastNode = null;\n\t\tthis._unmounted = true;\n\t\tthis.context = context;\n\t\tthis._patch = null;\n\t\tthis._parentComponent = null;\n\t\tthis._componentToDOMNodeMap = null;\n\t};\n\n\tComponent.prototype.render = function render () {\n\t};\n\n\tComponent.prototype.forceUpdate = function forceUpdate (callback) {\n\t\tif (this._unmounted) {\n\t\t\tthrow Error(noOp);\n\t\t}\n\t\tapplyState(this, true, callback);\n\t};\n\n\tComponent.prototype.setState = function setState (newState, callback) {\n\t\tif (this._unmounted) {\n\t\t\tthrow Error(noOp);\n\t\t}\n\t\tif (this._blockSetState === false) {\n\t\t\tqueueStateChanges(this, newState, callback);\n\t\t} else {\n\t\t\tthrow Error('Inferno Warning: Cannot update state via setState() in componentWillUpdate()');\n\t\t}\n\t};\n\n\tComponent.prototype.componentDidMount = function componentDidMount () {\n\t};\n\n\tComponent.prototype.componentWillMount = function componentWillMount () {\n\t};\n\n\tComponent.prototype.componentWillUnmount = function componentWillUnmount () {\n\t};\n\n\tComponent.prototype.componentDidUpdate = function componentDidUpdate () {\n\t};\n\n\tComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate () {\n\t\treturn true;\n\t};\n\n\tComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps () {\n\t};\n\n\tComponent.prototype.componentWillUpdate = function componentWillUpdate () {\n\t};\n\n\tComponent.prototype.getChildContext = function getChildContext () {\n\t};\n\n\tComponent.prototype._updateComponent = function _updateComponent (prevState, nextState, prevProps, nextProps, force) {\n\t\tif (this._unmounted === true) {\n\t\t\tthis._unmounted = false;\n\t\t\treturn false;\n\t\t}\n\t\tif (!isNullOrUndefined(nextProps) && isNullOrUndefined(nextProps.children)) {\n\t\t\tnextProps.children = prevProps.children;\n\t\t}\n\t\tif (prevProps !== nextProps || prevState !== nextState || force) {\n\t\t\tif (prevProps !== nextProps) {\n\t\t\t\tthis._blockRender = true;\n\t\t\t\tthis.componentWillReceiveProps(nextProps);\n\t\t\t\tthis._blockRender = false;\n\t\t\t\tif (this._pendingSetState) {\n\t\t\t\t\tnextState = Object.assign({}, nextState, this._pendingState);\n\t\t\t\t\tthis._pendingSetState = false;\n\t\t\t\t\tthis._pendingState = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar shouldUpdate = this.shouldComponentUpdate(nextProps, nextState);\n\n\t\t\tif (shouldUpdate !== false || force) {\n\t\t\t\tthis._blockSetState = true;\n\t\t\t\tthis.componentWillUpdate(nextProps, nextState);\n\t\t\t\tthis._blockSetState = false;\n\t\t\t\tthis.props = nextProps;\n\t\t\t\tthis.state = nextState;\n\t\t\t\treturn this.render();\n\t\t\t}\n\t\t}\n\t\treturn NO_RENDER;\n\t};\n\n\treturn Component;\n\n}));\n\n\n/** WEBPACK FOOTER **\n ** ./~/inferno/dist/inferno-component.js\n **/","\"use strict\";\nconst j2c_1 = require('j2c');\nlet style = '';\nfunction cleanStyle(s) {\n    return s.replace(/\\n/g, '');\n}\nfunction attach(...s) {\n    const scoped = j2c_1.sheet(s);\n    style += scoped;\n    return scoped;\n}\nexports.attach = attach;\nfunction dispatchStyle(clean = true) {\n    if (!clean) {\n        return <style>{style}</style>;\n    }\n    return <style>{cleanStyle(style)}</style>;\n}\nexports.dispatchStyle = dispatchStyle;\nfunction styled(target) {\n    if (typeof target.computedStyle === 'function') {\n        target.style = attach(target.componentStyle());\n    }\n    else {\n        target.style = {};\n    }\n}\nexports.styled = styled;\n//# sourceMappingURL=styler.jsx.map\n\n\n/** WEBPACK FOOTER **\n ** ./bin/common/component/styler.jsx\n **/","'use strict';\n\nvar emptyObject = {};\nvar emptyArray = [];\nvar type = emptyObject.toString;\nvar own =  emptyObject.hasOwnProperty;\nvar OBJECT = type.call(emptyObject);\nvar ARRAY =  type.call(emptyArray);\nvar STRING = type.call('');\n/*/-inline-/*/\n// function cartesian(a, b, res, i, j) {\n//   res = [];\n//   for (j in b) if (own.call(b, j))\n//     for (i in a) if (own.call(a, i))\n//       res.push(a[i] + b[j]);\n//   return res;\n// }\n/*/-inline-/*/\n\n/* /-statements-/*/\nfunction cartesian(a,b, selectorP, res, i, j) {\n  res = []\n  for (j in b) if(own.call(b, j))\n    for (i in a) if(own.call(a, i))\n      res.push(concat(a[i], b[j], selectorP))\n  return res\n}\n\nfunction concat(a, b, selectorP) {\n  // `b.replace(/&/g, a)` is never falsy, since the\n  // 'a' of cartesian can't be the empty string\n  // in selector mode.\n  return selectorP && (\n    /^[-\\w$]+$/.test(b) && ':-error-bad-sub-selector-' + b ||\n    /&/.test(b) && /* never falsy */ b.replace(/&/g, a)\n  ) || a + b\n}\n\nfunction decamelize(match) {\n  return '-' + match.toLowerCase()\n}\n\n/**\n * Handles the property:value; pairs.\n *\n * @param {array|object|string} o - the declarations.\n * @param {string[]} buf - the buffer in which the final style sheet is built.\n * @param {string} prefix - the current property or a prefix in case of nested\n *                          sub-properties.\n * @param {string} vendors - a list of vendor prefixes.\n * @Param {boolean} local - are we in @local or in @global scope.\n * @param {object} ns - helper functions to populate or create the @local namespace\n *                      and to @extend classes.\n * @param {function} ns.e - @extend helper.\n * @param {function} ns.l - @local helper.\n */\n\nfunction declarations(o, buf, prefix, vendors, local, ns, /*var*/ k, v, kk) {\n  if (o==null) return\n  if (/\\$/.test(prefix)) {\n    for (kk in (prefix = prefix.split('$'))) if (own.call(prefix, kk)) {\n      declarations(o, buf, prefix[kk], vendors, local, ns)\n    }\n    return\n  }\n  switch ( type.call(o = o.valueOf()) ) {\n  case ARRAY:\n    for (k = 0; k < o.length; k++)\n      declarations(o[k], buf, prefix, vendors, local, ns)\n    break\n  case OBJECT:\n    // prefix is falsy iif it is the empty string, which means we're at the root\n    // of the declarations list.\n    prefix = (prefix && prefix + '-')\n    for (k in o) if (own.call(o, k)){\n      v = o[k]\n      if (/\\$/.test(k)) {\n        for (kk in (k = k.split('$'))) if (own.call(k, kk))\n          declarations(v, buf, prefix + k[kk], vendors, local, ns)\n      } else {\n        declarations(v, buf, prefix + k, vendors, local, ns)\n      }\n    }\n    break\n  default:\n    // prefix is falsy when it is \"\", which means that we're\n    // at the top level.\n    // `o` is then treated as a `property:value` pair.\n    // otherwise, `prefix` is the property name, and\n    // `o` is the value.\n    k = prefix.replace(/_/g, '-').replace(/[A-Z]/g, decamelize)\n\n    if (local && (k == 'animation-name' || k == 'animation')) {\n      o = o.split(',').map(function (o) {\n        return o.replace(/()(?::global\\(\\s*([-\\w]+)\\s*\\)|()([-\\w]+))/, ns.l)\n      }).join(',')\n    }\n    if (/^animation|^transition/.test(k)) vendors = ['webkit']\n    // '@' in properties also triggers the *ielte7 hack\n    // Since plugins dispatch on the /^@/ for at-rules\n    // we swap the at for an asterisk\n    // http://browserhacks.com/#hack-6d49e92634f26ae6d6e46b3ebc10019a\n\n    k = k.replace(/^@/, '*')\n\n/*/-statements-/*/\n    // vendorify\n    for (kk = 0; kk < vendors.length; kk++)\n      buf.push('-', vendors[kk], '-', k, k ? ':': '', o, ';\\n')\n/*/-statements-/*/\n\n    buf.push(k, k ? ':': '', o, ';\\n')\n\n  }\n}\n\nvar findClass = /()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|(\\.)([-\\w]+))/g\n\n/**\n * Hanldes at-rules\n *\n * @param {string} k - The at-rule name, and, if takes both parameters and a\n *                     block, the parameters.\n * @param {string[]} buf - the buffer in which the final style sheet is built\n * @param {string[]} v - Either parameters for block-less rules or their block\n *                       for the others.\n * @param {string} prefix - the current selector or a prefix in case of nested rules\n * @param {string} rawPrefix - as above, but without localization transformations\n * @param {string} vendors - a list of vendor prefixes\n * @Param {boolean} local - are we in @local or in @global scope?\n * @param {object} ns - helper functions to populate or create the @local namespace\n *                      and to @extend classes\n * @param {function} ns.e - @extend helper\n * @param {function} ns.l - @local helper\n */\n\nfunction at(k, v, buf, prefix, rawPrefix, vendors, local, ns){\n  var kk\n  if (/^@(?:namespace|import|charset)$/.test(k)) {\n    if(type.call(v) == ARRAY){\n      for (kk = 0; kk < v.length; kk++) {\n        buf.push(k, ' ', v[kk], ';\\n')\n      }\n    } else {\n      buf.push(k, ' ', v, ';\\n')\n    }\n  } else if (/^@keyframes /.test(k)) {\n    k = local ? k.replace(\n      // generated by script/regexps.js\n      /( )(?::global\\(\\s*([-\\w]+)\\s*\\)|()([-\\w]+))/,\n      ns.l\n    ) : k\n    // add a @-webkit-keyframes block too.\n\n    buf.push('@-webkit-', k.slice(1), ' {\\n')\n    sheet(v, buf, '', '', ['webkit'])\n    buf.push('}\\n')\n\n    buf.push(k, ' {\\n')\n    sheet(v, buf, '', '', vendors, local, ns)\n    buf.push('}\\n')\n\n  } else if (/^@extends?$/.test(k)) {\n\n    /*eslint-disable no-cond-assign*/\n    // pick the last class to be extended\n    while (kk = findClass.exec(rawPrefix)) k = kk[4]\n    /*eslint-enable no-cond-assign*/\n    if (k == null || !local) {\n      // we're in a @global{} block\n      buf.push('@-error-cannot-extend-in-global-context ', JSON.stringify(rawPrefix), ';\\n')\n      return\n    } else if (/^@extends?$/.test(k)) {\n      // no class in the selector\n      buf.push('@-error-no-class-to-extend-in ', JSON.stringify(rawPrefix), ';\\n')\n      return\n    }\n    ns.e(\n      type.call(v) == ARRAY ? v.map(function (parent) {\n        return parent.replace(/()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|()\\.([-\\w]+))/, ns.l)\n      }).join(' ') : v.replace(/()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|()\\.([-\\w]+))/, ns.l),\n      k\n    )\n\n  } else if (/^@(?:font-face$|viewport$|page )/.test(k)) {\n    sheet(v, buf, k, k, emptyArray)\n\n  } else if (/^@global$/.test(k)) {\n    sheet(v, buf, prefix, rawPrefix, vendors, 0, ns)\n\n  } else if (/^@local$/.test(k)) {\n    sheet(v, buf, prefix, rawPrefix, vendors, 1, ns)\n\n  } else if (/^@(?:media |supports |document )./.test(k)) {\n    buf.push(k, ' {\\n')\n    sheet(v, buf, prefix, rawPrefix, vendors, local, ns)\n    buf.push('}\\n')\n\n  } else {\n    buf.push('@-error-unsupported-at-rule ', JSON.stringify(k), ';\\n')\n  }\n}\n\n/**\n * Add rulesets and other CSS statements to the sheet.\n *\n * @param {array|string|object} statements - a source object or sub-object.\n * @param {string[]} buf - the buffer in which the final style sheet is built\n * @param {string} prefix - the current selector or a prefix in case of nested rules\n * @param {string} rawPrefix - as above, but without localization transformations\n * @param {string} vendors - a list of vendor prefixes\n * @Param {boolean} local - are we in @local or in @global scope?\n * @param {object} ns - helper functions to populate or create the @local namespace\n *                      and to @extend classes\n * @param {function} ns.e - @extend helper\n * @param {function} ns.l - @local helper\n */\nfunction sheet(statements, buf, prefix, rawPrefix, vendors, local, ns) {\n  var k, kk, v, inDeclaration\n\n  switch (type.call(statements)) {\n\n  case ARRAY:\n    for (k = 0; k < statements.length; k++)\n      sheet(statements[k], buf, prefix, rawPrefix, vendors, local, ns)\n    break\n\n  case OBJECT:\n    for (k in statements) {\n      v = statements[k]\n      if (prefix && /^[-\\w$]+$/.test(k)) {\n        if (!inDeclaration) {\n          inDeclaration = 1\n          buf.push(( prefix || '*' ), ' {\\n')\n        }\n        declarations(v, buf, k, vendors, local, ns)\n      } else if (/^@/.test(k)) {\n        // Handle At-rules\n        inDeclaration = (inDeclaration && buf.push('}\\n') && 0)\n\n        at(k, v, buf, prefix, rawPrefix, vendors, local, ns)\n\n      } else {\n        // selector or nested sub-selectors\n\n        inDeclaration = (inDeclaration && buf.push('}\\n') && 0)\n\n        sheet(v, buf,\n          (kk = /,/.test(prefix) || prefix && /,/.test(k)) ?\n            cartesian(prefix.split(','), ( local ?\n          k.replace(\n            /()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|(\\.)([-\\w]+))/g, ns.l\n          ) : k\n        ).split(','), prefix).join(',') :\n            concat(prefix, ( local ?\n          k.replace(\n            /()(?::global\\(\\s*(\\.[-\\w]+)\\s*\\)|(\\.)([-\\w]+))/g, ns.l\n          ) : k\n        ), prefix),\n          kk ?\n            cartesian(rawPrefix.split(','), k.split(','), rawPrefix).join(',') :\n            concat(rawPrefix, k, rawPrefix),\n          vendors,\n          local, ns\n        )\n      }\n    }\n    if (inDeclaration) buf.push('}\\n')\n    break\n  case STRING:\n    buf.push(\n        ( prefix || ':-error-no-selector' ) , ' {\\n'\n      )\n    declarations(statements, buf, '', vendors, local, ns)\n    buf.push('}\\n')\n  }\n}\n\nvar scope_root = '_j2c_' +\n      Math.floor(Math.random() * 0x100000000).toString(36) + '_' +\n      Math.floor(Math.random() * 0x100000000).toString(36) + '_' +\n      Math.floor(Math.random() * 0x100000000).toString(36) + '_' +\n      Math.floor(Math.random() * 0x100000000).toString(36) + '_';\nvar counter = 0;\nfunction j2c(res) {\n  res = res || {}\n  var extensions = []\n\n  function finalize(buf, i) {\n    for (i = 0; i< extensions.length; i++) buf = extensions[i](buf) || buf\n    return buf.join('')\n  }\n\n  res.use = function() {\n    var args = arguments\n    for (var i = 0; i < args.length; i++){\n      extensions.push(args[i])\n    }\n    return res\n  }\n/*/-statements-/*/\n  res.sheet = function(ns, statements) {\n    if (arguments.length === 1) {\n      statements = ns; ns = {}\n    }\n    var\n      suffix = scope_root + counter++,\n      locals = {},\n      k, buf = []\n    // pick only non-numeric keys since `(NaN != NaN) === true`\n    for (k in ns) if (k-0 != k-0 && own.call(ns, k)) {\n      locals[k] = ns[k]\n    }\n    sheet(\n      statements, buf, '', '', emptyArray /*vendors*/,\n      1, // local\n      {\n        e: function extend(parent, child) {\n          var nameList = locals[child]\n          locals[child] =\n            nameList.slice(0, nameList.lastIndexOf(' ') + 1) +\n            parent + ' ' +\n            nameList.slice(nameList.lastIndexOf(' ') + 1)\n        },\n        l: function localize(match, space, global, dot, name) {\n          if (global) {\n            return space + global\n          }\n          if (!locals[name]) locals[name] = name + suffix\n          return space + dot + locals[name].match(/\\S+$/)\n        }\n      }\n    )\n    /*jshint -W053 */\n    buf = new String(finalize(buf))\n    /*jshint +W053 */\n    for (k in locals) if (own.call(locals, k)) buf[k] = locals[k]\n    return buf\n  }\n/*/-statements-/*/\n  res.inline = function (locals, decl, buf) {\n    if (arguments.length === 1) {\n      decl = locals; locals = {}\n    }\n    declarations(\n      decl,\n      buf = [],\n      '', // prefix\n      emptyArray, // vendors\n      1,\n      {\n        l: function localize(match, space, global, dot, name) {\n          if (global) return space + global\n          if (!locals[name]) return name\n          return space + dot + locals[name]\n        }\n      })\n    return finalize(buf)\n  }\n\n  res.prefix = function(val, vendors) {\n    return cartesian(\n      vendors.map(function(p){return '-' + p + '-'}).concat(['']),\n      [val]\n    )\n  }\n  return res\n}\n\nj2c.global = function(x) {\n  return ':global(' + x + ')'\n}\n\nj2c.kv = kv\nfunction kv (k, v, o) {\n  o = {}\n  o[k] = v\n  return o\n}\n\nj2c.at = function at (rule, params, block) {\n  if (\n    arguments.length < 3\n  ) {\n    var _at = at.bind.apply(at, [null].concat([].slice.call(arguments,0)))\n    _at.toString = function(){return '@' + rule + ' ' + params}\n    return _at\n  }\n  else return kv('@' + rule + ' ' + params, block)\n}\n\nj2c(j2c)\ndelete j2c.use\n\nmodule.exports = j2c;\n\n\n/** WEBPACK FOOTER **\n ** ./~/j2c/dist/j2c.commonjs.js\n **/","(function() {\n    function mrFactory(mobx, Inferno, InfernoDOM, InfernoComponent, createClass) {\n        if (!mobx)\n            throw new Error(\"mobx-inferno requires the MobX package\")\n        if (!Inferno)\n            throw new Error(\"mobx-inferno requires inferno to be available\");\n        if (!InfernoComponent)\n            throw new Error(\"mobx-inferno requires inferno-component to be available\");\n\n        /**\n         * dev tool support\n         */\n        var isDevtoolsEnabled = false;\n\n        // WeakMap<Node, Object>;\n        var componentByNodeRegistery = typeof WeakMap !== \"undefined\" ? new WeakMap() : undefined;\n        var renderReporter = new EventEmitter();\n\n        function findDOMNode(component) {\n            if (InfernoDOM)\n                return InfernoDOM.findDOMNode(component);\n            return null;\n        }\n\n        function reportRendering(component) {\n            var node = findDOMNode(component);\n            if (node && componentByNodeRegistery)\n                componentByNodeRegistery.set(node, component);\n\n            renderReporter.emit({\n                event: 'render',\n                renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,\n                totalTime: Date.now() - component.__$mobRenderStart,\n                component: component,\n                node: node\n            });\n        }\n\n        function trackComponents() {\n            if (typeof WeakMap === \"undefined\")\n                throw new Error(\"[mobx-inferno] tracking components is not supported in this browser.\");\n            if (!isDevtoolsEnabled)\n                isDevtoolsEnabled = true;\n        }\n\n        function EventEmitter() {\n            this.listeners = [];\n        };\n        EventEmitter.prototype.on = function (cb) {\n            this.listeners.push(cb);\n            var self = this;\n            return function() {\n                var idx = self.listeners.indexOf(cb);\n                if (idx !== -1)\n                    self.listeners.splice(idx, 1);\n            };\n        };\n        EventEmitter.prototype.emit = function(data) {\n            this.listeners.forEach(function (fn) {\n                fn(data);\n            });\n        };\n\n        /**\n         * Utilities\n         */\n        var specialReactKeys = { children: true, key: true, ref: true };\n\n        function patch(target, funcName) {\n            var base = target[funcName];\n            var mixinFunc = reactiveMixin[funcName];\n            if (!base) {\n                target[funcName] = mixinFunc;\n            } else {\n                target[funcName] = function() {\n                    base.apply(this, arguments);\n                    mixinFunc.apply(this, arguments);\n                }\n            }\n        }\n\n        /**\n         * ReactiveMixin\n         */\n        var reactiveMixin = {\n            componentWillMount: function componentWillMount() {\n                // Generate friendly name for debugging\n                var name = [\n                    this.displayName || this.name || (this.constructor && (this.constructor.displayName || this.constructor.name)) || \"<component>\",\n                    \"#\", this._reactInternalInstance && this._reactInternalInstance._rootNodeID,\n                    \".render()\"\n                ].join(\"\");\n\n                var baseRender = this.render.bind(this);\n                var self = this;\n                var reaction = null;\n                var isRenderingPending = false;\n                function initialRender() {\n                    reaction = new mobx.Reaction(name, function() {\n                        if (!isRenderingPending) {\n                            // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n                            // This unidiomatic inferno usage but inferno will correctly warn about this so we continue as usual\n                            // See #85 / Pull #44\n                            isRenderingPending = true;\n\n                            if (typeof self.componentWillReact === \"function\")\n                                self.componentWillReact(); // TODO: wrap in action?\n                            if (self.__$mobxIsUnmounted !== true) {\n                                // If we are unmounted at this point, componentWillReact() had a side effect causing the component to unmounted\n                                // TODO: remove this check? Then inferno will properly warn about the fact that this should not happen? See #73\n                                // However, people also claim this migth happen during unit tests..\n                                InfernoComponent.prototype.forceUpdate.call(self)\n                            }\n                        }\n                    });\n\n                    reactiveRender.$mobx = reaction;\n                    self.render = reactiveRender;\n                    return reactiveRender();\n                }\n\n                function reactiveRender() {\n                    isRenderingPending = false;\n                    var rendering;\n                    reaction.track(function() {\n                        if (isDevtoolsEnabled)\n                            self.__$mobRenderStart = Date.now();\n                        rendering = mobx.extras.allowStateChanges(false, baseRender);\n                        if (isDevtoolsEnabled)\n                            self.__$mobRenderEnd = Date.now();\n                    });\n                    return rendering;\n                }\n\n                this.render = initialRender;\n            },\n\n            componentWillUnmount: function() {\n                this.render.$mobx && this.render.$mobx.dispose();\n                this.__$mobxIsUnmounted = true;\n                if (isDevtoolsEnabled) {\n                    var node = findDOMNode(this);\n                    if (node && componentByNodeRegistery) {\n                        componentByNodeRegistery.delete(node);\n                    }\n                    renderReporter.emit({\n                        event: 'destroy',\n                        component: this,\n                        node: node\n                    });\n                }\n            },\n\n            componentDidMount: function() {\n                if (isDevtoolsEnabled)\n                    reportRendering(this);\n            },\n\n            componentDidUpdate: function() {\n                if (isDevtoolsEnabled)\n                    reportRendering(this);\n            },\n\n            shouldComponentUpdate: function(nextProps, nextState) {\n                // TODO: if context changed, return true.., see #18\n                // if props or state did change, but a render was scheduled already, no additional render needs to be scheduled\n                if (this.render.$mobx && this.render.$mobx.isScheduled() === true)\n                    return false;\n\n                // update on any state changes (as is the default)\n                if (this.state !== nextState)\n                    return true;\n                // update if props are shallowly not equal, inspired by PureRenderMixin\n                var keys = Object.keys(this.props);\n                var key;\n                if (keys.length !== Object.keys(nextProps).length)\n                    return true;\n                for(var i = keys.length -1; i >= 0, key = keys[i]; i--) {\n                    var newValue = nextProps[key];\n                    if (newValue !== this.props[key]) {\n                        return true;\n                    } else if (newValue && typeof newValue === \"object\" && !mobx.isObservable(newValue)) {\n                        /**\n                         * If the newValue is still the same object, but that object is not observable,\n                         * fallback to the default inferno behavior: update, because the object *might* have changed.\n                         * If you need the non default behavior, just use the inferno pure render mixin, as that one\n                         * will work fine with mobx as well, instead of the default implementation of\n                         * observer.\n                         */\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n\n        /**\n         * Observer function / decorator\n         */\n        function observer(arg1, arg2) {\n            if (typeof arg1 === \"string\")\n                throw new Error(\"Store names should be provided as array\");\n            if (Array.isArray(arg1)) {\n                // component needs stores\n                if (!arg2) {\n                    // invoked as decorator\n                    return function(componentClass) {\n                        return observer(arg1, componentClass);\n                    }\n                } else {\n                    // TODO: deprecate this invocation style\n                    return inject.apply(null, arg1)(observer(arg2));\n                }\n            }\n            var componentClass = arg1;\n\n            // Stateless function component:\n            // If it is function but doesn't seem to be an inferno class constructor,\n            // wrap it to an inferno class automatically\n            if (\n            typeof componentClass === \"function\" &&\n            (!componentClass.prototype || !componentClass.prototype.render) &&\n            !componentClass.isReactClass &&\n            !InfernoComponent.isPrototypeOf(componentClass)\n            ) {\n                return observer(createClass({\n                    displayName:     componentClass.displayName || componentClass.name,\n                    contextTypes:    componentClass.contextTypes,\n                    getDefaultProps: function() { return componentClass.defaultProps; },\n                    render:          function() { return componentClass.call(this, this.props, this.context); }\n                }));\n            }\n\n            if (!componentClass)\n                throw new Error(\"Please pass a valid component to 'observer'\");\n            var target = componentClass.prototype || componentClass;\n            [\n                \"componentWillMount\",\n                \"componentWillUnmount\",\n                \"componentDidMount\",\n                \"componentDidUpdate\"\n            ].forEach(function(funcName) {\n                patch(target, funcName)\n            });\n\n            if (!target.shouldComponentUpdate)\n                target.shouldComponentUpdate = reactiveMixin.shouldComponentUpdate;\n\n            componentClass.isMobXReactObserver = true;\n            return componentClass;\n        }\n\n        /**\n         * Store provider\n         */\n        var Provider = createClass({\n            displayName: \"Provider\",\n\n            render: function() {\n                return Inferno.Children.only(this.props.children);\n            },\n\n            getChildContext: function () {\n                var stores = {};\n                // inherit stores\n                var baseStores = this.context.mobxStores;\n                if (baseStores) for (var key in baseStores) {\n                    stores[key] = baseStores[key];\n                }\n                // add own stores\n                for (var key in this.props)\n                    if (!specialReactKeys[key])\n                        stores[key] = this.props[key];\n                return {\n                    mobxStores: stores\n                };\n            },\n\n            componentWillReceiveProps: function(nextProps) {\n                // Maybe this warning is to aggressive?\n                if (Object.keys(nextProps).length !== Object.keys(this.props).length)\n                    console.warn(\"MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children\");\n                for (var key in nextProps)\n                    if (!specialReactKeys[key] && this.props[key] !== nextProps[key])\n                        console.warn(\"MobX Provider: Provided store '\" + key + \"' has changed. Please avoid replacing stores as the change might not propagate to all children\");\n            }\n        });\n\n        var PropTypesAny = function(){};\n        Provider.contextTypes = { mobxStores: PropTypesAny };\n        Provider.childContextTypes = { mobxStores: PropTypesAny };\n\n        /**\n         * Store Injection\n         */\n        function createStoreInjector(grabStoresFn, component) {\n            var Injector = createClass({\n                displayName: \"MobXStoreInjector\",\n                render: function() {\n                    var newProps = {};\n                    for (var key in this.props)\n                        newProps[key] = this.props[key];\n                    newProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context);\n                    return Inferno.universal.createElement(component, newProps);\n                }\n                // TODO: should have shouldComponentUpdate?\n            });\n            Injector.contextTypes = { mobxStores: PropTypesAny };\n            Injector.wrappedComponent = component;\n            return Injector;\n        }\n\n        /**\n         * higher order component that injects stores to a child.\n         * takes either a varargs list of strings, which are stores read from the context,\n         * or a function that manually maps the available stores from the context to props:\n         * storesToProps(mobxStores, props, context) => newProps\n         */\n        function inject(/* fn(stores, nextProps) or ...storeNames */) {\n            var grabStoresFn;\n            if (typeof arguments[0] === \"function\") {\n                grabStoresFn = arguments[0];\n            } else {\n                var storesNames = [];\n                for (var i = 0; i < arguments.length; i++)\n                    storesNames[i] = arguments[i];\n                grabStoresFn = grabStoresByName(storesNames);\n            }\n            return function(componentClass) {\n                return createStoreInjector(grabStoresFn, componentClass);\n            };\n        }\n\n        function grabStoresByName(storeNames) {\n            return function(baseStores, nextProps) {\n                storeNames.forEach(function(storeName) {\n                    if (storeName in nextProps) // prefer props over stores\n                        return;\n                    if (!(storeName in baseStores))\n                        throw new Error(\"MobX observer: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n                    nextProps[storeName] = baseStores[storeName];\n                });\n                return nextProps;\n            }\n        }\n\n        /**\n         * PropTypes\n         */\n\n        function observableTypeChecker (type) {\n            return function(props, propName, componentName) {\n                if (!mobx['isObservable' + type](props[propName])) {\n                    return new Error(\n                    'Invalid prop `' + propName + '` supplied to' +\n                    ' `' + componentName + '`. Expected a mobx observable ' + type + '. Validation failed.'\n                    );\n                }\n            };\n        }\n\n        // oneOfType is used for simple isRequired chaining\n\n        var propTypes = {\n            observableArray: PropTypesAny,\n            observableMap: PropTypesAny,\n            observableObject: PropTypesAny,\n            arrayOrObservableArray: PropTypesAny,\n            objectOrObservableObject: PropTypesAny\n        };\n\n        /**\n         * Export\n         */\n        return ({\n            observer: observer,\n            Provider: Provider,\n            inject: inject,\n            propTypes: propTypes,\n            renderReporter: renderReporter,\n            componentByNodeRegistery: componentByNodeRegistery,\n            trackComponents: trackComponents\n        });\n    }\n\n    /**\n     * UMD\n     */\n    if (typeof exports === 'object') {\n        module.exports = mrFactory(require('mobx'), require('inferno'), require('inferno-dom'), require('inferno-component'), require('inferno-create-class'));\n    } else if (typeof define === 'function' && define.amd) {\n        define('mobx-inferno', ['mobx', 'inferno', 'inferno-dom', 'inferno-component', 'inferno-create-class'], mrFactory);\n    } else {\n        this.mobxInferno = mrFactory(this['mobx'], this['Inferno'], this['InfernoDOM'], this['InfernoComponent'], this['createClass']);\n    }\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/mobx-inferno/index.js\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    resetGlobalState: resetGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    trackTransitions: trackTransitions\n};\nexports._ = {\n    getAdministration: getAdministration,\n    resetGlobalState: resetGlobalState\n};\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = (args && args.length === 1) ? args[0] : (value.name || key || \"<unnamed action>\");\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, \"It is not allowed to assign new values to @action fields\");\n}, false, true);\nfunction action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\")\n        return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\")\n        return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\")\n        return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n}\nexports.action = action;\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", \"`runInAction` expects a function\");\n    invariant(fn.length === 0, \"`runInAction` expects a function without arguments\");\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    }\n    else if (typeof arg1 === \"function\") {\n        name = arg1.name || (\"Autorun@\" + getNextId());\n        view = arg1;\n        scope = arg2;\n    }\n    assertUnwrapped(view, \"autorun methods cannot have modifiers\");\n    invariant(typeof view === \"function\", \"autorun expects a function\");\n    if (scope)\n        view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    }\n    else if (typeof arg1 === \"function\") {\n        name = (\"When@\" + getNextId());\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunUntil(predicate, effect, scope) {\n    deprecated(\"`autorunUntil` is deprecated, please use `when`.\");\n    return when.apply(null, arguments);\n}\nexports.autorunUntil = autorunUntil;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    }\n    else if (typeof arg1 === \"function\") {\n        name = arg1.name || (\"AutorunAsync@\" + getNextId());\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    if (delay === void 0)\n        delay = 1;\n    if (scope)\n        func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed)\n                    r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() { func(r); }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(arg1, arg2, arg3, arg4, arg5, arg6) {\n    var name, expression, effect, fireImmediately, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        expression = arg2;\n        effect = arg3;\n        fireImmediately = arg4;\n        delay = arg5;\n        scope = arg6;\n    }\n    else {\n        name = arg1.name || arg2.name || (\"Reaction@\" + getNextId());\n        expression = arg1;\n        effect = arg2;\n        fireImmediately = arg3;\n        delay = arg4;\n        scope = arg5;\n    }\n    if (fireImmediately === void 0)\n        fireImmediately = false;\n    if (delay === void 0)\n        delay = 0;\n    var _a = getValueModeFromValue(expression, ValueMode.Reference), valueMode = _a[0], unwrappedExpression = _a[1];\n    var compareStructural = valueMode === ValueMode.Structure;\n    if (scope) {\n        unwrappedExpression = unwrappedExpression.bind(scope);\n        effect = action(name, effect.bind(scope));\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue = undefined;\n    var r = new Reaction(name, function () {\n        if (delay < 1) {\n            reactionRunner();\n        }\n        else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed)\n            return;\n        var changed = false;\n        r.track(function () {\n            var v = unwrappedExpression(r);\n            changed = valueDidChange(compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && fireImmediately)\n            effect(nextValue, r);\n        if (!firstTime && changed === true)\n            effect(nextValue, r);\n        if (firstTime)\n            firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nvar computedDecorator = createClassPropertyDecorator(function (target, name, _, decoratorArgs, originalDescriptor) {\n    invariant(typeof originalDescriptor !== \"undefined\", \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\");\n    var baseValue = originalDescriptor.get;\n    invariant(typeof baseValue === \"function\", \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\");\n    var compareStructural = false;\n    if (decoratorArgs && decoratorArgs.length === 1 && decoratorArgs[0].asStructure === true)\n        compareStructural = true;\n    var adm = asObservableObject(target, undefined, ValueMode.Recursive);\n    defineObservableProperty(adm, name, compareStructural ? asStructure(baseValue) : baseValue, false);\n}, function (name) {\n    return this.$mobx.values[name].get();\n}, throwingComputedValueSetter, false, true);\nfunction computed(targetOrExpr, keyOrScope, baseDescriptor, options) {\n    if (arguments.length < 3 && typeof targetOrExpr === \"function\")\n        return computedExpr(targetOrExpr, keyOrScope);\n    invariant(!baseDescriptor || !baseDescriptor.set, \"@observable properties cannot have a setter: \" + keyOrScope);\n    return computedDecorator.apply(null, arguments);\n}\nexports.computed = computed;\nfunction computedExpr(expr, scope) {\n    var _a = getValueModeFromValue(expr, ValueMode.Recursive), mode = _a[0], value = _a[1];\n    return new ComputedValue(value, scope, mode === ValueMode.Structure, value.name);\n}\nfunction throwingComputedValueSetter() {\n    throw new Error(\"[ComputedValue] It is not allowed to assign new values to computed properties.\");\n}\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length === 1, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = (function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            _super.call(this, function () { return transformer(sourceObject); }, null, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier);\n            this.sourceIdentifier = sourceIdentifier;\n            this.sourceObject = sourceObject;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup)\n                onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue));\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer)\n            return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || typeof object !== \"object\")\n        throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation())\n        console.warn(\"[mobx.expr] 'expr' should only be used inside other reactive functions.\");\n    return computed(expr, scope).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    invariant(arguments.length >= 2, \"extendObservable expected 2 or more arguments\");\n    invariant(typeof target === \"object\", \"extendObservable expects an object as first argument\");\n    invariant(!(target instanceof ObservableMap), \"extendObservable should not be used on maps, use map.merge instead\");\n    properties.forEach(function (propSet) {\n        invariant(typeof propSet === \"object\", \"all arguments of extendObservable should be objects\");\n        extendObservableHelper(target, propSet, ValueMode.Recursive, null);\n    });\n    return target;\n}\nexports.extendObservable = extendObservable;\nfunction extendObservableHelper(target, properties, mode, name) {\n    var adm = asObservableObject(target, name, mode);\n    for (var key in properties)\n        if (properties.hasOwnProperty(key)) {\n            if (target === properties && !isPropertyConfigurable(target, key))\n                continue;\n            setObservableObjectInstanceProperty(adm, key, properties[key]);\n        }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0)\n        result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observers && node.observers.length > 0)\n        result.observers = node.observers.asArray().map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\")\n        return interceptProperty(thing, propOrHandler, handler);\n    else\n        return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    if (isPlainObject(thing) && !isObservableObject(thing)) {\n        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n        return getAdministration(observable(thing)).intercept(handler);\n    }\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    if (isPlainObject(thing) && !isObservableObject(thing)) {\n        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n        extendObservable(thing, {\n            property: thing[property]\n        });\n        return interceptProperty(thing, property, handler);\n    }\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isObservable(value, property) {\n    if (value === null || value === undefined)\n        return false;\n    if (property !== undefined) {\n        if (value instanceof ObservableMap || value instanceof ObservableArray)\n            throw new Error(\"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\");\n        else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return !!value.$mobx || value instanceof BaseAtom || value instanceof Reaction || value instanceof ComputedValue;\n}\nexports.isObservable = isObservable;\nvar decoratorImpl = createClassPropertyDecorator(function (target, name, baseValue) {\n    var prevA = allowStateChangesStart(true);\n    if (typeof baseValue === \"function\")\n        baseValue = asReference(baseValue);\n    var adm = asObservableObject(target, undefined, ValueMode.Recursive);\n    defineObservableProperty(adm, name, baseValue, true);\n    allowStateChangesEnd(prevA);\n}, function (name) {\n    return this.$mobx.values[name].get();\n}, function (name, value) {\n    setPropertyValue(this, name, value);\n}, true, false);\nfunction observableDecorator(target, key, baseDescriptor) {\n    invariant(arguments.length >= 2 && arguments.length <= 3, \"Illegal decorator config\", key);\n    assertPropertyConfigurable(target, key);\n    invariant(!baseDescriptor || !baseDescriptor.get, \"@observable can not be used on getters, use @computed instead\");\n    return decoratorImpl.apply(null, arguments);\n}\nfunction observable(v, keyOrScope) {\n    if (v === void 0) { v = undefined; }\n    if (typeof arguments[1] === \"string\")\n        return observableDecorator.apply(null, arguments);\n    invariant(arguments.length < 3, \"observable expects zero, one or two arguments\");\n    if (isObservable(v))\n        return v;\n    var _a = getValueModeFromValue(v, ValueMode.Recursive), mode = _a[0], value = _a[1];\n    var sourceType = mode === ValueMode.Reference ? ValueType.Reference : getTypeOfValue(value);\n    switch (sourceType) {\n        case ValueType.Array:\n        case ValueType.PlainObject:\n            return makeChildObservable(value, mode);\n        case ValueType.Reference:\n        case ValueType.ComplexObject:\n            return new ObservableValue(value, mode);\n        case ValueType.ComplexFunction:\n            throw new Error(\"[mobx.observable] To be able to make a function reactive it should not have arguments. If you need an observable reference to a function, use `observable(asReference(f))`\");\n        case ValueType.ViewFunction:\n            deprecated(\"Use `computed(expr)` instead of `observable(expr)`\");\n            return computed(v, keyOrScope);\n    }\n    invariant(false, \"Illegal State\");\n}\nexports.observable = observable;\nvar ValueType;\n(function (ValueType) {\n    ValueType[ValueType[\"Reference\"] = 0] = \"Reference\";\n    ValueType[ValueType[\"PlainObject\"] = 1] = \"PlainObject\";\n    ValueType[ValueType[\"ComplexObject\"] = 2] = \"ComplexObject\";\n    ValueType[ValueType[\"Array\"] = 3] = \"Array\";\n    ValueType[ValueType[\"ViewFunction\"] = 4] = \"ViewFunction\";\n    ValueType[ValueType[\"ComplexFunction\"] = 5] = \"ComplexFunction\";\n})(ValueType || (ValueType = {}));\nfunction getTypeOfValue(value) {\n    if (value === null || value === undefined)\n        return ValueType.Reference;\n    if (typeof value === \"function\")\n        return value.length ? ValueType.ComplexFunction : ValueType.ViewFunction;\n    if (Array.isArray(value) || value instanceof ObservableArray)\n        return ValueType.Array;\n    if (typeof value === \"object\")\n        return isPlainObject(value) ? ValueType.PlainObject : ValueType.ComplexObject;\n    return ValueType.Reference;\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\")\n        return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);\n    else\n        return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    if (isPlainObject(thing) && !isObservableObject(thing)) {\n        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n        return getAdministration(observable(thing)).observe(listener, fireImmediately);\n    }\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    if (isPlainObject(thing) && !isObservableObject(thing)) {\n        deprecated(\"Passing plain objects to intercept / observe is deprecated and will be removed in 3.0\");\n        extendObservable(thing, {\n            property: thing[property]\n        });\n        return observeObservableProperty(thing, property, listener, fireImmediately);\n    }\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) { detectCycles = true; }\n    if (__alreadySeen === void 0) { __alreadySeen = null; }\n    function cache(value) {\n        if (detectCycles)\n            __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (source instanceof Date || source instanceof RegExp)\n        return source;\n    if (detectCycles && __alreadySeen === null)\n        __alreadySeen = [];\n    if (detectCycles && source !== null && typeof source === \"object\") {\n        for (var i = 0, l = __alreadySeen.length; i < l; i++)\n            if (__alreadySeen[i][0] === source)\n                return __alreadySeen[i][1];\n    }\n    if (!source)\n        return source;\n    if (Array.isArray(source) || source instanceof ObservableArray) {\n        var res = cache([]);\n        var toAdd = source.map(function (value) { return toJS(value, detectCycles, __alreadySeen); });\n        res.length = toAdd.length;\n        for (var i = 0, l = toAdd.length; i < l; i++)\n            res[i] = toAdd[i];\n        return res;\n    }\n    if (source instanceof ObservableMap) {\n        var res_1 = cache({});\n        source.forEach(function (value, key) { return res_1[key] = toJS(value, detectCycles, __alreadySeen); });\n        return res_1;\n    }\n    if (isObservable(source) && source.$mobx instanceof ObservableValue)\n        return toJS(source(), detectCycles, __alreadySeen);\n    if (source instanceof ObservableValue)\n        return toJS(source.get(), detectCycles, __alreadySeen);\n    if (typeof source === \"object\") {\n        var res = cache({});\n        for (var key in source)\n            res[key] = toJS(source[key], detectCycles, __alreadySeen);\n        return res;\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction toJSON(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) { detectCycles = true; }\n    if (__alreadySeen === void 0) { __alreadySeen = null; }\n    deprecated(\"toJSON is deprecated. Use toJS instead\");\n    return toJS.apply(null, arguments);\n}\nexports.toJSON = toJSON;\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.derivationStack[globalState.derivationStack.length - 1];\n            if (!thing)\n                return log(\"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested it's value.\");\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (thing instanceof ComputedValue)\n        return log(thing.whyRun());\n    else if (thing instanceof Reaction)\n        return log(thing.whyRun());\n    else\n        invariant(false, \"whyRun can only be used on reactions and computed values\");\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", \"`action` can only be invoked on functions\");\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function () {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var ds = globalState.derivationStack;\n    invariant(!(ds[ds.length - 1] instanceof ComputedValue), \"Computed values or transformers should not invoke actions or trigger other side effects\");\n    var notifySpy = isSpyEnabled();\n    var startTime;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = (args && args.length) || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0)\n            for (var i = 0; i < l; i++)\n                flattendArgs[i] = args[i];\n        spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            target: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevUntracked = untrackedStart();\n    transactionStart(actionName, scope, false);\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    try {\n        return fn.apply(scope, args);\n    }\n    finally {\n        allowStateChangesEnd(prevAllowStateChanges);\n        transactionEnd(false);\n        untrackedEnd(prevUntracked);\n        if (notifySpy)\n            spyReportEnd({ time: Date.now() - startTime });\n    }\n}\nfunction useStrict(strict) {\n    if (arguments.length === 0)\n        return globalState.strictMode;\n    else {\n        invariant(globalState.derivationStack.length === 0, \"It is not allowed to set `useStrict` when a derivation is running\");\n        globalState.strictMode = strict;\n        globalState.allowStateChanges = !strict;\n    }\n}\nexports.useStrict = useStrict;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res = func();\n    allowStateChangesEnd(prev);\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nfunction propagateAtomReady(atom) {\n    invariant(atom.isDirty, \"atom not dirty\");\n    atom.isDirty = false;\n    propagateReadiness(atom, true);\n}\nvar BaseAtom = (function () {\n    function BaseAtom(name) {\n        if (name === void 0) { name = \"Atom@\" + getNextId(); }\n        this.name = name;\n        this.isDirty = false;\n        this.staleObservers = [];\n        this.observers = new SimpleSet();\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {\n    };\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        if (!this.isDirty) {\n            this.reportStale();\n            this.reportReady();\n        }\n    };\n    BaseAtom.prototype.reportStale = function () {\n        if (!this.isDirty) {\n            this.isDirty = true;\n            propagateStaleness(this);\n        }\n    };\n    BaseAtom.prototype.reportReady = function () {\n        invariant(this.isDirty, \"atom not dirty\");\n        if (globalState.inTransaction > 0)\n            globalState.changedAtoms.push(this);\n        else {\n            propagateAtomReady(this);\n            runReactions();\n        }\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}());\nexports.BaseAtom = BaseAtom;\nvar Atom = (function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) { name = \"Atom@\" + getNextId(); }\n        if (onBecomeObservedHandler === void 0) { onBecomeObservedHandler = noop; }\n        if (onBecomeUnobservedHandler === void 0) { onBecomeUnobservedHandler = noop; }\n        _super.call(this, name);\n        this.name = name;\n        this.onBecomeObservedHandler = onBecomeObservedHandler;\n        this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        this.isBeingTracked = false;\n    }\n    Atom.prototype.reportObserved = function () {\n        _super.prototype.reportObserved.call(this);\n        var tracking = globalState.isTracking;\n        if (tracking && !this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        return tracking;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom));\nexports.Atom = Atom;\nvar ComputedValue = (function () {\n    function ComputedValue(derivation, scope, compareStructural, name) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.isLazy = true;\n        this.isComputing = false;\n        this.staleObservers = [];\n        this.observers = new SimpleSet();\n        this.observing = [];\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.dependencyChangeCount = 0;\n        this.dependencyStaleCount = 0;\n        this.value = undefined;\n        this.name = name || \"ComputedValue@\" + getNextId();\n    }\n    ComputedValue.prototype.peek = function () {\n        this.isComputing = true;\n        var prevAllowStateChanges = allowStateChangesStart(false);\n        var res = this.derivation.call(this.scope);\n        allowStateChangesEnd(prevAllowStateChanges);\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        clearObserving(this);\n        this.isLazy = true;\n        this.value = undefined;\n    };\n    ComputedValue.prototype.onDependenciesReady = function () {\n        var changed = this.trackAndCompute();\n        return changed;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        reportObserved(this);\n        if (this.dependencyStaleCount > 0) {\n            return this.peek();\n        }\n        if (this.isLazy) {\n            if (isComputingDerivation()) {\n                this.isLazy = false;\n                this.trackAndCompute();\n            }\n            else {\n                return this.peek();\n            }\n        }\n        return this.value;\n    };\n    ComputedValue.prototype.set = function (_) {\n        throw new Error(\"[ComputedValue '\" + name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this,\n                type: \"compute\",\n                fn: this.derivation,\n                target: this.scope\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = trackDerivedFunction(this, this.peek);\n        return valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener(newValue, prevValue);\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = globalState.derivationStack.length > 0;\n        var observing = unique(this.observing).map(function (dep) { return dep.name; });\n        var observers = unique(this.observers.asArray()).map(function (dep) { return dep.name; });\n        var runReason = (this.isComputing\n            ? isTracking\n                ? this.observers.length > 0\n                    ? RunReason.INVALIDATED\n                    : RunReason.REQUIRED\n                : RunReason.PEEK\n            : RunReason.NOT_RUNNING);\n        if (runReason === RunReason.REQUIRED) {\n            var requiredBy = globalState.derivationStack[globalState.derivationStack.length - 2];\n            if (requiredBy)\n                observers.push(requiredBy.name);\n        }\n        return ((\"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + runReasonTexts[runReason] + \" \" + ((runReason === RunReason.NOT_RUNNING) && this.dependencyStaleCount > 0 ? \"(a next run is scheduled)\" : \"\") + \"\\n\") +\n            (this.isLazy\n                ?\n                    \" * This computation is suspended (not in use by any reaction) and won't run automatically.\\n\\tDidn't expect this computation to be suspended at this point?\\n\\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\\n\"\n                :\n                    \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + ((this.isComputing && isTracking) ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\tMissing items in this list?\\n\\t  1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n\\t  2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\"));\n    };\n    return ComputedValue;\n}());\nvar RunReason;\n(function (RunReason) {\n    RunReason[RunReason[\"PEEK\"] = 0] = \"PEEK\";\n    RunReason[RunReason[\"INVALIDATED\"] = 1] = \"INVALIDATED\";\n    RunReason[RunReason[\"REQUIRED\"] = 2] = \"REQUIRED\";\n    RunReason[RunReason[\"NOT_RUNNING\"] = 3] = \"NOT_RUNNING\";\n})(RunReason || (RunReason = {}));\nvar runReasonTexts = (_a = {},\n    _a[RunReason.PEEK] = \"[peek] The value of this computed value was requested outside an reaction\",\n    _a[RunReason.INVALIDATED] = \"[invalidated] Some observables used by this computation did change\",\n    _a[RunReason.REQUIRED] = \"[started] This computation is required by another computed value / reaction\",\n    _a[RunReason.NOT_RUNNING] = \"[idle] This compution is currently not running\",\n    _a\n);\nfunction isComputingDerivation() {\n    return globalState.derivationStack.length > 0\n        && globalState.isTracking;\n}\nfunction checkIfStateModificationsAreAllowed() {\n    if (!globalState.allowStateChanges) {\n        invariant(false, globalState.strictMode\n            ? \"It is not allowed to create or change state outside an `action` when MobX is in strict mode. Wrap the current method in `action` if this state change is intended\"\n            : \"It is not allowed to change the state when a computed value or transformer is being evaluated. Use 'autorun' to create reactive functions with side-effects.\");\n    }\n}\nfunction notifyDependencyStale(derivation) {\n    if (++derivation.dependencyStaleCount === 1) {\n        propagateStaleness(derivation);\n    }\n}\nfunction notifyDependencyReady(derivation, dependencyDidChange) {\n    invariant(derivation.dependencyStaleCount > 0, \"unexpected ready notification\");\n    if (dependencyDidChange)\n        derivation.dependencyChangeCount += 1;\n    if (--derivation.dependencyStaleCount === 0) {\n        if (derivation.dependencyChangeCount > 0) {\n            derivation.dependencyChangeCount = 0;\n            var changed = derivation.onDependenciesReady();\n            propagateReadiness(derivation, changed);\n        }\n        else {\n            propagateReadiness(derivation, false);\n        }\n    }\n}\nfunction trackDerivedFunction(derivation, f) {\n    var prevObserving = derivation.observing;\n    derivation.observing = new Array(prevObserving.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    globalState.derivationStack.push(derivation);\n    var prevTracking = globalState.isTracking;\n    globalState.isTracking = true;\n    var hasException = true;\n    var result;\n    try {\n        result = f.call(derivation);\n        hasException = false;\n    }\n    finally {\n        if (hasException) {\n            var message = (\"[mobx] An uncaught exception occurred while calculating your computed value, autorun or transformer. Or inside the render() method of an observer based React component. \" +\n                \"These functions should never throw exceptions as MobX will not always be able to recover from them. \" +\n                (\"Please fix the error reported after this message or enable 'Pause on (caught) exceptions' in your debugger to find the root cause. In: '\" + derivation.name + \"'. \") +\n                \"For more details see https://github.com/mobxjs/mobx/issues/462\");\n            if (isSpyEnabled()) {\n                spyReport({\n                    type: \"error\",\n                    object: this,\n                    message: message\n                });\n            }\n            console.warn(message);\n            derivation.unboundDepsCount = 0;\n            derivation.observing = prevObserving;\n            resetGlobalState();\n        }\n        else {\n            globalState.isTracking = prevTracking;\n            globalState.derivationStack.length -= 1;\n            bindDependencies(derivation, prevObserving);\n        }\n    }\n    return result;\n}\nfunction bindDependencies(derivation, prevObserving) {\n    var prevLength = prevObserving.length;\n    var observing = derivation.observing;\n    var newLength = observing.length = derivation.unboundDepsCount;\n    for (var i = 0; i < prevLength; i++)\n        prevObserving[i].diffValue = -1;\n    for (var i = 0; i < newLength; i++) {\n        var dep = observing[i];\n        if ((++dep.diffValue) > 0) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n    for (var i = 0; i < prevLength; i++) {\n        var dep = prevObserving[i];\n        if (dep.diffValue < 0) {\n            dep.diffValue = 0;\n            removeObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var l = obs.length;\n    for (var i = 0; i < l; i++)\n        removeObserver(obs[i], derivation);\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.isTracking;\n    globalState.isTracking = false;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.isTracking = prev;\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = (function () {\n    function MobXGlobals() {\n        this.version = 3;\n        this.derivationStack = [];\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inTransaction = 0;\n        this.isTracking = false;\n        this.isRunningReactions = false;\n        this.changedAtoms = [];\n        this.pendingReactions = [];\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n    }\n    return MobXGlobals;\n}());\nvar globalState = (function () {\n    var res = new MobXGlobals();\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack)\n        throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== res.version)\n        throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal)\n        return global.__mobxGlobal;\n    return global.__mobxGlobal = res;\n})();\nfunction registerGlobals() {\n}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals)\n        if (persistentKeys.indexOf(key) === -1)\n            globalState[key] = defaultGlobals[key];\n    globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction addObserver(observable, node) {\n    observable.observers.add(node);\n}\nfunction removeObserver(observable, node) {\n    observable.observers.remove(node);\n    if (observable.observers.length === 0)\n        observable.onBecomeUnobserved();\n}\nfunction reportObserved(observable) {\n    if (globalState.isTracking === false)\n        return;\n    var derivation = globalState.derivationStack[globalState.derivationStack.length - 1];\n    if (derivation.runId !== observable.lastAccessedBy) {\n        observable.lastAccessedBy = derivation.runId;\n        derivation.observing[derivation.unboundDepsCount++] = observable;\n    }\n}\nfunction propagateStaleness(observable) {\n    var os = observable.observers.asArray();\n    var l = os.length;\n    for (var i = 0; i < l; i++)\n        notifyDependencyStale(os[i]);\n    observable.staleObservers = observable.staleObservers.concat(os);\n}\nfunction propagateReadiness(observable, valueDidActuallyChange) {\n    observable.staleObservers.splice(0).forEach(function (o) { return notifyDependencyReady(o, valueDidActuallyChange); });\n}\nvar EMPTY_DERIVATION_SET;\nvar Reaction = (function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) { name = \"Reaction@\" + getNextId(); }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.staleObservers = EMPTY_ARRAY;\n        this.observers = EMPTY_DERIVATION_SET || (EMPTY_DERIVATION_SET = new SimpleSet());\n        this.observing = [];\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.dependencyChangeCount = 0;\n        this.dependencyStaleCount = 0;\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeUnobserved = function () {\n    };\n    Reaction.prototype.onDependenciesReady = function () {\n        this.schedule();\n        return false;\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this.dependencyStaleCount > 0 || this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            this._isScheduled = false;\n            this._isTrackPending = true;\n            this.onInvalidate();\n            if (this._isTrackPending && isSpyEnabled()) {\n                spyReport({\n                    object: this,\n                    type: \"scheduled-reaction\"\n                });\n            }\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        trackDerivedFunction(this, fn);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning)\n                clearObserving(this);\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this.observing).map(function (dep) { return dep.name; });\n        return (\"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + ((this._isRunning) ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\tMissing items in this list?\\n\\t  1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n\\t  2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\");\n    };\n    return Reaction;\n}());\nexports.Reaction = Reaction;\nvar MAX_REACTION_ITERATIONS = 100;\nfunction runReactions() {\n    if (globalState.isRunningReactions === true || globalState.inTransaction > 0)\n        return;\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS)\n            throw new Error(\"Reaction doesn't converge to a stable state. Probably there is a cycle in the reactive function: \" + allReactions[0].toString());\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++)\n            remainingReactions[i].runReaction();\n    }\n    globalState.isRunningReactions = false;\n}\nvar spyEnabled = false;\nfunction isSpyEnabled() {\n    return spyEnabled;\n}\nfunction spyReport(event) {\n    if (!spyEnabled)\n        return false;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++)\n        listeners[i](event);\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change)\n        spyReport(objectAssign({}, change, END_EVENT));\n    else\n        spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    spyEnabled = globalState.spyListeners.length > 0;\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1)\n            globalState.spyListeners.splice(idx, 1);\n        spyEnabled = globalState.spyListeners.length > 0;\n    });\n}\nexports.spy = spy;\nfunction trackTransitions(onReport) {\n    deprecated(\"trackTransitions is deprecated. Use mobx.spy instead\");\n    if (typeof onReport === \"boolean\") {\n        deprecated(\"trackTransitions only takes a single callback function. If you are using the mobx-react-devtools, please update them first\");\n        onReport = arguments[1];\n    }\n    if (!onReport) {\n        deprecated(\"trackTransitions without callback has been deprecated and is a no-op now. If you are using the mobx-react-devtools, please update them first\");\n        return function () { };\n    }\n    return spy(onReport);\n}\nfunction transaction(action, thisArg, report) {\n    if (thisArg === void 0) { thisArg = undefined; }\n    if (report === void 0) { report = true; }\n    transactionStart((action.name) || \"anonymous transaction\", thisArg, report);\n    var res = action.call(thisArg);\n    transactionEnd(report);\n    return res;\n}\nexports.transaction = transaction;\nfunction transactionStart(name, thisArg, report) {\n    if (thisArg === void 0) { thisArg = undefined; }\n    if (report === void 0) { report = true; }\n    globalState.inTransaction += 1;\n    if (report && isSpyEnabled()) {\n        spyReportStart({\n            type: \"transaction\",\n            target: thisArg,\n            name: name\n        });\n    }\n}\nfunction transactionEnd(report) {\n    if (report === void 0) { report = true; }\n    if (--globalState.inTransaction === 0) {\n        var values = globalState.changedAtoms.splice(0);\n        for (var i = 0, l = values.length; i < l; i++)\n            propagateAtomReady(values[i]);\n        runReactions();\n    }\n    if (report && isSpyEnabled())\n        spyReportEnd();\n}\nfunction hasInterceptors(interceptable) {\n    return (interceptable.interceptors && interceptable.interceptors.length > 0);\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1)\n            interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    var interceptors = interceptable.interceptors;\n    for (var i = 0, l = interceptors.length; i < l; i++) {\n        change = interceptors[i](change);\n        invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n        if (!change)\n            return null;\n    }\n    untrackedEnd(prevU);\n    return change;\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1)\n            listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        if (Array.isArray(change)) {\n            listeners[i].apply(null, change);\n        }\n        else {\n            listeners[i](change);\n        }\n    }\n    untrackedEnd(prevU);\n}\nvar ValueMode;\n(function (ValueMode) {\n    ValueMode[ValueMode[\"Recursive\"] = 0] = \"Recursive\";\n    ValueMode[ValueMode[\"Reference\"] = 1] = \"Reference\";\n    ValueMode[ValueMode[\"Structure\"] = 2] = \"Structure\";\n    ValueMode[ValueMode[\"Flat\"] = 3] = \"Flat\";\n})(ValueMode || (ValueMode = {}));\nfunction asReference(value) {\n    return new AsReference(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    return new AsStructure(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    return new AsFlat(value);\n}\nexports.asFlat = asFlat;\nvar AsReference = (function () {\n    function AsReference(value) {\n        this.value = value;\n        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n    }\n    return AsReference;\n}());\nvar AsStructure = (function () {\n    function AsStructure(value) {\n        this.value = value;\n        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n    }\n    return AsStructure;\n}());\nvar AsFlat = (function () {\n    function AsFlat(value) {\n        this.value = value;\n        assertUnwrapped(value, \"Modifiers are not allowed to be nested\");\n    }\n    return AsFlat;\n}());\nfunction asMap(data, modifierFunc) {\n    return map(data, modifierFunc);\n}\nexports.asMap = asMap;\nfunction getValueModeFromValue(value, defaultMode) {\n    if (value instanceof AsReference)\n        return [ValueMode.Reference, value.value];\n    if (value instanceof AsStructure)\n        return [ValueMode.Structure, value.value];\n    if (value instanceof AsFlat)\n        return [ValueMode.Flat, value.value];\n    return [defaultMode, value];\n}\nfunction getValueModeFromModifierFunc(func) {\n    if (func === asReference)\n        return ValueMode.Reference;\n    else if (func === asStructure)\n        return ValueMode.Structure;\n    else if (func === asFlat)\n        return ValueMode.Flat;\n    invariant(func === undefined, \"Cannot determine value mode from function. Please pass in one of these: mobx.asReference, mobx.asStructure or mobx.asFlat, got: \" + func);\n    return ValueMode.Recursive;\n}\nfunction makeChildObservable(value, parentMode, name) {\n    var childMode;\n    if (isObservable(value))\n        return value;\n    switch (parentMode) {\n        case ValueMode.Reference:\n            return value;\n        case ValueMode.Flat:\n            assertUnwrapped(value, \"Items inside 'asFlat' cannot have modifiers\");\n            childMode = ValueMode.Reference;\n            break;\n        case ValueMode.Structure:\n            assertUnwrapped(value, \"Items inside 'asStructure' cannot have modifiers\");\n            childMode = ValueMode.Structure;\n            break;\n        case ValueMode.Recursive:\n            _a = getValueModeFromValue(value, ValueMode.Recursive), childMode = _a[0], value = _a[1];\n            break;\n        default:\n            invariant(false, \"Illegal State\");\n    }\n    if (Array.isArray(value))\n        return createObservableArray(value, childMode, name);\n    if (isPlainObject(value) && Object.isExtensible(value))\n        return extendObservableHelper(value, value, childMode, name);\n    return value;\n    var _a;\n}\nfunction assertUnwrapped(value, message) {\n    if (value instanceof AsReference || value instanceof AsStructure || value instanceof AsFlat)\n        throw new Error(\"[mobx] asStructure / asReference / asFlat cannot be used here. \" + message);\n}\nvar safariPrototypeSetterInheritanceBug = (function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function () { v = true; } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n})();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = (function () {\n    function StubArray() {\n    }\n    return StubArray;\n}());\nStubArray.prototype = [];\nvar ObservableArrayAdministration = (function () {\n    function ObservableArrayAdministration(name, mode, array, owned) {\n        this.mode = mode;\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || (\"ObservableArray@\" + getNextId()));\n    }\n    ObservableArrayAdministration.prototype.makeReactiveArrayItem = function (value) {\n        assertUnwrapped(value, \"Array values cannot have modifiers\");\n        if (this.mode === ValueMode.Flat || this.mode === ValueMode.Reference)\n            return value;\n        return makeChildObservable(value, this.mode, this.atom.name + \"[..]\");\n    };\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) { fireImmediately = false; }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0)\n            throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength)\n            return;\n        else if (newLength > currentLength)\n            this.spliceWithArray(currentLength, 0, new Array(newLength - currentLength));\n        else\n            this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength)\n            throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE)\n            reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        checkIfStateModificationsAreAllowed();\n        var length = this.values.length;\n        if (index === undefined)\n            index = 0;\n        else if (index > length)\n            index = length;\n        else if (index < 0)\n            index = Math.max(0, length + index);\n        if (arguments.length === 1)\n            deleteCount = length - index;\n        else if (deleteCount === undefined || deleteCount === null)\n            deleteCount = 0;\n        else\n            deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined)\n            newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change)\n                return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(this.makeReactiveArrayItem, this);\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        if (deleteCount !== 0 || newItems.length !== 0)\n            this.notifyArraySplice(index, newItems, res);\n        return res;\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy)\n            spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify)\n            notifyListeners(this, change);\n        if (notifySpy)\n            spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy)\n            spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify)\n            notifyListeners(this, change);\n        if (notifySpy)\n            spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}());\nvar ObservableArray = (function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, mode, name, owned) {\n        if (owned === void 0) { owned = false; }\n        _super.call(this);\n        var adm = new ObservableArrayAdministration(name, mode, this, owned);\n        addHiddenFinalProp(this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(adm.makeReactiveArrayItem, adm);\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        }\n        else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) { fireImmediately = false; }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i - 0] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.slice(), arrays.map(function (a) { return isObservableArray(a) ? a.slice() : a; }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) { fromIndex = 0; }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values, l = items.length;\n        for (var i = fromIndex; i < l; i++)\n            if (predicate.call(thisArg, items[i], i, this))\n                return items[i];\n        return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i - 0] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i - 0] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.toString = function () {\n        return \"[mobx.array] \" + Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        return \"[mobx.array] \" + Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray));\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\n    \"constructor\",\n    \"observe\",\n    \"clear\",\n    \"concat\",\n    \"replace\",\n    \"toJSON\",\n    \"peek\",\n    \"find\",\n    \"splice\",\n    \"push\",\n    \"pop\",\n    \"shift\",\n    \"unshift\",\n    \"reverse\",\n    \"sort\",\n    \"remove\",\n    \"toString\",\n    \"toLocaleString\"\n]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function () {\n        return this.$mobx.getArrayLength();\n    },\n    set: function (newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\n    \"every\",\n    \"filter\",\n    \"forEach\",\n    \"indexOf\",\n    \"join\",\n    \"lastIndexOf\",\n    \"map\",\n    \"reduce\",\n    \"reduceRight\",\n    \"slice\",\n    \"some\"\n].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        assertUnwrapped(newValue, \"Modifiers cannot be used on array values. For non-reactive array values use makeReactive(asFlat(array)).\");\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed();\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change)\n                    return;\n                newValue = change.newValue;\n            }\n            newValue = adm.makeReactiveArrayItem(newValue);\n            var changed = (adm.mode === ValueMode.Structure) ? !deepEquals(oldValue, newValue) : oldValue !== newValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        }\n        else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        }\n        else\n            throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl && index < impl.values.length) {\n            impl.atom.reportObserved();\n            return impl.values[index];\n        }\n        console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++)\n        createArrayBufferItem(index);\n    OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nfunction createObservableArray(initialValues, mode, name) {\n    return new ObservableArray(initialValues, mode, name);\n}\nfunction fastArray(initialValues) {\n    deprecated(\"fastArray is deprecated. Please use `observable(asFlat([]))`\");\n    return createObservableArray(initialValues, ValueMode.Flat, null);\n}\nexports.fastArray = fastArray;\nfunction isObservableArray(thing) {\n    return thing instanceof ObservableArray;\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = (function () {\n    function ObservableMap(initialData, valueModeFunc) {\n        var _this = this;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this.name = \"ObservableMap@\" + getNextId();\n        this._keys = new ObservableArray(null, ValueMode.Reference, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this._valueMode = getValueModeFromModifierFunc(valueModeFunc);\n        if (this._valueMode === ValueMode.Flat)\n            this._valueMode = ValueMode.Reference;\n        allowStateChanges(true, function () {\n            if (isPlainObject(initialData))\n                _this.merge(initialData);\n            else if (Array.isArray(initialData))\n                initialData.forEach(function (_a) {\n                    var key = _a[0], value = _a[1];\n                    return _this.set(key, value);\n                });\n        });\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key))\n            return false;\n        key = \"\" + key;\n        if (this._hasMap[key])\n            return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        assertUnwrapped(value, \"[mobx.map.set] Expected unwrapped value to be inserted to key '\" + key + \"'. If you need to use modifiers pass them as second argument to the constructor\");\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change)\n                return;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        }\n        else {\n            this._addValue(key, value);\n        }\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change)\n                return;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy)\n                spyReportStart(change);\n            transaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            }, undefined, false);\n            if (notify)\n                notifyListeners(this, change);\n            if (notifySpy)\n                spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        }\n        else {\n            entry = this._hasMap[key] = new ObservableValue(value, ValueMode.Reference, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy)\n                spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify)\n                notifyListeners(this, change);\n            if (notifySpy)\n                spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        transaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this._valueMode, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        }, undefined, false);\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy)\n            spyReportStart(change);\n        if (notify)\n            notifyListeners(this, change);\n        if (notifySpy)\n            spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key))\n            return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) { return [key, _this.get(key)]; }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) { return callback.call(thisArg, _this.get(key), key); });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        transaction(function () {\n            if (other instanceof ObservableMap)\n                other.keys().forEach(function (key) { return _this.set(key, other.get(key)); });\n            else\n                Object.keys(other).forEach(function (key) { return _this.set(key, other[key]); });\n        }, undefined, false);\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        transaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        }, undefined, false);\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function () {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) { return res[key] = _this.get(key); });\n        return res;\n    };\n    ObservableMap.prototype.toJs = function () {\n        deprecated(\"toJs is deprecated, use toJS instead\");\n        return this.toJS();\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined)\n            return false;\n        if (typeof key !== \"string\" && typeof key !== \"number\" && typeof key !== \"boolean\")\n            return false;\n        return true;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key))\n            throw new Error(\"[mobx.map] Invalid key: '\" + key + \"'\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) { return (key + \": \" + (\"\" + _this.get(key))); }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable maps.\");\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}());\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues, valueModifier) {\n    return new ObservableMap(initialValues, valueModifier);\n}\nexports.map = map;\nfunction isObservableMap(thing) {\n    return thing instanceof ObservableMap;\n}\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = (function () {\n    function ObservableObjectAdministration(target, name, mode) {\n        this.target = target;\n        this.name = name;\n        this.mode = mode;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}());\nfunction asObservableObject(target, name, mode) {\n    if (mode === void 0) { mode = ValueMode.Recursive; }\n    if (isObservableObject(target))\n        return target.$mobx;\n    if (!isPlainObject(target))\n        name = target.constructor.name + \"@\" + getNextId();\n    if (!name)\n        name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name, mode);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction setObservableObjectInstanceProperty(adm, propName, value) {\n    if (adm.values[propName])\n        adm.target[propName] = value;\n    else\n        defineObservableProperty(adm, propName, value, true);\n}\nfunction defineObservableProperty(adm, propName, newValue, asInstanceProperty) {\n    if (asInstanceProperty)\n        assertPropertyConfigurable(adm.target, propName);\n    var observable;\n    var name = adm.name + \".\" + propName;\n    var isComputed = true;\n    if (typeof newValue === \"function\" && newValue.length === 0 && !isAction(newValue))\n        observable = new ComputedValue(newValue, adm.target, false, name);\n    else if (newValue instanceof AsStructure && typeof newValue.value === \"function\" && newValue.value.length === 0)\n        observable = new ComputedValue(newValue.value, adm.target, true, name);\n    else {\n        isComputed = false;\n        if (hasInterceptors(adm)) {\n            var change = interceptChange(adm, {\n                object: adm.target,\n                name: propName,\n                type: \"add\",\n                newValue: newValue\n            });\n            if (!change)\n                return;\n            newValue = change.newValue;\n        }\n        observable = new ObservableValue(newValue, adm.mode, name, false);\n        newValue = observable.value;\n    }\n    adm.values[propName] = observable;\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, isComputed ? generateComputedPropConfig(propName) : generateObservablePropConfig(propName));\n    }\n    if (!isComputed)\n        notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    var config = observablePropertyConfigs[propName];\n    if (config)\n        return config;\n    return observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            return this.$mobx.values[propName].get();\n        },\n        set: function (v) {\n            setPropertyValue(this, propName, v);\n        }\n    };\n}\nfunction generateComputedPropConfig(propName) {\n    var config = computedPropertyConfigs[propName];\n    if (config)\n        return config;\n    return computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function () {\n            return this.$mobx.values[propName].get();\n        },\n        set: throwingComputedValueSetter\n    };\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change)\n            return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notifyListeners || hasListeners ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy)\n            spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify)\n            notifyListeners(adm, change);\n        if (notifySpy)\n            spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy)\n        spyReportStart(change);\n    if (notify)\n        notifyListeners(adm, change);\n    if (notifySpy)\n        spyReportEnd();\n}\nfunction isObservableObject(thing) {\n    if (typeof thing === \"object\" && thing !== null) {\n        runLazyInitializers(thing);\n        return thing.$mobx instanceof ObservableObjectAdministration;\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = (function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, mode, name, notifySpy) {\n        if (name === void 0) { name = \"ObservableValue@\" + getNextId(); }\n        if (notifySpy === void 0) { notifySpy = true; }\n        _super.call(this, name);\n        this.mode = mode;\n        this.hasUnreportedChange = false;\n        this.value = undefined;\n        var _a = getValueModeFromValue(value, ValueMode.Recursive), childmode = _a[0], unwrappedValue = _a[1];\n        if (this.mode === ValueMode.Recursive)\n            this.mode = childmode;\n        this.value = makeChildObservable(unwrappedValue, this.mode, this.name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: this, newValue: this.value });\n        }\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy)\n                spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        assertUnwrapped(newValue, \"Modifiers cannot be used on non-initial values.\");\n        checkIfStateModificationsAreAllowed();\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change)\n                return UNCHANGED;\n            newValue = change.newValue;\n        }\n        var changed = valueDidChange(this.mode === ValueMode.Structure, this.value, newValue);\n        if (changed)\n            return makeChildObservable(newValue, this.mode, this.name);\n        return UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this))\n            notifyListeners(this, [newValue, oldValue]);\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately)\n            listener(this.value, undefined);\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    return ObservableValue;\n}(BaseAtom));\nfunction getAtom(thing, property) {\n    if (typeof thing === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, \"It is not possible to get index atoms from arrays\");\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            if (property === undefined)\n                return getAtom(thing._keys);\n            var observable_1 = thing._data[property] || thing._hasMap[property];\n            invariant(!!observable_1, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_1;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            invariant(!!property, \"please specify a property\");\n            var observable_2 = thing.$mobx.values[property];\n            invariant(!!observable_2, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        if (thing instanceof BaseAtom || thing instanceof ComputedValue || thing instanceof Reaction) {\n            return thing;\n        }\n    }\n    else if (typeof thing === \"function\") {\n        if (thing.$mobx instanceof Reaction) {\n            return thing.$mobx;\n        }\n    }\n    invariant(false, \"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expection some object\");\n    if (property !== undefined)\n        return getAdministration(getAtom(thing, property));\n    if (thing instanceof BaseAtom || thing instanceof ComputedValue || thing instanceof Reaction)\n        return thing;\n    if (isObservableMap(thing))\n        return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx)\n        return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined)\n        named = getAtom(thing, property);\n    else if (isObservableObject(thing) || isObservableMap(thing))\n        named = getAdministration(thing);\n    else\n        named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, get, set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs) {\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function () {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true)\n                        typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return get.call(this, key);\n                },\n                set: function (v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    }\n                    else {\n                        set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        }\n        else {\n            if (!target.hasOwnProperty(\"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", (target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice()) || []);\n            }\n            var value_1 = descriptor.value, initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, (initializer_1 ? initializer_1.call(instance) : value_1), customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function () {\n                    if (this.__mobxDidRunLazyInitializers !== true)\n                        runLazyInitializers(this);\n                    return get.call(this, key);\n                },\n                set: function (v) {\n                    if (this.__mobxDidRunLazyInitializers !== true)\n                        runLazyInitializers(this);\n                    set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments))\n                return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            return function (target, key, descriptor) { return classPropertyDecorator(target, key, descriptor, outerArgs); };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!instance.hasOwnProperty(\"__mobxInitializedProps\"))\n        addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true)\n        return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) { return initializer(instance); });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return (typeof Symbol === \"function\" && Symbol.iterator) || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar SimpleSet = (function () {\n    function SimpleSet() {\n        this.size = 0;\n        this.data = {};\n    }\n    Object.defineProperty(SimpleSet.prototype, \"length\", {\n        get: function () {\n            return this.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SimpleSet.prototype.asArray = function () {\n        var res = new Array(this.size);\n        var i = 0;\n        for (var key in this.data) {\n            res[i] = this.data[key];\n            i++;\n        }\n        return res;\n    };\n    SimpleSet.prototype.add = function (value) {\n        var m = value.__mapid;\n        if (!(m in this.data)) {\n            this.data[m] = value;\n            this.size++;\n        }\n    };\n    SimpleSet.prototype.remove = function (value) {\n        if (value.__mapid in this.data) {\n            delete this.data[value.__mapid];\n            this.size--;\n        }\n    };\n    return SimpleSet;\n}());\nexports.SimpleSet = SimpleSet;\nvar SimpleEventEmitter = (function () {\n    function SimpleEventEmitter() {\n        this.listeners = [];\n        deprecated(\"extras.SimpleEventEmitter is deprecated and will be removed in the next major release\");\n    }\n    SimpleEventEmitter.prototype.emit = function () {\n        var listeners = this.listeners.slice();\n        for (var i = 0, l = listeners.length; i < l; i++)\n            listeners[i].apply(null, arguments);\n    };\n    SimpleEventEmitter.prototype.on = function (listener) {\n        var _this = this;\n        this.listeners.push(listener);\n        return once(function () {\n            var idx = _this.listeners.indexOf(listener);\n            if (idx !== -1)\n                _this.listeners.splice(idx, 1);\n        });\n    };\n    SimpleEventEmitter.prototype.once = function (listener) {\n        var subscription = this.on(function () {\n            subscription();\n            listener.apply(this, arguments);\n        });\n        return subscription;\n    };\n    return SimpleEventEmitter;\n}());\nexports.SimpleEventEmitter = SimpleEventEmitter;\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction invariant(check, message, thing) {\n    if (!check)\n        throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1)\n        return;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked)\n            return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function () { };\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1)\n            res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) { limit = 100; }\n    if (separator === void 0) { separator = \" - \"; }\n    if (!things)\n        return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isPlainObject(value) {\n    return value !== null && typeof value === \"object\" && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source)\n            if (source.hasOwnProperty(key)) {\n                res[key] = source[key];\n            }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    return compareStructural\n        ? !deepEquals(oldValue, newValue)\n        : oldValue !== newValue;\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: false,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || (descriptor.configurable !== false && descriptor.writable !== false);\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj)\n        res.push(key);\n    return res;\n}\nfunction deepEquals(a, b) {\n    if (a === null && b === null)\n        return true;\n    if (a === undefined && b === undefined)\n        return true;\n    var aIsArray = Array.isArray(a) || isObservableArray(a);\n    if (aIsArray !== (Array.isArray(b) || isObservableArray(b))) {\n        return false;\n    }\n    else if (aIsArray) {\n        if (a.length !== b.length)\n            return false;\n        for (var i = a.length - 1; i >= 0; i--)\n            if (!deepEquals(a[i], b[i]))\n                return false;\n        return true;\n    }\n    else if (typeof a === \"object\" && typeof b === \"object\") {\n        if (a === null || b === null)\n            return false;\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length)\n            return false;\n        for (var prop in a) {\n            if (!(prop in b))\n                return false;\n            if (!deepEquals(a[prop], b[prop]))\n                return false;\n        }\n        return true;\n    }\n    return a === b;\n}\nvar _a;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/mobx/lib/mobx.js\n **/","'use strict';\n\nmodule.exports = require('inferno/dist/inferno');\n\n\n/** WEBPACK FOOTER **\n ** ./~/inferno/inferno.js\n **/","/*!\n * inferno v0.7.25\n * (c) 2016 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.Inferno = factory());\n}(this, function () { 'use strict';\n\n\t// Runs only once in applications lifetime\n\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\n\tfunction isNullOrUndefined(obj) {\n\t\treturn isUndefined(obj) || isNull(obj);\n\t}\n\n\tfunction isAttrAnEvent$1(attr) {\n\t\treturn attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n\t}\n\n\tfunction isNull(obj) {\n\t\treturn obj === null;\n\t}\n\n\tfunction isUndefined(obj) {\n\t\treturn obj === undefined;\n\t}\n\n\tfunction VNode(blueprint) {\n\t\tthis.bp = blueprint;\n\t\tthis.dom = null;\n\t\tthis.instance = null;\n\t\tthis.tag = null;\n\t\tthis.children = null;\n\t\tthis.style = null;\n\t\tthis.className = null;\n\t\tthis.attrs = null;\n\t\tthis.events = null;\n\t\tthis.hooks = null;\n\t\tthis.key = null;\n\t\tthis.clipData = null;\n\t}\n\n\tVNode.prototype = {\n\t\tsetAttrs: function setAttrs(attrs) {\n\t\t\tthis.attrs = attrs;\n\t\t\treturn this;\n\t\t},\n\t\tsetTag: function setTag(tag) {\n\t\t\tthis.tag = tag;\n\t\t\treturn this;\n\t\t},\n\t\tsetStyle: function setStyle(style) {\n\t\t\tthis.style = style;\n\t\t\treturn this;\n\t\t},\n\t\tsetClassName: function setClassName(className) {\n\t\t\tthis.className = className;\n\t\t\treturn this;\n\t\t},\n\t\tsetChildren: function setChildren(children) {\n\t\t\tthis.children = children;\n\t\t\treturn this;\n\t\t},\n\t\tsetHooks: function setHooks(hooks) {\n\t\t\tthis.hooks = hooks;\n\t\t\treturn this;\n\t\t},\n\t\tsetEvents: function setEvents(events) {\n\t\t\tthis.events = events;\n\t\t\treturn this;\n\t\t},\n\t\tsetKey: function setKey(key) {\n\t\t\tthis.key = key;\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tfunction createVNode(bp) {\n\t\treturn new VNode(bp);\n\t}\n\n\tfunction isAttrAnEvent(attr) {\n\t\treturn attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n\t}\n\n\tfunction isAttrAHook(hook) {\n\t\treturn hook === 'onCreated'\n\t\t\t|| hook === 'onAttached'\n\t\t\t|| hook === 'onWillDetach'\n\t\t\t|| hook === 'onWillUpdate'\n\t\t\t|| hook === 'onDidUpdate';\n\t}\n\n\tfunction isAttrAComponentHook(hook) {\n\t\treturn hook === 'onComponentWillMount'\n\t\t\t|| hook === 'onComponentDidMount'\n\t\t\t|| hook === 'onComponentWillUnmount'\n\t\t\t|| hook === 'onComponentShouldUpdate'\n\t\t\t|| hook === 'onComponentWillUpdate'\n\t\t\t|| hook === 'onComponentDidUpdate';\n\t}\n\n\n\tfunction createBlueprint(shape, childrenType) {\n\t\tvar tag = shape.tag || null;\n\t\tvar tagIsDynamic = tag && tag.arg !== undefined ? true : false;\n\n\t\tvar children = isNullOrUndefined(shape.children) ? null : shape.children;\n\t\tvar childrenIsDynamic = children && children.arg !== undefined ? true : false;\n\n\t\tvar attrs = shape.attrs || null;\n\t\tvar attrsIsDynamic = attrs && attrs.arg !== undefined ? true : false;\n\n\t\tvar hooks = shape.hooks || null;\n\t\tvar hooksIsDynamic = hooks && hooks.arg !== undefined ? true : false;\n\n\t\tvar events = shape.events || null;\n\t\tvar eventsIsDynamic = events && events.arg !== undefined ? true : false;\n\n\t\tvar key = shape.key === undefined ? null : shape.key;\n\t\tvar keyIsDynamic = !isNullOrUndefined(key) && !isNullOrUndefined(key.arg);\n\n\t\tvar style = shape.style || null;\n\t\tvar styleIsDynamic = style && style.arg !== undefined ? true : false;\n\n\t\tvar className = shape.className === undefined ? null : shape.className;\n\t\tvar classNameIsDynamic = className && className.arg !== undefined ? true : false;\n\n\t\tvar spread = shape.spread === undefined ? null : shape.spread;\n\t\tvar hasSpread = shape.spread !== undefined;\n\n\t\tvar blueprint = {\n\t\t\tlazy: shape.lazy || false,\n\t\t\tdom: null,\n\t\t\tpool: [],\n\t\t\ttag: tagIsDynamic ? null : tag,\n\t\t\tclassName: className !== '' && className ? className : null,\n\t\t\tstyle: style !== '' && style ? style : null,\n\t\t\tisComponent: tagIsDynamic,\n\t\t\thasAttrs: attrsIsDynamic || (attrs ? true : false),\n\t\t\thasHooks: hooksIsDynamic,\n\t\t\thasEvents: eventsIsDynamic,\n\t\t\thasStyle: styleIsDynamic || (style !== '' && style ? true : false),\n\t\t\thasClassName: classNameIsDynamic || (className !== '' && className ? true : false),\n\t\t\tchildrenType: childrenType === undefined ? (children ? 5 : 0) : childrenType,\n\t\t\tattrKeys: null,\n\t\t\teventKeys: null,\n\t\t\tisSVG: shape.isSVG || false\n\t\t};\n\n\t\treturn function () {\n\t\t\tvar vNode = new VNode(blueprint);\n\n\t\t\tif (tagIsDynamic === true) {\n\t\t\t\tvNode.tag = arguments[tag.arg];\n\t\t\t}\n\t\t\tif (childrenIsDynamic === true) {\n\t\t\t\tvNode.children = arguments[children.arg];\n\t\t\t}\n\t\t\tif (hasSpread) {\n\t\t\t\tvar _spread = arguments[spread.arg];\n\t\t\t\tvar attrs$1;\n\t\t\t\tvar events$1;\n\t\t\t\tvar hooks$1;\n\t\t\t\tvar attrKeys = [];\n\t\t\t\tvar eventKeys = [];\n\n\t\t\t\tfor (var prop in _spread) {\n\t\t\t\t\tvar value = _spread[prop];\n\n\t\t\t\t\tif (prop === 'className' || (prop === 'class' && !blueprint.isSVG)) {\n\t\t\t\t\t\tvNode.className = value;\n\t\t\t\t\t\tblueprint.hasClassName = true;\n\t\t\t\t\t} else if (prop === 'style') {\n\t\t\t\t\t\tvNode.style = value;\n\t\t\t\t\t\tblueprint.hasStyle = true;\n\t\t\t\t\t} else if (prop === 'key') {\n\t\t\t\t\t\tvNode.key = value;\n\t\t\t\t\t} else if (isAttrAHook(prop) || isAttrAComponentHook(prop)) {\n\t\t\t\t\t\tif (!hooks$1) {\n\t\t\t\t\t\t\thooks$1 = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\thooks$1[prop[2].toLowerCase() + prop.substring(3)] = value;\n\t\t\t\t\t} else if (isAttrAnEvent(prop)) {\n\t\t\t\t\t\tif (!events$1) {\n\t\t\t\t\t\t\tevents$1 = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\teventKeys.push(prop.toLowerCase());\n\t\t\t\t\t\tevents$1[prop.toLowerCase()] = value;\n\t\t\t\t\t} else if (prop === 'children') {\n\t\t\t\t\t\tvNode.children = value;\n\t\t\t\t\t\tblueprint.childrenType = blueprint.childrenType || 5;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!attrs$1) {\n\t\t\t\t\t\t\tattrs$1 = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattrKeys.push(prop);\n\t\t\t\t\t\tattrs$1[prop] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (attrs$1) {\n\t\t\t\t\tvNode.attrs = attrs$1;\n\t\t\t\t\tblueprint.attrKeys = attrKeys;\n\t\t\t\t\tblueprint.hasAttrs = true;\n\t\t\t\t}\n\t\t\t\tif (events$1) {\n\t\t\t\t\tvNode.events = events$1;\n\t\t\t\t\tblueprint.eventKeys = eventKeys;\n\t\t\t\t\tblueprint.hasEvents = true;\n\t\t\t\t}\n\t\t\t\tif (hooks$1) {\n\t\t\t\t\tvNode.hooks = hooks$1;\n\t\t\t\t\tblueprint.hasHooks = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (attrsIsDynamic === true) {\n\t\t\t\t\tvNode.attrs = arguments[attrs.arg];\n\t\t\t\t} else {\n\t\t\t\t\tvNode.attrs = attrs;\n\t\t\t\t}\n\t\t\t\tif (hooksIsDynamic === true) {\n\t\t\t\t\tvNode.hooks = arguments[hooks.arg];\n\t\t\t\t}\n\t\t\t\tif (eventsIsDynamic === true) {\n\t\t\t\t\tvNode.events = arguments[events.arg];\n\t\t\t\t}\n\t\t\t\tif (keyIsDynamic === true) {\n\t\t\t\t\tvNode.key = arguments[key.arg];\n\t\t\t\t} else {\n\t\t\t\t\tvNode.key = key;\n\t\t\t\t}\n\t\t\t\tif (styleIsDynamic === true) {\n\t\t\t\t\tvNode.style = arguments[style.arg];\n\t\t\t\t} else {\n\t\t\t\t\tvNode.style = blueprint.style;\n\t\t\t\t}\n\t\t\t\tif (classNameIsDynamic === true) {\n\t\t\t\t\tvNode.className = arguments[className.arg];\n\t\t\t\t} else {\n\t\t\t\t\tvNode.className = blueprint.className;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vNode;\n\t\t};\n\t}\n\n\tfunction VText(text) {\n\t\tthis.text = text;\n\t\tthis.dom = null;\n\t}\n\n\tfunction createVText(text) {\n\t\treturn new VText(text);\n\t}\n\n\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\tfunction documentCreateElement(tag, isSVG) {\n\t\tvar dom;\n\n\t\tif (isSVG === true) {\n\t\t\tdom = document.createElementNS('http://www.w3.org/2000/svg', tag);\n\t\t} else {\n\t\t\tdom = document.createElement(tag);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction createUniversalElement(tag, attrs, isSVG) {\n\t\tif (isBrowser) {\n\t\t\tvar dom = documentCreateElement(tag, isSVG);\n\t\t\tif (attrs) {\n\t\t\t\tcreateStaticAttributes(attrs, dom);\n\t\t\t}\n\t\t\treturn dom;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction createStaticAttributes(attrs, dom) {\n\t\tvar attrKeys = Object.keys(attrs);\n\n\t\tfor (var i = 0; i < attrKeys.length; i++) {\n\t\t\tvar attr = attrKeys[i];\n\t\t\tvar value = attrs[attr];\n\n\t\t\tif (attr === 'className') {\n\t\t\t\tdom.className = value;\n\t\t\t} else {\n\t\t\t\tif (value === true) {\n\t\t\t\t\tdom.setAttribute(attr, attr);\n\t\t\t\t} else if (!isNullOrUndefined(value) && value !== false && !isAttrAnEvent$1(attr)) {\n\t\t\t\t\tdom.setAttribute(attr, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar index = {\n\t\tcreateBlueprint: createBlueprint,\n\t\tcreateVNode: createVNode,\n\t\tcreateVText: createVText,\n\t\tuniversal: {\n\t\t\tcreateElement: createUniversalElement\n\t\t}\n\t};\n\n\treturn index;\n\n}));\n\n\n/** WEBPACK FOOTER **\n ** ./~/inferno/dist/inferno.js\n **/","'use strict';\r\n\r\nmodule.exports = require('inferno/dist/inferno-dom');\n\n\n/** WEBPACK FOOTER **\n ** ./~/inferno-dom/inferno-dom.js\n **/","/*!\n * inferno-dom v0.7.25\n * (c) 2016 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.InfernoDOM = factory());\n}(this, function () { 'use strict';\n\n\tfunction addChildrenToProps(children, props) {\n\t\tif (!isNullOrUndefined(children)) {\n\t\t\tvar isChildrenArray = isArray(children);\n\t\t\tif (isChildrenArray && children.length > 0 || !isChildrenArray) {\n\t\t\t\tif (props) {\n\t\t\t\t\tprops = Object.assign({}, props, { children: children });\n\t\t\t\t} else {\n\t\t\t\t\tprops = {\n\t\t\t\t\t\tchildren: children\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn props;\n\t}\n\n\tvar NO_RENDER = 'NO_RENDER';\n\n\t// Runs only once in applications lifetime\n\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\n\tfunction isArray(obj) {\n\t\treturn obj instanceof Array;\n\t}\n\n\tfunction isStatefulComponent(obj) {\n\t\treturn obj.prototype && obj.prototype.render !== undefined;\n\t}\n\n\tfunction isStringOrNumber(obj) {\n\t\treturn isString(obj) || isNumber(obj);\n\t}\n\n\tfunction isNullOrUndefined(obj) {\n\t\treturn isUndefined(obj) || isNull(obj);\n\t}\n\n\tfunction isInvalidNode(obj) {\n\t\treturn isNull(obj) || obj === false || obj === true || isUndefined(obj);\n\t}\n\n\tfunction isFunction(obj) {\n\t\treturn typeof obj === 'function';\n\t}\n\n\tfunction isString(obj) {\n\t\treturn typeof obj === 'string';\n\t}\n\n\tfunction isNumber(obj) {\n\t\treturn typeof obj === 'number';\n\t}\n\n\tfunction isNull(obj) {\n\t\treturn obj === null;\n\t}\n\n\tfunction isTrue(obj) {\n\t\treturn obj === true;\n\t}\n\n\tfunction isUndefined(obj) {\n\t\treturn obj === undefined;\n\t}\n\n\tfunction deepScanChildrenForNode(children, node) {\n\t\tif (!isInvalidNode(children)) {\n\t\t\tif (isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i];\n\n\t\t\t\t\tif (!isInvalidNode(child)) {\n\t\t\t\t\t\tif (child === node) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else if (child.children) {\n\t\t\t\t\t\t\treturn deepScanChildrenForNode(child.children, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (children === node) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (children.children) {\n\t\t\t\t\treturn deepScanChildrenForNode(children.children, node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction getRefInstance$1(node, instance) {\n\t\tvar children = instance.props.children;\n\n\t\tif (deepScanChildrenForNode(children, node)) {\n\t\t\treturn getRefInstance$1(node, instance._parentComponent);\n\t\t}\n\t\treturn instance;\n\t}\n\n\tvar recyclingEnabled = true;\n\n\tfunction recycle(node, bp, lifecycle, context, instance) {\n\t\tif (bp !== undefined) {\n\t\t\tvar pool = bp.pool;\n\t\t\tvar recycledNode = pool.pop();\n\n\t\t\tif (!isNullOrUndefined(recycledNode)) {\n\t\t\t\tpatch(recycledNode, node, null, lifecycle, context, instance, bp.isSVG);\n\t\t\t\treturn node.dom;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction pool(node) {\n\t\tvar bp = node.bp;\n\n\t\tif (!isNullOrUndefined(bp)) {\n\t\t\tbp.pool.push(node);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction unmount(input, parentDom) {\n\t\tif (isVList(input)) {\n\t\t\tunmountVList(input, parentDom, true);\n\t\t} else if (isVNode(input)) {\n\t\t\tunmountVNode(input, parentDom, false);\n\t\t}\n\t}\n\n\tfunction unmountVList(vList, parentDom, removePointer) {\n\t\tvar items = vList.items;\n\t\tvar itemsLength = items.length;\n\t\tvar pointer = vList.pointer;\n\n\t\tif (itemsLength > 0) {\n\t\t\tfor (var i = 0; i < itemsLength; i++) {\n\t\t\t\tvar item = items[i];\n\n\t\t\t\tif (isVList(item)) {\n\t\t\t\t\tunmountVList(item, parentDom, true);\n\t\t\t\t} else {\n\t\t\t\t\tif (parentDom) {\n\t\t\t\t\t\tremoveChild(parentDom, item.dom);\n\t\t\t\t\t}\n\t\t\t\t\tunmount(item, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (parentDom && removePointer) {\n\t\t\tremoveChild(parentDom, pointer);\n\t\t}\n\t}\n\n\tfunction unmountVNode(node, parentDom, shallow) {\n\t\tvar instance = node.instance;\n\t\tvar instanceHooks = null;\n\t\tvar instanceChildren = null;\n\n\t\tif (!isNullOrUndefined(instance)) {\n\t\t\tinstanceHooks = instance.hooks;\n\t\t\tinstanceChildren = instance.children;\n\n\t\t\tif (instance.render !== undefined) {\n\t\t\t\tinstance.componentWillUnmount();\n\t\t\t\tinstance._unmounted = true;\n\t\t\t\tcomponentToDOMNodeMap.delete(instance);\n\t\t\t\t!shallow && unmount(instance._lastNode, null);\n\t\t\t}\n\t\t}\n\t\tvar hooks = node.hooks || instanceHooks;\n\n\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\tif (!isNullOrUndefined(hooks.willDetach)) {\n\t\t\t\thooks.willDetach(node.dom);\n\t\t\t}\n\t\t\tif (!isNullOrUndefined(hooks.componentWillUnmount)) {\n\t\t\t\thooks.componentWillUnmount(node.dom, hooks);\n\t\t\t}\n\t\t}\n\t\tvar children = (isNullOrUndefined(instance) ? node.children : null) || instanceChildren;\n\n\t\tif (!isNullOrUndefined(children)) {\n\t\t\tif (isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tunmount(children[i], null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunmount(children, null);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction VText(text) {\n\t\tthis.text = text;\n\t\tthis.dom = null;\n\t}\n\n\tfunction VPlaceholder() {\n\t\tthis.placeholder = true;\n\t\tthis.dom = null;\n\t}\n\n\tfunction VList(items) {\n\t\tthis.dom = null;\n\t\tthis.pointer = null;\n\t\tthis.items = items;\n\t}\n\n\tfunction createVText(text) {\n\t\treturn new VText(text);\n\t}\n\n\tfunction createVPlaceholder() {\n\t\treturn new VPlaceholder();\n\t}\n\n\tfunction createVList(items) {\n\t\treturn new VList(items);\n\t}\n\n\tfunction constructDefaults(string, object, value) {\n\t\t/* eslint no-return-assign: 0 */\n\t\tstring.split(',').forEach(function (i) { return object[i] = value; });\n\t}\n\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\tvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\n\tvar strictProps = {};\n\tvar booleanProps = {};\n\tvar namespaces = {};\n\tvar isUnitlessNumber = {};\n\n\tconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\n\tconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\n\tconstructDefaults('volume,value', strictProps, true);\n\tconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,selected,readonly,multiple,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\n\tconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\n\tfunction isVText(o) {\n\t\treturn o.text !== undefined;\n\t}\n\n\tfunction isVPlaceholder(o) {\n\t\treturn o.placeholder === true;\n\t}\n\n\tfunction isVList(o) {\n\t\treturn o.items !== undefined;\n\t}\n\n\tfunction isVNode(o) {\n\t\treturn o.tag !== undefined || o.bp !== undefined;\n\t}\n\n\tfunction insertOrAppend(parentDom, newNode, nextNode) {\n\t\tif (isNullOrUndefined(nextNode)) {\n\t\t\tparentDom.appendChild(newNode);\n\t\t} else {\n\t\t\tparentDom.insertBefore(newNode, nextNode);\n\t\t}\n\t}\n\n\tfunction replaceVListWithNode(parentDom, vList, dom) {\n\t\tvar pointer = vList.pointer;\n\n\t\tunmountVList(vList, parentDom, false);\n\t\treplaceNode(parentDom, dom, pointer);\n\t}\n\n\tfunction documentCreateElement(tag, isSVG) {\n\t\tvar dom;\n\n\t\tif (isSVG === true) {\n\t\t\tdom = document.createElementNS('http://www.w3.org/2000/svg', tag);\n\t\t} else {\n\t\t\tdom = document.createElement(tag);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction appendText(text, parentDom, singleChild) {\n\t\tif (parentDom === null) {\n\t\t\treturn document.createTextNode(text);\n\t\t} else {\n\t\t\tif (singleChild) {\n\t\t\t\tif (text !== '') {\n\t\t\t\t\tparentDom.textContent = text;\n\t\t\t\t\treturn parentDom.firstChild;\n\t\t\t\t} else {\n\t\t\t\t\tvar textNode = document.createTextNode('');\n\n\t\t\t\t\tparentDom.appendChild(textNode);\n\t\t\t\t\treturn textNode;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar textNode$1 = document.createTextNode(text);\n\n\t\t\t\tparentDom.appendChild(textNode$1);\n\t\t\t\treturn textNode$1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar lastInstance = null;\n\t\tvar instanceLastNode = lastNode._lastNode;\n\n\t\tif (!isNullOrUndefined(instanceLastNode)) {\n\t\t\tlastInstance = lastNode;\n\t\t\tlastNode = instanceLastNode;\n\t\t}\n\t\tunmount(lastNode, false);\n\t\tvar dom = mount(nextNode, null, lifecycle, context, instance, isSVG);\n\n\t\tnextNode.dom = dom;\n\t\treplaceNode(parentDom, dom, lastNode.dom);\n\t\tif (lastInstance !== null) {\n\t\t\tlastInstance._lastNode = nextNode;\n\t\t}\n\t}\n\n\tfunction replaceNode(parentDom, nextDom, lastDom) {\n\t\tparentDom.replaceChild(nextDom, lastDom);\n\t}\n\n\tfunction normalise(object) {\n\t\tif (isStringOrNumber(object)) {\n\t\t\treturn createVText(object);\n\t\t} else if (isInvalidNode(object)) {\n\t\t\treturn createVPlaceholder();\n\t\t} else if (isArray(object)) {\n\t\t\treturn createVList(object);\n\t\t}\n\t\treturn object;\n\t}\n\n\tfunction normaliseChild(children, i) {\n\t\tvar child = children[i];\n\n\t\treturn children[i] = normalise(child);\n\t}\n\n\tfunction remove(node, parentDom) {\n\t\tif (isVList(node)) {\n\t\t\treturn unmount(node, parentDom);\n\t\t}\n\t\tvar dom = node.dom;\n\t\tif (dom === parentDom) {\n\t\t\tdom.innerHTML = '';\n\t\t} else {\n\t\t\tremoveChild(parentDom, dom);\n\t\t\tif (recyclingEnabled) {\n\t\t\t\tpool(node);\n\t\t\t}\n\t\t}\n\t\tunmount(node, false);\n\t}\n\n\tfunction removeChild(parentDom, dom) {\n\t\tparentDom.removeChild(dom);\n\t}\n\n\tfunction removeEvents(events, lastEventKeys, dom) {\n\t\tvar eventKeys = lastEventKeys || Object.keys(events);\n\n\t\tfor (var i = 0; i < eventKeys.length; i++) {\n\t\t\tvar event = eventKeys[i];\n\n\t\t\tdom[event] = null;\n\t\t}\n\t}\n\n\t// TODO: for node we need to check if document is valid\n\tfunction getActiveNode() {\n\t\treturn document.activeElement;\n\t}\n\n\tfunction removeAllChildren(dom, children) {\n\t\tif (recyclingEnabled) {\n\t\t\tvar childrenLength = children.length;\n\n\t\t\tif (childrenLength > 5) {\n\t\t\t\tfor (var i = 0; i < childrenLength; i++) {\n\t\t\t\t\tvar child = children[i];\n\n\t\t\t\t\tif (!isInvalidNode(child)) {\n\t\t\t\t\t\tpool(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdom.textContent = '';\n\t}\n\n\tfunction resetActiveNode(activeNode) {\n\t\tif (activeNode !== null && activeNode !== document.body && document.activeElement !== activeNode) {\n\t\t\tactiveNode.focus(); // TODO: verify are we doing new focus event, if user has focus listener this might trigger it\n\t\t}\n\t}\n\n\tfunction isKeyed(lastChildren, nextChildren) {\n\t\tif (lastChildren.complex) {\n\t\t\treturn false;\n\t\t}\n\t\treturn nextChildren.length && !isNullOrUndefined(nextChildren[0]) && !isNullOrUndefined(nextChildren[0].key)\n\t\t\t&& lastChildren.length && !isNullOrUndefined(lastChildren[0]) && !isNullOrUndefined(lastChildren[0].key);\n\t}\n\n\tfunction selectOptionValueIfNeeded(vdom, values) {\n\t\tif (vdom.tag !== 'option') {\n\t\t\tfor (var i = 0, len = vdom.children.length; i < len; i++) {\n\t\t\t\tselectOptionValueIfNeeded(vdom.children[i], values);\n\t\t\t}\n\t\t\t// NOTE! Has to be a return here to catch optGroup elements\n\t\t\treturn;\n\t\t}\n\n\t\tvar value = vdom.attrs && vdom.attrs.value;\n\n\t\tif (values[value]) {\n\t\t\tvdom.attrs = vdom.attrs || {};\n\t\t\tvdom.attrs.selected = 'selected';\n\t\t\tvdom.dom.selected = true;\n\t\t} else {\n\t\t\tvdom.dom.selected = false;\n\t\t}\n\t}\n\n\tfunction selectValue(vdom) {\n\t\tvar value = vdom.attrs && vdom.attrs.value;\n\n\t\tvar values = {};\n\t\tif (isArray(value)) {\n\t\t\tfor (var i = 0, len = value.length; i < len; i++) {\n\t\t\t\tvalues[value[i]] = value[i];\n\t\t\t}\n\t\t} else {\n\t\t\tvalues[value] = value;\n\t\t}\n\t\tfor (var i$1 = 0, len$1 = vdom.children.length; i$1 < len$1; i$1++) {\n\t\t\tselectOptionValueIfNeeded(vdom.children[i$1], values);\n\t\t}\n\n\t\tif (vdom.attrs && vdom.attrs[value]) {\n\t\t\tdelete vdom.attrs.value; // TODO! Avoid deletion here. Set to null or undef. Not sure what you want to usev\n\t\t}\n\t}\n\n\tfunction handleAttachedHooks(hooks, lifecycle, dom) {\n\t\tif (!isNullOrUndefined(hooks.created)) {\n\t\t\thooks.created(dom);\n\t\t}\n\t\tif (!isNullOrUndefined(hooks.attached)) {\n\t\t\tlifecycle.addListener(function () {\n\t\t\t\thooks.attached(dom);\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction setValueProperty(nextNode) {\n\t\tvar value = nextNode.attrs.value;\n\t\tif (!isNullOrUndefined(value)) {\n\t\t\tnextNode.dom.value = value;\n\t\t}\n\t}\n\n\tfunction setFormElementProperties(nextTag, nextNode) {\n\t\tif (nextTag === 'input' && nextNode.attrs) {\n\t\t\tvar inputType = nextNode.attrs.type;\n\t\t\tif (inputType === 'text') {\n\t\t\t\tsetValueProperty(nextNode);\n\t\t\t} else if (inputType === 'checkbox' || inputType === 'radio') {\n\t\t\t\tvar checked = nextNode.attrs.checked;\n\t\t\t\tnextNode.dom.checked = !!checked;\n\t\t\t}\n\t\t} else if (nextTag === 'textarea') {\n\t\t\tsetValueProperty(nextNode);\n\t\t}\n\t}\n\n\tfunction mount(input, parentDom, lifecycle, context, instance, isSVG) {\n\t\tif (isVPlaceholder(input)) {\n\t\t\treturn mountVPlaceholder(input, parentDom);\n\t\t} else if (isVText(input)) {\n\t\t\treturn mountVText(input, parentDom);\n\t\t} else if (isVList(input)) {\n\t\t\treturn mountVList(input, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else if (isVNode(input)) {\n\t\t\treturn mountVNode$1(input, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else {\n\t\t\tvar normalisedInput = normalise(input);\n\n\t\t\tif (input !== normalisedInput) {\n\t\t\t\treturn mount(normalisedInput, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t} else {\n\t\t\t\tthrow new Error((\"Inferno Error: invalid object \\\"\" + (typeof input) + \"\\\" passed to mount()\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction mountVNode$1(vNode, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar bp = vNode.bp;\n\n\t\tif (isUndefined(bp)) {\n\t\t\treturn mountVNodeWithoutBlueprint(vNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else {\n\t\t\tif (recyclingEnabled) {\n\t\t\t\tvar dom = recycle(vNode, bp, lifecycle, context, instance);\n\n\t\t\t\tif (!isNull(dom)) {\n\t\t\t\t\tif (!isNull(parentDom)) {\n\t\t\t\t\t\tparentDom.appendChild(dom);\n\t\t\t\t\t}\n\t\t\t\t\treturn dom;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mountVNodeWithBlueprint(vNode, bp, parentDom, lifecycle, context, instance);\n\t\t}\n\t}\n\n\tfunction mountVList(vList, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar items = vList.items;\n\t\tvar pointer = document.createTextNode('');\n\t\tvar dom = document.createDocumentFragment();\n\n\t\tmountArrayChildren(items, dom, lifecycle, context, instance, isSVG);\n\t\tvList.pointer = pointer;\n\t\tvList.dom = dom;\n\t\tdom.appendChild(pointer);\n\t\tif (parentDom) {\n\t\t\tinsertOrAppend(parentDom, dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountVText(vText, parentDom) {\n\t\tvar dom = document.createTextNode(vText.text);\n\n\t\tvText.dom = dom;\n\t\tif (parentDom) {\n\t\t\tinsertOrAppend(parentDom, dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountVPlaceholder(vPlaceholder, parentDom) {\n\t\tvar dom = document.createTextNode('');\n\n\t\tvPlaceholder.dom = dom;\n\t\tif (parentDom) {\n\t\t\tinsertOrAppend(parentDom, dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction handleSelects(node) {\n\t\tif (node.tag === 'select') {\n\t\t\tselectValue(node);\n\t\t}\n\t}\n\n\tfunction mountBlueprintAttrs(node, bp, dom, instance) {\n\t\thandleSelects(node);\n\t\tvar attrs = node.attrs;\n\n\t\tif (isNull(bp.attrKeys)) {\n\t\t\tvar newKeys = Object.keys(attrs);\n\t\t\tbp.attrKeys = bp.attrKeys ? bp.attrKeys.concat(newKeys) : newKeys;\n\t\t}\n\t\tvar attrKeys = bp.attrKeys;\n\n\t\tmountAttributes(node, attrs, attrKeys, dom, instance);\n\t}\n\n\tfunction mountBlueprintEvents(node, bp, dom) {\n\t\tvar events = node.events;\n\n\t\tif (isNull(bp.eventKeys)) {\n\t\t\tbp.eventKeys = Object.keys(events);\n\t\t}\n\t\tvar eventKeys = bp.eventKeys;\n\n\t\tmountEvents(events, eventKeys, dom);\n\t}\n\n\tfunction mountVNodeWithBlueprint(node, bp, parentDom, lifecycle, context, instance) {\n\t\tvar tag = node.tag;\n\n\t\tif (isTrue(bp.isComponent)) {\n\t\t\treturn mountComponent(node, tag, node.attrs || {}, node.hooks, node.children, instance, parentDom, lifecycle, context);\n\t\t}\n\t\tvar dom = documentCreateElement(bp.tag, bp.isSVG);\n\n\t\tnode.dom = dom;\n\t\tif (isTrue(bp.hasHooks)) {\n\t\t\thandleAttachedHooks(node.hooks, lifecycle, dom);\n\t\t}\n\t\tif (isTrue(bp.lazy)) {\n\t\t\thandleLazyAttached(node, lifecycle, dom);\n\t\t}\n\t\tvar children = node.children;\n\t\t// bp.childrenType:\n\t\t// 0: no children\n\t\t// 1: text node\n\t\t// 2: single child\n\t\t// 3: multiple children\n\t\t// 4: multiple children (keyed)\n\t\t// 5: variable children (defaults to no optimisation)\n\n\t\tswitch (bp.childrenType) {\n\t\t\tcase 1:\n\t\t\t\tappendText(children, dom, true);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tmount(node.children, dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tmountArrayChildren(children, dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tmount(children[i], dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tmountChildren(node, children, dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (isTrue(bp.hasAttrs)) {\n\t\t\tmountBlueprintAttrs(node, bp, dom, instance);\n\t\t}\n\t\tif (isTrue(bp.hasClassName)) {\n\t\t\tdom.className = node.className;\n\t\t}\n\t\tif (isTrue(bp.hasStyle)) {\n\t\t\tpatchStyle(null, node.style, dom);\n\t\t}\n\t\tif (isTrue(bp.hasEvents)) {\n\t\t\tmountBlueprintEvents(node, bp, dom);\n\t\t}\n\t\tif (!isNull(parentDom)) {\n\t\t\tparentDom.appendChild(dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountVNodeWithoutBlueprint(node, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar tag = node.tag;\n\n\t\tif (isFunction(tag)) {\n\t\t\treturn mountComponent(node, tag, node.attrs || {}, node.hooks, node.children, instance, parentDom, lifecycle, context);\n\t\t}\n\t\tif (!isString(tag) || tag === '') {\n\t\t\tthrow Error('Inferno Error: Expected function or string for element tag type');\n\t\t}\n\t\tif (tag === 'svg') {\n\t\t\tisSVG = true;\n\t\t}\n\t\tvar dom = documentCreateElement(tag, isSVG);\n\t\tvar children = node.children;\n\t\tvar attrs = node.attrs;\n\t\tvar events = node.events;\n\t\tvar hooks = node.hooks;\n\t\tvar className = node.className;\n\t\tvar style = node.style;\n\n\t\tnode.dom = dom;\n\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\thandleAttachedHooks(hooks, lifecycle, dom);\n\t\t}\n\t\tif (!isInvalidNode(children)) {\n\t\t\tmountChildren(node, children, dom, lifecycle, context, instance, isSVG);\n\t\t}\n\t\tif (!isNullOrUndefined(attrs)) {\n\t\t\thandleSelects(node);\n\t\t\tmountAttributes(node, attrs, Object.keys(attrs), dom, instance);\n\t\t}\n\t\tif (!isNullOrUndefined(className)) {\n\t\t\tdom.className = className;\n\t\t}\n\t\tif (!isNullOrUndefined(style)) {\n\t\t\tpatchStyle(null, style, dom);\n\t\t}\n\t\tif (!isNullOrUndefined(events)) {\n\t\t\tmountEvents(events, Object.keys(events), dom);\n\t\t}\n\t\tif (!isNull(parentDom)) {\n\t\t\tparentDom.appendChild(dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountArrayChildren(children, parentDom, lifecycle, context, instance, isSVG) {\n\t\tchildren.complex = false;\n\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\tvar child = normaliseChild(children, i);\n\n\t\t\tif (isVText(child)) {\n\t\t\t\tmountVText(child, parentDom);\n\t\t\t\tchildren.complex = true;\n\t\t\t} else if (isVPlaceholder(child)) {\n\t\t\t\tmountVPlaceholder(child, parentDom);\n\t\t\t\tchildren.complex = true;\n\t\t\t} else if (isVList(child)) {\n\t\t\t\tmountVList(child, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\tchildren.complex = true;\n\t\t\t} else {\n\t\t\t\tmount(child, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction mountChildren(node, children, parentDom, lifecycle, context, instance, isSVG) {\n\t\tif (isArray(children)) {\n\t\t\tmountArrayChildren(children, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else if (isStringOrNumber(children)) {\n\t\t\tappendText(children, parentDom, true);\n\t\t} else if (!isInvalidNode(children)) {\n\t\t\tmount(children, parentDom, lifecycle, context, instance, isSVG);\n\t\t}\n\t}\n\n\tfunction mountRef(instance, value, refValue) {\n\t\tif (!isInvalidNode(instance) && isString(value)) {\n\t\t\tinstance.refs[value] = refValue;\n\t\t}\n\t}\n\n\tfunction mountEvents(events, eventKeys, dom) {\n\t\tfor (var i = 0; i < eventKeys.length; i++) {\n\t\t\tvar event = eventKeys[i];\n\n\t\t\tdom[event] = events[event];\n\t\t}\n\t}\n\n\tfunction mountComponent(parentNode, Component, props, hooks, children, lastInstance, parentDom, lifecycle, context) {\n\t\tprops = addChildrenToProps(children, props);\n\n\t\tvar dom;\n\t\tif (isStatefulComponent(Component)) {\n\t\t\tvar instance = new Component(props, context);\n\n\t\t\tinstance._patch = patch;\n\t\t\tinstance._componentToDOMNodeMap = componentToDOMNodeMap;\n\t\t\tif (!isNullOrUndefined(lastInstance) && props.ref) {\n\t\t\t\tmountRef(lastInstance, props.ref, instance);\n\t\t\t}\n\t\t\tvar childContext = instance.getChildContext();\n\n\t\t\tif (!isNullOrUndefined(childContext)) {\n\t\t\t\tcontext = Object.assign({}, context, childContext);\n\t\t\t}\n\t\t\tinstance.context = context;\n\t\t\tinstance._unmounted = false;\n\t\t\tinstance._parentNode = parentNode;\n\t\t\tif (lastInstance) {\n\t\t\t\tinstance._parentComponent = lastInstance;\n\t\t\t}\n\t\t\tinstance._pendingSetState = true;\n\t\t\tinstance.componentWillMount();\n\t\t\tvar node = instance.render();\n\n\t\t\tif (isInvalidNode(node)) {\n\t\t\t\tnode = createVPlaceholder();\n\t\t\t}\n\t\t\tinstance._pendingSetState = false;\n\t\t\tdom = mount(node, null, lifecycle, context, instance, false);\n\t\t\tinstance._lastNode = node;\n\t\t\tinstance.componentDidMount();\n\t\t\tif (parentDom !== null && !isInvalidNode(dom)) {\n\t\t\t\tparentDom.appendChild(dom);\n\t\t\t}\n\t\t\tcomponentToDOMNodeMap.set(instance, dom);\n\t\t\tparentNode.dom = dom;\n\t\t\tparentNode.instance = instance;\n\t\t} else {\n\t\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\t\tif (!isNullOrUndefined(hooks.componentWillMount)) {\n\t\t\t\t\thooks.componentWillMount(null, props);\n\t\t\t\t}\n\t\t\t\tif (!isNullOrUndefined(hooks.componentDidMount)) {\n\t\t\t\t\tlifecycle.addListener(function () {\n\t\t\t\t\t\thooks.componentDidMount(dom, props);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* eslint new-cap: 0 */\n\t\t\tvar node$1 = Component(props, context);\n\n\t\t\tif (isInvalidNode(node$1)) {\n\t\t\t\tnode$1 = createVPlaceholder();\n\t\t\t}\n\t\t\tdom = mount(node$1, null, lifecycle, context, null, false);\n\n\t\t\tparentNode.instance = node$1;\n\n\t\t\tif (parentDom !== null && !isInvalidNode(dom)) {\n\t\t\t\tparentDom.appendChild(dom);\n\t\t\t}\n\t\t\tparentNode.dom = dom;\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountAttributes(node, attrs, attrKeys, dom, instance) {\n\t\tfor (var i = 0; i < attrKeys.length; i++) {\n\t\t\tvar attr = attrKeys[i];\n\n\t\t\tif (attr === 'ref') {\n\t\t\t\tmountRef(getRefInstance$1(node, instance), attrs[attr], dom);\n\t\t\t} else {\n\t\t\t\tpatchAttribute(attr, null, attrs[attr], dom);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patch(lastInput, nextInput, parentDom, lifecycle, context, instance, isSVG) {\n\t\tif (lastInput !== nextInput) {\n\t\t\tif (isInvalidNode(lastInput)) {\n\t\t\t\tmount(nextInput, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t} else if (isInvalidNode(nextInput)) {\n\t\t\t\tremove(lastInput, parentDom);\n\t\t\t} else if (isStringOrNumber(lastInput)) {\n\t\t\t\tif (isStringOrNumber(nextInput)) {\n\t\t\t\t\tparentDom.firstChild.nodeValue = nextInput;\n\t\t\t\t} else {\n\t\t\t\t\tvar dom = mount(nextInput, null, lifecycle, context, instance, isSVG);\n\n\t\t\t\t\tnextInput.dom = dom;\n\t\t\t\t\treplaceNode(parentDom, dom, parentDom.firstChild);\n\t\t\t\t}\n\t\t\t} else if (isStringOrNumber(nextInput)) {\n\t\t\t\treplaceNode(parentDom, document.createTextNode(nextInput), lastInput.dom);\n\t\t\t} else {\n\t\t\t\tif (isVList(nextInput)) {\n\t\t\t\t\tif (isVList(lastInput)) {\n\t\t\t\t\t\tpatchVList(lastInput, nextInput, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplaceNode(parentDom, mountVList(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t}\n\t\t\t\t} else if (isVList(lastInput)) {\n\t\t\t\t\treplaceVListWithNode(parentDom, lastInput, mount(nextInput, null, lifecycle, context, instance, isSVG));\n\t\t\t\t} else if (isVPlaceholder(nextInput)) {\n\t\t\t\t\tif (isVPlaceholder(lastInput)) {\n\t\t\t\t\t\tpatchVFragment(lastInput, nextInput);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplaceNode(parentDom, mountVPlaceholder(nextInput, null), lastInput.dom);\n\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t}\n\t\t\t\t} else if (isVPlaceholder(lastInput)) {\n\t\t\t\t\treplaceNode(parentDom, mount(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t} else if (isVText(nextInput)) {\n\t\t\t\t\tif (isVText(lastInput)) {\n\t\t\t\t\t\tpatchVText(lastInput, nextInput);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplaceNode(parentDom, mountVText(nextInput, null), lastInput.dom);\n\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t}\n\t\t\t\t} else if (isVText(lastInput)) {\n\t\t\t\t\treplaceNode(parentDom, mount(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t} else if (isVNode(nextInput)) {\n\t\t\t\t\tif (isVNode(lastInput)) {\n\t\t\t\t\t\tpatchVNode(lastInput, nextInput, parentDom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplaceNode(parentDom, mountVNode(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t}\n\t\t\t\t} else if (isVNode(lastInput)) {\n\t\t\t\t\treplaceNode(parentDom, mount(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t} else {\n\t\t\t\t\treturn patch(lastInput, normalise(nextInput), parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nextInput;\n\t}\n\n\tfunction patchTextNode(dom, lastChildren, nextChildren) {\n\t\tif (isStringOrNumber(lastChildren)) {\n\t\t\tdom.firstChild.nodeValue = nextChildren;\n\t\t} else {\n\t\t\tdom.textContent = nextChildren;\n\t\t}\n\t}\n\n\tfunction patchRef(instance, lastValue, nextValue, dom) {\n\t\tif (instance) {\n\t\t\tif (isString(lastValue)) {\n\t\t\t\tdelete instance.refs[lastValue];\n\t\t\t}\n\t\t\tif (isString(nextValue)) {\n\t\t\t\tinstance.refs[nextValue] = dom;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchChildren(lastNode, nextNode, dom, lifecycle, context, instance, isSVG) {\n\t\tvar nextChildren = nextNode.children;\n\t\tvar lastChildren = lastNode.children;\n\n\t\tif (lastChildren === nextChildren) {\n\t\t\treturn;\n\t\t}\n\t\tif (isInvalidNode(lastChildren)) {\n\t\t\tif (isStringOrNumber(nextChildren)) {\n\t\t\t\tpatchTextNode(dom, lastChildren, nextChildren);\n\t\t\t} else if (!isInvalidNode(nextChildren)) {\n\t\t\t\tif (isArray(nextChildren)) {\n\t\t\t\t\tmountArrayChildren(nextChildren, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t} else {\n\t\t\t\t\tmount(nextChildren, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (isInvalidNode(nextChildren)) {\n\t\t\t\tremoveAllChildren(dom, lastChildren);\n\t\t\t} else {\n\t\t\t\tif (isArray(lastChildren)) {\n\t\t\t\t\tif (isArray(nextChildren)) {\n\t\t\t\t\t\tnextChildren.complex = lastChildren.complex;\n\t\t\t\t\t\tif (isKeyed(lastChildren, nextChildren)) {\n\t\t\t\t\t\t\tpatchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpatchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpatchNonKeyedChildren(lastChildren, [nextChildren], dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isArray(nextChildren)) {\n\t\t\t\t\t\tvar lastChild = lastChildren;\n\n\t\t\t\t\t\tif (isStringOrNumber(lastChildren)) {\n\t\t\t\t\t\t\tlastChild = createVText(lastChild);\n\t\t\t\t\t\t\tlastChild.dom = dom.firstChild;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpatchNonKeyedChildren([lastChild], nextChildren, dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t} else if (isStringOrNumber(nextChildren)) {\n\t\t\t\t\t\tpatchTextNode(dom, lastChildren, nextChildren);\n\t\t\t\t\t} else if (isStringOrNumber(lastChildren)) {\n\t\t\t\t\t\tpatch(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpatchVNode(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchVNode(lastVNode, nextVNode, parentDom, lifecycle, context, instance, isSVG, skipLazyCheck) {\n\t\tvar lastBp = lastVNode.bp;\n\t\tvar nextBp = nextVNode.bp;\n\n\t\tif (lastBp === undefined || nextBp === undefined) {\n\t\t\tpatchVNodeWithoutBlueprint(lastVNode, nextVNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else {\n\t\t\tpatchVNodeWithBlueprint(lastVNode, nextVNode, lastBp, nextBp, parentDom, lifecycle, context, instance, skipLazyCheck);\n\t\t}\n\t}\n\n\tfunction patchVNodeWithBlueprint(lastVNode, nextVNode, lastBp, nextBp, parentDom, lifecycle, context, instance, skipLazyCheck) {\n\t\tvar nextHooks;\n\n\t\tif (nextBp.hasHooks === true) {\n\t\t\tnextHooks = nextVNode.hooks;\n\t\t\tif (nextHooks && !isNullOrUndefined(nextHooks.willUpdate)) {\n\t\t\t\tnextHooks.willUpdate(lastVNode.dom);\n\t\t\t}\n\t\t}\n\t\tvar nextTag = nextVNode.tag || nextBp.tag;\n\t\tvar lastTag = lastVNode.tag || lastBp.tag;\n\n\t\tif (lastTag !== nextTag) {\n\t\t\tif (lastBp.isComponent === true) {\n\t\t\t\tvar lastNodeInstance = lastVNode.instance;\n\n\t\t\t\tif (nextBp.isComponent === true) {\n\t\t\t\t\treplaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, instance, false);\n\t\t\t\t} else if (isStatefulComponent(lastTag)) {\n\t\t\t\t\tunmountVNode(lastVNode, null, true);\n\t\t\t\t\tvar lastNode = lastNodeInstance._lastNode;\n\t\t\t\t\tpatchVNodeWithBlueprint(lastNode, nextVNode, lastNode.bp, nextBp, parentDom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t} else {\n\t\t\t\t\tunmountVNode(lastVNode, null, true);\n\t\t\t\t\tpatchVNodeWithBlueprint(lastNodeInstance, nextVNode, lastNodeInstance.bp, nextBp, parentDom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treplaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t}\n\t\t} else if (isNullOrUndefined(lastTag)) {\n\t\t\tnextVNode.dom = lastVNode.dom;\n\t\t} else {\n\t\t\tif (lastBp.isComponent === true) {\n\t\t\t\tif (nextBp.isComponent === true) {\n\t\t\t\t\tvar instance$1 = lastVNode.instance;\n\n\t\t\t\t\tif (!isNullOrUndefined(instance$1) && instance$1._unmounted) {\n\t\t\t\t\t\tvar newDom = mountComponent(nextVNode, lastTag, nextVNode.attrs || {}, nextVNode.hooks, nextVNode.children, instance$1, parentDom, lifecycle, context);\n\t\t\t\t\t\tif (parentDom !== null) {\n\t\t\t\t\t\t\treplaceNode(parentDom, newDom, lastVNode.dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextVNode.instance = instance$1;\n\t\t\t\t\t\tnextVNode.dom = lastVNode.dom;\n\t\t\t\t\t\tpatchComponent(true, nextVNode, nextVNode.tag, lastBp, nextBp, instance$1, lastVNode.attrs || {}, nextVNode.attrs || {}, nextVNode.hooks, lastVNode.children, nextVNode.children, parentDom, lifecycle, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar dom = lastVNode.dom;\n\t\t\t\tvar lastChildrenType = lastBp.childrenType;\n\t\t\t\tvar nextChildrenType = nextBp.childrenType;\n\t\t\t\tnextVNode.dom = dom;\n\n\t\t\t\tif (nextBp.lazy === true && skipLazyCheck === false) {\n\t\t\t\t\tvar clipData = lastVNode.clipData;\n\n\t\t\t\t\tif (lifecycle.scrollY === null) {\n\t\t\t\t\t\tlifecycle.refresh();\n\t\t\t\t\t}\n\n\t\t\t\t\tnextVNode.clipData = clipData;\n\t\t\t\t\tif (clipData.pending === true || clipData.top - lifecycle.scrollY > lifecycle.screenHeight) {\n\t\t\t\t\t\tif (setClipNode(clipData, dom, lastVNode, nextVNode, parentDom, lifecycle, context, instance, lastBp.isSVG)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (clipData.bottom < lifecycle.scrollY) {\n\t\t\t\t\t\tif (setClipNode(clipData, dom, lastVNode, nextVNode, parentDom, lifecycle, context, instance, lastBp.isSVG)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lastChildrenType > 0 || nextChildrenType > 0) {\n\t\t\t\t\tif (nextChildrenType === 5 || lastChildrenType === 5) {\n\t\t\t\t\t\tpatchChildren(lastVNode, nextVNode, dom, lifecycle, context, instance);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar lastChildren = lastVNode.children;\n\t\t\t\t\t\tvar nextChildren = nextVNode.children;\n\n\t\t\t\t\t\tif (lastChildrenType === 0 || isInvalidNode(lastChildren)) {\n\t\t\t\t\t\t\tif (nextChildrenType > 2) {\n\t\t\t\t\t\t\t\tmountArrayChildren(nextChildren, dom, lifecycle, context, instance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmount(nextChildren, dom, lifecycle, context, instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (nextChildrenType === 0 || isInvalidNode(nextChildren)) {\n\t\t\t\t\t\t\tif (lastChildrenType > 2) {\n\t\t\t\t\t\t\t\tremoveAllChildren(dom, lastChildren);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tremove(lastChildren, dom);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (lastChildren !== nextChildren) {\n\t\t\t\t\t\t\t\tif (lastChildrenType === 4 && nextChildrenType === 4) {\n\t\t\t\t\t\t\t\t\tpatchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, nextBp.isSVG, null);\n\t\t\t\t\t\t\t\t} else if (lastChildrenType === 2 && nextChildrenType === 2) {\n\t\t\t\t\t\t\t\t\tpatch(lastChildren, nextChildren, dom, lifecycle, context, instance, true, nextBp.isSVG);\n\t\t\t\t\t\t\t\t} else if (lastChildrenType === 1 && nextChildrenType === 1) {\n\t\t\t\t\t\t\t\t\tpatchTextNode(dom, lastChildren, nextChildren);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpatchChildren(lastVNode, nextVNode, dom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lastBp.hasAttrs === true || nextBp.hasAttrs === true) {\n\t\t\t\t\tpatchAttributes(lastVNode, nextVNode, lastBp.attrKeys, nextBp.attrKeys, dom, instance);\n\t\t\t\t}\n\t\t\t\tif (lastBp.hasEvents === true || nextBp.hasEvents === true) {\n\t\t\t\t\tpatchEvents(lastVNode.events, nextVNode.events, lastBp.eventKeys, nextBp.eventKeys, dom);\n\t\t\t\t}\n\t\t\t\tif (lastBp.hasClassName === true || nextBp.hasClassName === true) {\n\t\t\t\t\tvar nextClassName = nextVNode.className;\n\n\t\t\t\t\tif (lastVNode.className !== nextClassName) {\n\t\t\t\t\t\tif (isNullOrUndefined(nextClassName)) {\n\t\t\t\t\t\t\tdom.removeAttribute('class');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdom.className = nextClassName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lastBp.hasStyle === true || nextBp.hasStyle === true) {\n\t\t\t\t\tvar nextStyle = nextVNode.style;\n\t\t\t\t\tvar lastStyle = lastVNode.style;\n\n\t\t\t\t\tif (lastStyle !== nextStyle) {\n\t\t\t\t\t\tpatchStyle(lastStyle, nextStyle, dom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nextBp.hasHooks === true && !isNullOrUndefined(nextHooks.didUpdate)) {\n\t\t\t\t\tnextHooks.didUpdate(dom);\n\t\t\t\t}\n\t\t\t\tsetFormElementProperties(nextTag, nextVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchVNodeWithoutBlueprint(lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar nextHooks = nextNode.hooks;\n\t\tvar nextHooksDefined = !isNullOrUndefined(nextHooks);\n\n\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.willUpdate)) {\n\t\t\tnextHooks.willUpdate(lastNode.dom);\n\t\t}\n\t\tvar nextTag = nextNode.tag || ((isNullOrUndefined(nextNode.bp)) ? null : nextNode.bp.tag);\n\t\tvar lastTag = lastNode.tag || ((isNullOrUndefined(lastNode.bp)) ? null : lastNode.bp.tag);\n\n\t\tif (nextTag === 'svg') {\n\t\t\tisSVG = true;\n\t\t}\n\t\tif (lastTag !== nextTag) {\n\t\t\tvar lastNodeInstance = lastNode.instance;\n\n\t\t\tif (isFunction(lastTag)) {\n\t\t\t\tif (isFunction(nextTag)) {\n\t\t\t\t\treplaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t} else if (isStatefulComponent(lastTag)) {\n\t\t\t\t\tunmountVNode(lastNode, null, true);\n\t\t\t\t\tpatchVNodeWithoutBlueprint(lastNodeInstance._lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t} else {\n\t\t\t\t\tunmountVNode(lastNode, null, true);\n\t\t\t\t\tpatchVNodeWithoutBlueprint(lastNodeInstance, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treplaceWithNewNode(lastNodeInstance || lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t}\n\t\t} else if (isNullOrUndefined(lastTag)) {\n\t\t\tnextNode.dom = lastNode.dom;\n\t\t} else {\n\t\t\tif (isFunction(lastTag)) {\n\t\t\t\tif (isFunction(nextTag)) {\n\t\t\t\t\tvar instance$1 = lastNode._instance;\n\n\t\t\t\t\tif (!isNullOrUndefined(instance$1) && instance$1._unmounted) {\n\t\t\t\t\t\tvar newDom = mountComponent(nextNode, lastTag, nextNode.attrs || {}, nextNode.hooks, nextNode.children, instance$1, parentDom, lifecycle, context);\n\t\t\t\t\t\tif (parentDom !== null) {\n\t\t\t\t\t\t\treplaceNode(parentDom, newDom, lastNode.dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextNode.instance = lastNode.instance;\n\t\t\t\t\t\tnextNode.dom = lastNode.dom;\n\t\t\t\t\t\tpatchComponent(false, nextNode, nextNode.tag, null, null, nextNode.instance, lastNode.attrs || {}, nextNode.attrs || {}, nextNode.hooks, lastNode.children, nextNode.children, parentDom, lifecycle, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar dom = lastNode.dom;\n\t\t\t\tvar nextClassName = nextNode.className;\n\t\t\t\tvar nextStyle = nextNode.style;\n\n\t\t\t\tnextNode.dom = dom;\n\n\t\t\t\tpatchChildren(lastNode, nextNode, dom, lifecycle, context, instance, isSVG);\n\t\t\t\tpatchAttributes(lastNode, nextNode, null, null, dom, instance);\n\t\t\t\tpatchEvents(lastNode.events, nextNode.events, null, null, dom);\n\n\t\t\t\tif (lastNode.className !== nextClassName) {\n\t\t\t\t\tif (isNullOrUndefined(nextClassName)) {\n\t\t\t\t\t\tdom.removeAttribute('class');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.className = nextClassName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lastNode.style !== nextStyle) {\n\t\t\t\t\tpatchStyle(lastNode.style, nextStyle, dom);\n\t\t\t\t}\n\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.didUpdate)) {\n\t\t\t\t\tnextHooks.didUpdate(dom);\n\t\t\t\t}\n\t\t\t\tsetFormElementProperties(nextTag, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchAttributes(lastNode, nextNode, lastAttrKeys, nextAttrKeys, dom, instance) {\n\t\tif (lastNode.tag === 'select') {\n\t\t\tselectValue(nextNode);\n\t\t}\n\t\tvar nextAttrs = nextNode.attrs;\n\t\tvar lastAttrs = lastNode.attrs;\n\t\tvar nextAttrsIsUndef = isNullOrUndefined(nextAttrs);\n\t\tvar lastAttrsIsNotUndef = !isNullOrUndefined(lastAttrs);\n\n\t\tif (!nextAttrsIsUndef) {\n\t\t\tvar nextAttrsKeys = nextAttrKeys || Object.keys(nextAttrs);\n\t\t\tvar attrKeysLength = nextAttrsKeys.length;\n\n\t\t\tfor (var i = 0; i < attrKeysLength; i++) {\n\t\t\t\tvar attr = nextAttrsKeys[i];\n\t\t\t\tvar lastAttrVal = lastAttrsIsNotUndef && lastAttrs[attr];\n\t\t\t\tvar nextAttrVal = nextAttrs[attr];\n\n\t\t\t\tif (lastAttrVal !== nextAttrVal) {\n\t\t\t\t\tif (attr === 'ref') {\n\t\t\t\t\t\tpatchRef(instance, lastAttrVal, nextAttrVal, dom);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpatchAttribute(attr, lastAttrVal, nextAttrVal, dom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lastAttrsIsNotUndef) {\n\t\t\tvar lastAttrsKeys = lastAttrKeys || Object.keys(lastAttrs);\n\t\t\tvar attrKeysLength$1 = lastAttrsKeys.length;\n\n\t\t\tfor (var i$1 = 0; i$1 < attrKeysLength$1; i$1++) {\n\t\t\t\tvar attr$1 = lastAttrsKeys[i$1];\n\n\t\t\t\tif (nextAttrsIsUndef || isNullOrUndefined(nextAttrs[attr$1])) {\n\t\t\t\t\tif (attr$1 === 'ref') {\n\t\t\t\t\t\tpatchRef(getRefInstance(node, instance), lastAttrs[attr$1], null, dom);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.removeAttribute(attr$1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n\t\tif (isString(nextAttrValue)) {\n\t\t\tdom.style.cssText = nextAttrValue;\n\t\t} else if (isNullOrUndefined(lastAttrValue)) {\n\t\t\tif (!isNullOrUndefined(nextAttrValue)) {\n\t\t\t\tvar styleKeys = Object.keys(nextAttrValue);\n\n\t\t\t\tfor (var i = 0; i < styleKeys.length; i++) {\n\t\t\t\t\tvar style = styleKeys[i];\n\t\t\t\t\tvar value = nextAttrValue[style];\n\n\t\t\t\t\tif (isNumber(value) && !isUnitlessNumber[style]) {\n\t\t\t\t\t\tdom.style[style] = value + 'px';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.style[style] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isNullOrUndefined(nextAttrValue)) {\n\t\t\tdom.removeAttribute('style');\n\t\t} else {\n\t\t\tvar styleKeys$1 = Object.keys(nextAttrValue);\n\n\t\t\tfor (var i$1 = 0; i$1 < styleKeys$1.length; i$1++) {\n\t\t\t\tvar style$1 = styleKeys$1[i$1];\n\t\t\t\tvar value$1 = nextAttrValue[style$1];\n\n\t\t\t\tif (isNumber(value$1) && !isUnitlessNumber[style$1]) {\n\t\t\t\t\tdom.style[style$1] = value$1 + 'px';\n\t\t\t\t} else {\n\t\t\t\t\tdom.style[style$1] = value$1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar lastStyleKeys = Object.keys(lastAttrValue);\n\n\t\t\tfor (var i$2 = 0; i$2 < lastStyleKeys.length; i$2++) {\n\t\t\t\tvar style$2 = lastStyleKeys[i$2];\n\t\t\t\tif (isNullOrUndefined(nextAttrValue[style$2])) {\n\t\t\t\t\tdom.style[style$2] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchEvents(lastEvents, nextEvents, _lastEventKeys, _nextEventKeys, dom) {\n\t\tvar nextEventsDefined = !isNullOrUndefined(nextEvents);\n\t\tvar lastEventsDefined = !isNullOrUndefined(lastEvents);\n\t\tvar lastEventKeys;\n\n\t\tif (lastEventsDefined) {\n\t\t\tlastEventKeys = _lastEventKeys || Object.keys(lastEvents);\n\t\t}\n\t\tif (nextEventsDefined) {\n\t\t\tvar nextEventKeys = _nextEventKeys || Object.keys(nextEvents);\n\n\t\t\tif (lastEventsDefined) {\n\t\t\t\tfor (var i = 0; i < nextEventKeys.length; i++) {\n\t\t\t\t\tvar event = nextEventKeys[i];\n\t\t\t\t\tvar lastEvent = lastEvents[event];\n\t\t\t\t\tvar nextEvent = nextEvents[event];\n\n\t\t\t\t\tif (lastEvent !== nextEvent) {\n\t\t\t\t\t\tdom[event] = nextEvent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var i$1 = 0; i$1 < lastEventKeys.length; i$1++) {\n\t\t\t\t\tvar event$1 = lastEventKeys[i$1];\n\n\t\t\t\t\tif (isNullOrUndefined(nextEvents[event$1])) {\n\t\t\t\t\t\tdom[event$1] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmountEvents(nextEvents, nextEventKeys, dom);\n\t\t\t}\n\t\t} else if (lastEventsDefined) {\n\t\t\tremoveEvents(lastEvents, lastEventKeys, dom);\n\t\t}\n\t}\n\n\tfunction patchAttribute(attrName, lastAttrValue, nextAttrValue, dom) {\n\t\tif (attrName === 'dangerouslySetInnerHTML') {\n\t\t\tvar lastHtml = lastAttrValue && lastAttrValue.__html;\n\t\t\tvar nextHtml = nextAttrValue && nextAttrValue.__html;\n\n\t\t\tif (isNullOrUndefined(nextHtml)) {\n\t\t\t\tthrow new Error('Inferno Error: dangerouslySetInnerHTML requires an object with a __html propety containing the innerHTML content');\n\t\t\t}\n\t\t\tif (lastHtml !== nextHtml) {\n\t\t\t\tdom.innerHTML = nextHtml;\n\t\t\t}\n\t\t} else if (attrName === 'eventData') {\n\t\t\tdom.eventData = nextAttrValue;\n\t\t} else if (strictProps[attrName]) {\n\t\t\tdom[attrName] = nextAttrValue === null ? '' : nextAttrValue;\n\t\t} else {\n\t\t\tif (booleanProps[attrName]) {\n\t\t\t\tdom[attrName] = nextAttrValue ? true : false;\n\t\t\t} else {\n\t\t\t\tvar ns = namespaces[attrName];\n\n\t\t\t\tif (nextAttrValue === false || isNullOrUndefined(nextAttrValue)) {\n\t\t\t\t\tif (ns !== undefined) {\n\t\t\t\t\t\tdom.removeAttributeNS(ns, attrName);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.removeAttribute(attrName);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ns !== undefined) {\n\t\t\t\t\t\tdom.setAttributeNS(ns, attrName, nextAttrValue === true ? attrName : nextAttrValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.setAttribute(attrName, nextAttrValue === true ? attrName : nextAttrValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchComponent(hasBlueprint, lastNode, Component, lastBp, nextBp, instance, lastProps, nextProps, nextHooks, lastChildren, nextChildren, parentDom, lifecycle, context) {\n\t\tnextProps = addChildrenToProps(nextChildren, nextProps);\n\n\t\tif (isStatefulComponent(Component)) {\n\t\t\tvar prevProps = instance.props;\n\t\t\tvar prevState = instance.state;\n\t\t\tvar nextState = instance.state;\n\n\t\t\tvar childContext = instance.getChildContext();\n\t\t\tif (!isNullOrUndefined(childContext)) {\n\t\t\t\tcontext = Object.assign({}, context, childContext);\n\t\t\t}\n\t\t\tinstance.context = context;\n\t\t\tvar nextNode = instance._updateComponent(prevState, nextState, prevProps, nextProps);\n\n\t\t\tif (nextNode === NO_RENDER) {\n\t\t\t\tnextNode = instance._lastNode;\n\t\t\t} else if (isNullOrUndefined(nextNode)) {\n\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t}\n\t\t\tpatch(instance._lastNode, nextNode, parentDom, lifecycle, context, instance, null, false);\n\t\t\tlastNode.dom = nextNode.dom;\n\t\t\tinstance._lastNode = nextNode;\n\t\t\tinstance.componentDidUpdate(prevProps, prevState);\n\t\t\tcomponentToDOMNodeMap.set(instance, nextNode.dom);\n\t\t} else {\n\t\t\tvar shouldUpdate = true;\n\t\t\tvar nextHooksDefined = (hasBlueprint && nextBp.hasHooks === true) || !isNullOrUndefined(nextHooks);\n\n\t\t\tlastProps = addChildrenToProps(lastChildren, lastProps);\n\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.componentShouldUpdate)) {\n\t\t\t\tshouldUpdate = nextHooks.componentShouldUpdate(lastNode.dom, lastProps, nextProps);\n\t\t\t}\n\t\t\tif (shouldUpdate !== false) {\n\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.componentWillUpdate)) {\n\t\t\t\t\tnextHooks.componentWillUpdate(lastNode.dom, lastProps, nextProps);\n\t\t\t\t}\n\t\t\t\tvar nextNode$1 = Component(nextProps, context);\n\n\t\t\t\tif (isInvalidNode(nextNode$1)) {\n\t\t\t\t\tnextNode$1 = createVPlaceholder();\n\t\t\t\t}\n\t\t\t\tnextNode$1.dom = lastNode.dom;\n\t\t\t\tpatch(instance, nextNode$1, parentDom, lifecycle, context, null, null, false);\n\t\t\t\tlastNode.instance = nextNode$1;\n\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.componentDidUpdate)) {\n\t\t\t\t\tnextHooks.componentDidUpdate(lastNode.dom, lastProps, nextProps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchVList(lastVList, nextVList, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar lastItems = lastVList.items;\n\t\tvar nextItems = nextVList.items;\n\t\tvar pointer = lastVList.pointer;\n\n\t\tnextVList.dom = lastVList.dom;\n\t\tnextVList.pointer = pointer;\n\t\tif (!lastItems !== nextItems) {\n\t\t\tif (isKeyed(lastItems, nextItems)) {\n\t\t\t\tpatchKeyedChildren(lastItems, nextItems, parentDom, lifecycle, context, instance, isSVG, nextVList);\n\t\t\t} else {\n\t\t\t\tpatchNonKeyedChildren(lastItems, nextItems, parentDom, lifecycle, context, instance, isSVG, nextVList);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, parentVList) {\n\t\tvar lastChildrenLength = lastChildren.length;\n\t\tvar nextChildrenLength = nextChildren.length;\n\t\tvar commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n\t\tvar i = 0;\n\n\t\tfor (; i < commonLength; i++) {\n\t\t\tvar lastChild = lastChildren[i];\n\t\t\tvar nextChild = normaliseChild(nextChildren, i);\n\n\t\t\tpatch(lastChild, nextChild, dom, lifecycle, context, instance, isSVG);\n\t\t}\n\t\tif (lastChildrenLength < nextChildrenLength) {\n\t\t\tfor (i = commonLength; i < nextChildrenLength; i++) {\n\t\t\t\tvar child = normaliseChild(nextChildren, i);\n\n\t\t\t\tinsertOrAppend(dom, mount(child, null, lifecycle, context, instance, isSVG), parentVList && parentVList.pointer);\n\t\t\t}\n\t\t} else if (lastChildrenLength > nextChildrenLength) {\n\t\t\tfor (i = commonLength; i < lastChildrenLength; i++) {\n\t\t\t\tremove(lastChildren[i], dom);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchVFragment(lastVFragment, nextVFragment) {\n\t\tnextVFragment.dom = lastVFragment.dom;\n\t}\n\n\tfunction patchVText(lastVText, nextVText) {\n\t\tvar nextText = nextVText.text;\n\t\tvar dom = lastVText.dom;\n\n\t\tnextVText.dom = dom;\n\t\tif (lastVText.text !== nextText) {\n\t\t\tdom.nodeValue = nextText;\n\t\t}\n\t}\n\n\tfunction patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, parentVList) {\n\t\tvar lastChildrenLength = lastChildren.length;\n\t\tvar nextChildrenLength = nextChildren.length;\n\t\tvar lastEndIndex = lastChildrenLength - 1;\n\t\tvar nextEndIndex = nextChildrenLength - 1;\n\t\tvar lastStartIndex = 0;\n\t\tvar nextStartIndex = 0;\n\t\tvar lastStartNode = null;\n\t\tvar nextStartNode = null;\n\t\tvar nextEndNode = null;\n\t\tvar lastEndNode = null;\n\t\tvar nextNode;\n\n\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\tnextStartNode = nextChildren[nextStartIndex];\n\t\t\tlastStartNode = lastChildren[lastStartIndex];\n\n\t\t\tif (nextStartNode.key !== lastStartNode.key) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpatchVNode(lastStartNode, nextStartNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\tnextStartIndex++;\n\t\t\tlastStartIndex++;\n\t\t}\n\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\tnextEndNode = nextChildren[nextEndIndex];\n\t\t\tlastEndNode = lastChildren[lastEndIndex];\n\n\t\t\tif (nextEndNode.key !== lastEndNode.key) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpatchVNode(lastEndNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\tnextEndIndex--;\n\t\t\tlastEndIndex--;\n\t\t}\n\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\tnextEndNode = nextChildren[nextEndIndex];\n\t\t\tlastStartNode = lastChildren[lastStartIndex];\n\n\t\t\tif (nextEndNode.key !== lastStartNode.key) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextNode = (nextEndIndex + 1 < nextChildrenLength) ? nextChildren[nextEndIndex + 1].dom : null;\n\t\t\tpatchVNode(lastStartNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\tinsertOrAppend(dom, nextEndNode.dom, nextNode);\n\t\t\tnextEndIndex--;\n\t\t\tlastStartIndex++;\n\t\t}\n\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\tnextStartNode = nextChildren[nextStartIndex];\n\t\t\tlastEndNode = lastChildren[lastEndIndex];\n\n\t\t\tif (nextStartNode.key !== lastEndNode.key) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextNode = lastChildren[lastStartIndex].dom;\n\t\t\tpatchVNode(lastEndNode, nextStartNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\tinsertOrAppend(dom, nextStartNode.dom, nextNode);\n\t\t\tnextStartIndex++;\n\t\t\tlastEndIndex--;\n\t\t}\n\n\t\tif (lastStartIndex > lastEndIndex) {\n\t\t\tif (nextStartIndex <= nextEndIndex) {\n\t\t\t\tnextNode = (nextEndIndex + 1 < nextChildrenLength) ? nextChildren[nextEndIndex + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\tfor (; nextStartIndex <= nextEndIndex; nextStartIndex++) {\n\t\t\t\t\tinsertOrAppend(dom, mount(nextChildren[nextStartIndex], null, lifecycle, context, instance, isSVG), nextNode);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nextStartIndex > nextEndIndex) {\n\t\t\twhile (lastStartIndex <= lastEndIndex) {\n\t\t\t\tremove(lastChildren[lastStartIndex++], dom);\n\t\t\t}\n\t\t} else {\n\t\t\tvar aLength = lastEndIndex - lastStartIndex + 1;\n\t\t\tvar bLength = nextEndIndex - nextStartIndex + 1;\n\t\t\tvar sources = new Array(bLength);\n\n\t\t\t// Mark all nodes as inserted.\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < bLength; i++) {\n\t\t\t\tsources[i] = -1;\n\t\t\t}\n\t\t\tvar moved = false;\n\t\t\tvar removeOffset = 0;\n\t\t\tvar lastTarget = 0;\n\t\t\tvar index;\n\t\t\tvar removed = true;\n\t\t\tvar k = 0;\n\n\t\t\tif ((bLength <= 4) || (aLength * bLength <= 16)) {\n\t\t\t\tfor (i = lastStartIndex; i <= lastEndIndex; i++) {\n\t\t\t\t\tremoved = true;\n\t\t\t\t\tlastEndNode = lastChildren[i];\n\t\t\t\t\tif (k < bLength) {\n\t\t\t\t\t\tfor (index = nextStartIndex; index <= nextEndIndex; index++) {\n\t\t\t\t\t\t\tnextEndNode = nextChildren[index];\n\t\t\t\t\t\t\tif (lastEndNode.key === nextEndNode.key) {\n\t\t\t\t\t\t\t\tsources[index - nextStartIndex] = i;\n\n\t\t\t\t\t\t\t\tif (lastTarget > index) {\n\t\t\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlastTarget = index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpatchVNode(lastEndNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\tremoved = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (removed) {\n\t\t\t\t\t\tremove(lastEndNode, dom);\n\t\t\t\t\t\tremoveOffset++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar prevItemsMap = new Map();\n\n\t\t\t\tfor (i = nextStartIndex; i <= nextEndIndex; i++) {\n\t\t\t\t\tprevItemsMap.set(nextChildren[i].key, i);\n\t\t\t\t}\n\t\t\t\tfor (i = lastStartIndex; i <= lastEndIndex; i++) {\n\t\t\t\t\tremoved = true;\n\t\t\t\t\tlastEndNode = lastChildren[i];\n\n\t\t\t\t\tif (k < nextChildrenLength) {\n\t\t\t\t\t\tindex = prevItemsMap.get(lastEndNode.key);\n\n\t\t\t\t\t\tif (index !== undefined) {\n\t\t\t\t\t\t\tnextEndNode = nextChildren[index];\n\t\t\t\t\t\t\tsources[index - nextStartIndex] = i;\n\t\t\t\t\t\t\tif (lastTarget > index) {\n\t\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlastTarget = index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpatchVNode(lastEndNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tremoved = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (removed) {\n\t\t\t\t\t\tremove(lastEndNode, dom);\n\t\t\t\t\t\tremoveOffset++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar pos;\n\t\t\tif (moved) {\n\t\t\t\tvar seq = lis_algorithm(sources);\n\t\t\t\tindex = seq.length - 1;\n\t\t\t\tfor (i = bLength - 1; i >= 0; i--) {\n\t\t\t\t\tif (sources[i] === -1) {\n\t\t\t\t\t\tpos = i + nextStartIndex;\n\t\t\t\t\t\tnextNode = (pos + 1 < nextChildrenLength) ? nextChildren[pos + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\t\tinsertOrAppend(dom, mount(nextChildren[pos], null, lifecycle, context, instance, isSVG), nextNode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (index < 0 || i !== seq[index]) {\n\t\t\t\t\t\t\tpos = i + nextStartIndex;\n\t\t\t\t\t\t\tnextNode = (pos + 1 < nextChildrenLength) ? nextChildren[pos + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\t\t\tinsertOrAppend(dom, nextChildren[pos].dom, nextNode);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (aLength - removeOffset !== bLength) {\n\t\t\t\tfor (i = bLength - 1; i >= 0; i--) {\n\t\t\t\t\tif (sources[i] === -1) {\n\t\t\t\t\t\tpos = i + nextStartIndex;\n\t\t\t\t\t\tnextNode = (pos + 1 < nextChildrenLength) ? nextChildren[pos + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\t\tinsertOrAppend(dom, mount(nextChildren[pos], null, lifecycle, context, instance, isSVG), nextNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n\tfunction lis_algorithm(a) {\n\t\tvar p = a.slice(0);\n\t\tvar result = [];\n\t\tresult.push(0);\n\t\tvar i;\n\t\tvar j;\n\t\tvar u;\n\t\tvar v;\n\t\tvar c;\n\n\t\tfor (i = 0; i < a.length; i++) {\n\t\t\tif (a[i] === -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tj = result[result.length - 1];\n\t\t\tif (a[j] < a[i]) {\n\t\t\t\tp[i] = j;\n\t\t\t\tresult.push(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tu = 0;\n\t\t\tv = result.length - 1;\n\n\t\t\twhile (u < v) {\n\t\t\t\tc = ((u + v) / 2) | 0;\n\t\t\t\tif (a[result[c]] < a[i]) {\n\t\t\t\t\tu = c + 1;\n\t\t\t\t} else {\n\t\t\t\t\tv = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a[i] < a[result[u]]) {\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tp[i] = result[u - 1];\n\t\t\t\t}\n\t\t\t\tresult[u] = i;\n\t\t\t}\n\t\t}\n\n\t\tu = result.length;\n\t\tv = result[u - 1];\n\n\t\twhile (u-- > 0) {\n\t\t\tresult[u] = v;\n\t\t\tv = p[v];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tvar screenWidth = isBrowser && window.screen.width;\n\tvar screenHeight = isBrowser && window.screen.height;\n\tvar scrollX = 0;\n\tvar scrollY = 0;\n\tvar lastScrollTime = 0;\n\n\tif (isBrowser) {\n\t\twindow.onscroll = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\n\t\twindow.resize = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tscreenWidth = window.screen.width;\n\t\t\tscreenHeight = window.screen.height;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\t}\n\n\tfunction Lifecycle() {\n\t\tthis._listeners = [];\n\t\tthis.scrollX = null;\n\t\tthis.scrollY = null;\n\t\tthis.screenHeight = screenHeight;\n\t\tthis.screenWidth = screenWidth;\n\t}\n\n\tLifecycle.prototype = {\n\t\trefresh: function refresh() {\n\t\t\tthis.scrollX = isBrowser && window.scrollX;\n\t\t\tthis.scrollY = isBrowser && window.scrollY;\n\t\t},\n\t\taddListener: function addListener(callback) {\n\t\t\tthis._listeners.push(callback);\n\t\t},\n\t\ttrigger: function trigger() {\n\t\t\tvar this$1 = this;\n\n\t\t\tfor (var i = 0; i < this._listeners.length; i++) {\n\t\t\t\tthis$1._listeners[i]();\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction handleLazyAttached(node, lifecycle, dom) {\n\t\tlifecycle.addListener(function () {\n\t\t\tvar rect = dom.getBoundingClientRect();\n\n\t\t\tif (lifecycle.scrollY === null) {\n\t\t\t\tlifecycle.refresh();\n\t\t\t}\n\t\t\tnode.clipData = {\n\t\t\t\ttop: rect.top + lifecycle.scrollY,\n\t\t\t\tleft: rect.left + lifecycle.scrollX,\n\t\t\t\tbottom: rect.bottom + lifecycle.scrollY,\n\t\t\t\tright: rect.right + lifecycle.scrollX,\n\t\t\t\tpending: false\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction hydrateChild(child, childNodes, counter, parentDom, lifecycle, context, instance) {\n\t\tvar domNode = childNodes[counter.i];\n\n\t\tif (isVText(child)) {\n\t\t\tvar text = child.text;\n\n\t\t\tchild.dom = domNode;\n\t\t\tif (domNode.nodeType === 3 && text !== '') {\n\t\t\t\tdomNode.nodeValue = text;\n\t\t\t} else {\n\t\t\t\tvar newDomNode = mountVText(text);\n\n\t\t\t\treplaceNode(parentDom, newDomNode, domNode);\n\t\t\t\tchildNodes.splice(childNodes.indexOf(domNode), 1, newDomNode);\n\t\t\t\tchild.dom = newDomNode;\n\t\t\t}\n\t\t} else if (isVPlaceholder(child)) {\n\t\t\tchild.dom = domNode;\n\t\t} else if (isVList(child)) {\n\t\t\tvar items = child.items;\n\n\t\t\t// this doesn't really matter, as it won't be used again, but it's what it should be given the purpose of VList\n\t\t\tchild.dom = document.createDocumentFragment();\n\t\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\t\tvar rebuild = hydrateChild(normaliseChild(items, i), childNodes, counter, parentDom, lifecycle, context, instance);\n\n\t\t\t\tif (rebuild) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// at the end of every VList, there should be a \"pointer\". It's an empty TextNode used for tracking the VList\n\t\t\tvar pointer = childNodes[counter.i++];\n\n\t\t\tif (pointer && pointer.nodeType === 3) {\n\t\t\t\tchild.pointer = pointer;\n\t\t\t} else {\n\t\t\t\t// there is a problem, we need to rebuild this tree\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tvar rebuild$1 = hydrateNode(child, domNode, parentDom, lifecycle, context, instance, false);\n\n\t\t\tif (rebuild$1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcounter.i++;\n\t}\n\n\tfunction getChildNodesWithoutComments(domNode) {\n\t\tvar childNodes = [];\n\t\tvar rawChildNodes = domNode.childNodes;\n\t\tvar length = rawChildNodes.length;\n\t\tvar i = 0;\n\n\t\twhile (i < length) {\n\t\t\tvar rawChild = rawChildNodes[i];\n\n\t\t\tif (rawChild.nodeType === 8) {\n\t\t\t\tif (rawChild.data === '!') {\n\t\t\t\t\tvar placeholder = document.createTextNode('');\n\n\t\t\t\t\tdomNode.replaceChild(placeholder, rawChild);\n\t\t\t\t\tchildNodes.push(placeholder);\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tdomNode.removeChild(rawChild);\n\t\t\t\t\tlength--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchildNodes.push(rawChild);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn childNodes;\n\t}\n\n\tfunction hydrateComponent(node, Component, props, hooks, children, domNode, parentDom, lifecycle, context, lastInstance, isRoot) {\n\t\tprops = addChildrenToProps(children, props);\n\n\t\tif (isStatefulComponent(Component)) {\n\t\t\tvar instance = node.instance = new Component(props);\n\n\t\t\tinstance._patch = patch;\n\t\t\tif (!isNullOrUndefined(lastInstance) && props.ref) {\n\t\t\t\tmountRef(lastInstance, props.ref, instance);\n\t\t\t}\n\t\t\tvar childContext = instance.getChildContext();\n\n\t\t\tif (!isNullOrUndefined(childContext)) {\n\t\t\t\tcontext = Object.assign({}, context, childContext);\n\t\t\t}\n\t\t\tinstance.context = context;\n\t\t\tinstance._unmounted = false;\n\t\t\tinstance._parentNode = node;\n\t\t\tif (lastInstance) {\n\t\t\t\tinstance._parentComponent = lastInstance;\n\t\t\t}\n\t\t\tinstance._pendingSetState = true;\n\t\t\tinstance.componentWillMount();\n\t\t\tvar nextNode = instance.render();\n\n\t\t\tinstance._pendingSetState = false;\n\t\t\tif (isInvalidNode(nextNode)) {\n\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t}\n\t\t\thydrateNode(nextNode, domNode, parentDom, lifecycle, context, instance, isRoot);\n\t\t\tinstance._lastNode = nextNode;\n\t\t\tinstance.componentDidMount();\n\n\t\t} else {\n\t\t\tvar instance$1 = node.instance = Component(props);\n\n\t\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\t\tif (!isNullOrUndefined(hooks.componentWillMount)) {\n\t\t\t\t\thooks.componentWillMount(null, props);\n\t\t\t\t}\n\t\t\t\tif (!isNullOrUndefined(hooks.componentDidMount)) {\n\t\t\t\t\tlifecycle.addListener(function () {\n\t\t\t\t\t\thooks.componentDidMount(domNode, props);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hydrateNode(instance$1, domNode, parentDom, lifecycle, context, instance$1, isRoot);\n\t\t}\n\t}\n\n\tfunction hydrateNode(node, domNode, parentDom, lifecycle, context, instance, isRoot) {\n\t\tvar bp = node.bp;\n\t\tvar tag = node.tag || bp.tag;\n\n\t\tif (isFunction(tag)) {\n\t\t\tnode.dom = domNode;\n\t\t\thydrateComponent(node, tag, node.attrs || {}, node.hooks, node.children, domNode, parentDom, lifecycle, context, instance, isRoot);\n\t\t} else {\n\t\t\tif (\n\t\t\t\tdomNode.nodeType !== 1 ||\n\t\t\t\ttag !== domNode.tagName.toLowerCase()\n\t\t\t) {\n\t\t\t\t// TODO remake node\n\t\t\t} else {\n\t\t\t\tnode.dom = domNode;\n\t\t\t\tvar hooks = node.hooks;\n\n\t\t\t\tif ((bp && bp.hasHooks === true) || !isNullOrUndefined(hooks)) {\n\t\t\t\t\thandleAttachedHooks(hooks, lifecycle, domNode);\n\t\t\t\t}\n\t\t\t\tvar children = node.children;\n\n\t\t\t\tif (!isNullOrUndefined(children)) {\n\t\t\t\t\tif (isStringOrNumber(children)) {\n\t\t\t\t\t\tif (domNode.textContent !== children) {\n\t\t\t\t\t\t\tdomNode.textContent = children;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar childNodes = getChildNodesWithoutComments(domNode);\n\t\t\t\t\t\tvar counter = { i: 0 };\n\t\t\t\t\t\tvar rebuild = false;\n\n\t\t\t\t\t\tif (isArray(children)) {\n\t\t\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\t\t\trebuild = hydrateChild(normaliseChild(children, i), childNodes, counter, domNode, lifecycle, context, instance);\n\n\t\t\t\t\t\t\t\tif (rebuild) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (childNodes.length === 1) {\n\t\t\t\t\t\t\t\trebuild = hydrateChild(children, childNodes, counter, domNode, lifecycle, context, instance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trebuild = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rebuild) {\n\t\t\t\t\t\t\t// TODO scrap children and rebuild again\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar className = node.className;\n\t\t\t\tvar style = node.style;\n\n\t\t\t\tif (!isNullOrUndefined(className)) {\n\t\t\t\t\tdomNode.className = className;\n\t\t\t\t}\n\t\t\t\tif (!isNullOrUndefined(style)) {\n\t\t\t\t\tpatchStyle(null, style, domNode);\n\t\t\t\t}\n\t\t\t\tif (bp && bp.hasAttrs === true) {\n\t\t\t\t\tmountBlueprintAttrs(node, bp, domNode, instance);\n\t\t\t\t} else {\n\t\t\t\t\tvar attrs = node.attrs;\n\n\t\t\t\t\tif (!isNullOrUndefined(attrs)) {\n\t\t\t\t\t\thandleSelects(node);\n\t\t\t\t\t\tmountAttributes(node, attrs, Object.keys(attrs), domNode, instance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bp && bp.hasEvents === true) {\n\t\t\t\t\tmountBlueprintEvents(node, bp, domNode);\n\t\t\t\t} else {\n\t\t\t\t\tvar events = node.events;\n\n\t\t\t\t\tif (!isNullOrUndefined(events)) {\n\t\t\t\t\t\tmountEvents(events, Object.keys(events), domNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvar documetBody = isBrowser ? document.body : null;\n\n\tfunction hydrate(node, parentDom, lifecycle) {\n\t\tif (parentDom && parentDom.nodeType === 1) {\n\t\t\tvar rootNode = parentDom.querySelector('[data-infernoroot]');\n\n\t\t\tif (rootNode && rootNode.parentNode === parentDom) {\n\t\t\t\thydrateNode(node, rootNode, parentDom, lifecycle, {}, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// clear parentDom, unless it's document.body\n\t\tif (parentDom !== documetBody) {\n\t\t\tparentDom.textContent = '';\n\t\t} else {\n\t\t\tconsole.warn('Inferno Warning: rendering to the \"document.body\" is dangerous! Use a dedicated container element instead.');\n\t\t}\n\t\treturn false;\n\t}\n\n\tvar roots = new Map();\n\tvar componentToDOMNodeMap = new Map();\n\n\tfunction findDOMNode(domNode) {\n\t\treturn componentToDOMNodeMap.get(domNode) || null;\n\t}\n\n\tfunction render(input, parentDom) {\n\t\tvar root = roots.get(parentDom);\n\t\tvar lifecycle = new Lifecycle();\n\n\t\tif (isUndefined(root)) {\n\t\t\tif (!isInvalidNode(input)) {\n\t\t\t\tif (!hydrate(input, parentDom, lifecycle)) {\n\t\t\t\t\tmount(input, parentDom, lifecycle, {}, null, false);\n\t\t\t\t}\n\t\t\t\tlifecycle.trigger();\n\t\t\t\troots.set(parentDom, { input: input });\n\t\t\t}\n\t\t} else {\n\t\t\tvar activeNode = getActiveNode();\n\t\t\tvar nextInput = patch(root.input, input, parentDom, lifecycle, {}, null, false);\n\n\t\t\tlifecycle.trigger();\n\t\t\tif (isNull(input)) {\n\t\t\t\troots.delete(parentDom);\n\t\t\t}\n\t\t\troot.input = nextInput;\n\t\t\tresetActiveNode(activeNode);\n\t\t}\n\t}\n\n\tvar index = {\n\t\trender: render,\n\t\tfindDOMNode: findDOMNode,\n\t\tmount: mount,\n\t\tpatch: patch,\n\t\tunmount: unmount\n\t};\n\n\treturn index;\n\n}));\n\n\n/** WEBPACK FOOTER **\n ** ./~/inferno/dist/inferno-dom.js\n **/","'use strict';\n\nmodule.exports = require('inferno/dist/inferno-create-class');\n\n\n/** WEBPACK FOOTER **\n ** ./~/inferno-create-class/inferno-create-class.js\n **/","/*!\n * inferno-create-class v0.7.25\n * (c) 2016 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.InfernoCreateClass = factory());\n}(this, function () { 'use strict';\n\n\tvar NO_RENDER = 'NO_RENDER';\n\n\t// Runs only once in applications lifetime\n\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\n\tfunction isNullOrUndefined(obj) {\n\t\treturn isUndefined(obj) || isNull(obj);\n\t}\n\n\tfunction isNull(obj) {\n\t\treturn obj === null;\n\t}\n\n\tfunction isUndefined(obj) {\n\t\treturn obj === undefined;\n\t}\n\n\tfunction VPlaceholder() {\n\t\tthis.placeholder = true;\n\t\tthis.dom = null;\n\t}\n\n\tfunction createVPlaceholder() {\n\t\treturn new VPlaceholder();\n\t}\n\n\tvar documetBody = isBrowser ? document.body : null;\n\n\tfunction constructDefaults(string, object, value) {\n\t\t/* eslint no-return-assign: 0 */\n\t\tstring.split(',').forEach(function (i) { return object[i] = value; });\n\t}\n\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\tvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\n\tvar strictProps = {};\n\tvar booleanProps = {};\n\tvar namespaces = {};\n\tvar isUnitlessNumber = {};\n\n\tconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\n\tconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\n\tconstructDefaults('volume,value', strictProps, true);\n\tconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,selected,readonly,multiple,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\n\tconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\n\tvar screenWidth = isBrowser && window.screen.width;\n\tvar screenHeight = isBrowser && window.screen.height;\n\tvar scrollX = 0;\n\tvar scrollY = 0;\n\tvar lastScrollTime = 0;\n\n\tif (isBrowser) {\n\t\twindow.onscroll = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\n\t\twindow.resize = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tscreenWidth = window.screen.width;\n\t\t\tscreenHeight = window.screen.height;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\t}\n\n\tfunction Lifecycle() {\n\t\tthis._listeners = [];\n\t\tthis.scrollX = null;\n\t\tthis.scrollY = null;\n\t\tthis.screenHeight = screenHeight;\n\t\tthis.screenWidth = screenWidth;\n\t}\n\n\tLifecycle.prototype = {\n\t\trefresh: function refresh() {\n\t\t\tthis.scrollX = isBrowser && window.scrollX;\n\t\t\tthis.scrollY = isBrowser && window.scrollY;\n\t\t},\n\t\taddListener: function addListener(callback) {\n\t\t\tthis._listeners.push(callback);\n\t\t},\n\t\ttrigger: function trigger() {\n\t\t\tvar this$1 = this;\n\n\t\t\tfor (var i = 0; i < this._listeners.length; i++) {\n\t\t\t\tthis$1._listeners[i]();\n\t\t\t}\n\t\t}\n\t};\n\n\tvar noOp = 'Inferno Error: Can only update a mounted or mounting component. This usually means you called setState() or forceUpdate() on an unmounted component. This is a no-op.';\n\n\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\tfunction getActiveNode() {\n\t\treturn document.activeElement;\n\t}\n\n\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\tfunction resetActiveNode(activeNode) {\n\t\tif (activeNode !== document.body && document.activeElement !== activeNode) {\n\t\t\tactiveNode.focus(); // TODO: verify are we doing new focus event, if user has focus listener this might trigger it\n\t\t}\n\t}\n\n\tfunction queueStateChanges(component, newState, callback) {\n\t\tfor (var stateKey in newState) {\n\t\t\tcomponent._pendingState[stateKey] = newState[stateKey];\n\t\t}\n\t\tif (!component._pendingSetState) {\n\t\t\tcomponent._pendingSetState = true;\n\t\t\tapplyState(component, false, callback);\n\t\t} else {\n\t\t\tcomponent.state = Object.assign({}, component.state, component._pendingState);\n\t\t\tcomponent._pendingState = {};\n\t\t}\n\t}\n\n\tfunction applyState(component, force, callback) {\n\t\tif ((!component._deferSetState || force) && !component._blockRender) {\n\t\t\tcomponent._pendingSetState = false;\n\t\t\tvar pendingState = component._pendingState;\n\t\t\tvar prevState = component.state;\n\t\t\tvar nextState = Object.assign({}, prevState, pendingState);\n\t\t\tvar props = component.props;\n\n\t\t\tcomponent._pendingState = {};\n\t\t\tvar nextNode = component._updateComponent(prevState, nextState, props, props, force);\n\n\t\t\tif (nextNode === NO_RENDER) {\n\t\t\t\tnextNode = component._lastNode;\n\t\t\t} else if (isNullOrUndefined(nextNode)) {\n\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t}\n\t\t\tvar lastNode = component._lastNode;\n\t\t\tvar parentDom = lastNode.dom.parentNode;\n\t\t\tvar activeNode = getActiveNode();\n\t\t\tvar subLifecycle = new Lifecycle();\n\n\t\t\tcomponent._patch(lastNode, nextNode, parentDom, subLifecycle, component.context, component, null);\n\t\t\tcomponent._lastNode = nextNode;\n\t\t\tcomponent._componentToDOMNodeMap.set(component, nextNode.dom);\n\t\t\tcomponent._parentNode.dom = nextNode.dom;\n\t\t\tcomponent.componentDidUpdate(props, prevState);\n\t\t\tsubLifecycle.trigger();\n\t\t\tif (!isNullOrUndefined(callback)) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\tresetActiveNode(activeNode);\n\t\t}\n\t}\n\n\tvar Component = function Component(props, context) {\n\t\tif ( context === void 0 ) context = {};\n\n\t\t/** @type {object} */\n\t\tthis.props = props || {};\n\n\t\t/** @type {object} */\n\t\tthis.state = {};\n\n\t\t/** @type {object} */\n\t\tthis.refs = {};\n\t\tthis._blockRender = false;\n\t\tthis._blockSetState = false;\n\t\tthis._deferSetState = false;\n\t\tthis._pendingSetState = false;\n\t\tthis._pendingState = {};\n\t\tthis._parentNode = null;\n\t\tthis._lastNode = null;\n\t\tthis._unmounted = true;\n\t\tthis.context = context;\n\t\tthis._patch = null;\n\t\tthis._parentComponent = null;\n\t\tthis._componentToDOMNodeMap = null;\n\t};\n\n\tComponent.prototype.render = function render () {\n\t};\n\n\tComponent.prototype.forceUpdate = function forceUpdate (callback) {\n\t\tif (this._unmounted) {\n\t\t\tthrow Error(noOp);\n\t\t}\n\t\tapplyState(this, true, callback);\n\t};\n\n\tComponent.prototype.setState = function setState (newState, callback) {\n\t\tif (this._unmounted) {\n\t\t\tthrow Error(noOp);\n\t\t}\n\t\tif (this._blockSetState === false) {\n\t\t\tqueueStateChanges(this, newState, callback);\n\t\t} else {\n\t\t\tthrow Error('Inferno Warning: Cannot update state via setState() in componentWillUpdate()');\n\t\t}\n\t};\n\n\tComponent.prototype.componentDidMount = function componentDidMount () {\n\t};\n\n\tComponent.prototype.componentWillMount = function componentWillMount () {\n\t};\n\n\tComponent.prototype.componentWillUnmount = function componentWillUnmount () {\n\t};\n\n\tComponent.prototype.componentDidUpdate = function componentDidUpdate () {\n\t};\n\n\tComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate () {\n\t\treturn true;\n\t};\n\n\tComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps () {\n\t};\n\n\tComponent.prototype.componentWillUpdate = function componentWillUpdate () {\n\t};\n\n\tComponent.prototype.getChildContext = function getChildContext () {\n\t};\n\n\tComponent.prototype._updateComponent = function _updateComponent (prevState, nextState, prevProps, nextProps, force) {\n\t\tif (this._unmounted === true) {\n\t\t\tthis._unmounted = false;\n\t\t\treturn false;\n\t\t}\n\t\tif (!isNullOrUndefined(nextProps) && isNullOrUndefined(nextProps.children)) {\n\t\t\tnextProps.children = prevProps.children;\n\t\t}\n\t\tif (prevProps !== nextProps || prevState !== nextState || force) {\n\t\t\tif (prevProps !== nextProps) {\n\t\t\t\tthis._blockRender = true;\n\t\t\t\tthis.componentWillReceiveProps(nextProps);\n\t\t\t\tthis._blockRender = false;\n\t\t\t\tif (this._pendingSetState) {\n\t\t\t\t\tnextState = Object.assign({}, nextState, this._pendingState);\n\t\t\t\t\tthis._pendingSetState = false;\n\t\t\t\t\tthis._pendingState = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar shouldUpdate = this.shouldComponentUpdate(nextProps, nextState);\n\n\t\t\tif (shouldUpdate !== false || force) {\n\t\t\t\tthis._blockSetState = true;\n\t\t\t\tthis.componentWillUpdate(nextProps, nextState);\n\t\t\t\tthis._blockSetState = false;\n\t\t\t\tthis.props = nextProps;\n\t\t\t\tthis.state = nextState;\n\t\t\t\treturn this.render();\n\t\t\t}\n\t\t}\n\t\treturn NO_RENDER;\n\t};\n\n\t// don't autobind these methods since they already have guaranteed context.\n\tvar AUTOBIND_BLACKLIST = {\n\t\tconstructor: 1,\n\t\trender: 1,\n\t\tshouldComponentUpdate: 1,\n\t\tcomponentWillRecieveProps: 1,\n\t\tcomponentWillUpdate: 1,\n\t\tcomponentDidUpdate: 1,\n\t\tcomponentWillMount: 1,\n\t\tcomponentDidMount: 1,\n\t\tcomponentWillUnmount: 1,\n\t\tcomponentDidUnmount: 1\n\t};\n\n\tfunction F() {\n\t}\n\n\tfunction extend(base, props, all) {\n\t\tfor (var key in props) {\n\t\t\tif (all === true || !isNullOrUndefined(props[key])) {\n\t\t\t\tbase[key] = props[key];\n\t\t\t}\n\t\t}\n\t\treturn base;\n\t}\n\n\tfunction bindAll(ctx) {\n\t\tfor (var i in ctx) {\n\t\t\tvar v = ctx[i];\n\t\t\tif (typeof v === 'function' && !v.__bound && !AUTOBIND_BLACKLIST.hasOwnProperty(i)) {\n\t\t\t\t(ctx[i] = v.bind(ctx)).__bound = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction createClass(obj) {\n\t\tfunction Cl(props) {\n\t\t\textend(this, obj);\n\t\t\tComponent.call(this, props);\n\t\t\tbindAll(this);\n\t\t\tif (this.getInitialState) {\n\t\t\t\tthis.state = this.getInitialState();\n\t\t\t}\n\t\t}\n\n\t\tF.prototype = Component.prototype;\n\t\tCl.prototype = new F();\n\t\tCl.prototype.constructor = Cl;\n\t\tCl.displayName = obj.displayName || 'Component';\n\t\treturn Cl;\n\t}\n\n\treturn createClass;\n\n}));\n\n\n/** WEBPACK FOOTER **\n ** ./~/inferno/dist/inferno-create-class.js\n **/"],"sourceRoot":""}